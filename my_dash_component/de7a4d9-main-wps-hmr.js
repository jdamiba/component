webpackHotUpdatemy_dash_component("main",{

/***/ "./node_modules/react-bulma-components/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-bulma-components/dist/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 37);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! react */ "./node_modules/react/index.js");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

/* global define */
(function () {
  'use strict';

  var hasOwn = {}.hasOwnProperty;

  function classNames() {
    var classes = [];

    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) continue;

      var argType = _typeof(arg);

      if (argType === 'string' || argType === 'number') {
        classes.push(arg);
      } else if (Array.isArray(arg) && arg.length) {
        var inner = classNames.apply(null, arg);

        if (inner) {
          classes.push(inner);
        }
      } else if (argType === 'object') {
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes.push(key);
          }
        }
      }
    }

    return classes.join(' ');
  }

  if (  true && module.exports) {
    classNames.default = classNames;
    module.exports = classNames;
  } else if (  true && _typeof(__webpack_require__(3)) === 'object' && __webpack_require__(3)) {
    // register as 'classnames', consistent with npm package name
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return classNames;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    window.classNames = classNames;
  }
})();

/***/ }),
/* 3 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var components_form_namespaceObject = {};
__webpack_require__.r(components_form_namespaceObject);
__webpack_require__.d(components_form_namespaceObject, "Field", function() { return field; });
__webpack_require__.d(components_form_namespaceObject, "Control", function() { return control; });
__webpack_require__.d(components_form_namespaceObject, "Input", function() { return input; });
__webpack_require__.d(components_form_namespaceObject, "Label", function() { return components_label; });
__webpack_require__.d(components_form_namespaceObject, "Textarea", function() { return components_textarea; });
__webpack_require__.d(components_form_namespaceObject, "Select", function() { return components_select; });
__webpack_require__.d(components_form_namespaceObject, "Checkbox", function() { return components_checkbox; });
__webpack_require__.d(components_form_namespaceObject, "Radio", function() { return components_radio; });
__webpack_require__.d(components_form_namespaceObject, "Help", function() { return help; });
__webpack_require__.d(components_form_namespaceObject, "InputFile", function() { return input_file_InputFile; });

// EXTERNAL MODULE: ./src/index.sass
var src_0 = __webpack_require__(5);

// EXTERNAL MODULE: ./src/components/form/form.sass
var form_form = __webpack_require__(6);

// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(1);
var external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);

// EXTERNAL MODULE: external "prop-types"
var external_prop_types_ = __webpack_require__(0);
var external_prop_types_default = /*#__PURE__*/__webpack_require__.n(external_prop_types_);

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var node_modules_classnames = __webpack_require__(2);
var classnames_default = /*#__PURE__*/__webpack_require__.n(node_modules_classnames);

// CONCATENATED MODULE: ./src/modifiers/helpers.js
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/* harmony default export */ var helpers = ({
  propTypes: {
    clearfix: external_prop_types_default.a.bool,
    pull: external_prop_types_default.a.oneOf([undefined, 'right', 'left']),
    marginless: external_prop_types_default.a.bool,
    paddingless: external_prop_types_default.a.bool,
    overlay: external_prop_types_default.a.bool,
    clipped: external_prop_types_default.a.bool,
    radiusless: external_prop_types_default.a.bool,
    shadowless: external_prop_types_default.a.bool,
    unselectable: external_prop_types_default.a.bool,
    invisible: external_prop_types_default.a.bool,
    hidden: external_prop_types_default.a.bool
  },
  defaultProps: {
    clearfix: undefined,
    pull: undefined,
    marginless: undefined,
    paddingless: undefined,
    overlay: undefined,
    clipped: undefined,
    radiusless: undefined,
    shadowless: undefined,
    unselectable: undefined,
    invisible: undefined,
    hidden: undefined
  },
  classnames: function classnames(props) {
    var _classnames2;

    return classnames_default()((_classnames2 = {
      'is-clearfix': props.clearfix
    }, _defineProperty(_classnames2, "is-pulled-".concat(props.pull), props.pull), _defineProperty(_classnames2, 'is-marginless', props.marginless), _defineProperty(_classnames2, 'is-paddingless', props.paddingless), _defineProperty(_classnames2, 'is-overlay', props.overlay), _defineProperty(_classnames2, 'is-clipped', props.clipped), _defineProperty(_classnames2, 'is-radiusless', props.radiusless), _defineProperty(_classnames2, 'is-shadowless', props.shadowless), _defineProperty(_classnames2, 'is-unselectable', props.unselectable), _defineProperty(_classnames2, 'is-invisible', props.invisible), _defineProperty(_classnames2, 'is-hidden', props.hidden), _classnames2));
  },
  clean: function clean(_ref) {
    var hidden = _ref.hidden,
        clearfix = _ref.clearfix,
        paddingless = _ref.paddingless,
        pull = _ref.pull,
        marginless = _ref.marginless,
        overlay = _ref.overlay,
        clipped = _ref.clipped,
        radiusless = _ref.radiusless,
        shadowless = _ref.shadowless,
        unselectable = _ref.unselectable,
        invisible = _ref.invisible,
        props = _objectWithoutProperties(_ref, ["hidden", "clearfix", "paddingless", "pull", "marginless", "overlay", "clipped", "radiusless", "shadowless", "unselectable", "invisible"]);

    return props;
  }
});
// CONCATENATED MODULE: ./src/modifiers/responsives.js
function responsives_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = responsives_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function responsives_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { responsives_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function responsives_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var displays = ['block', 'flex', 'inline', 'inline-block', 'inline-flex'];

var getSizeClassFromProp = function getSizeClassFromProp(sizes) {
  return Object.keys(sizes).reduce(function (classes, size) {
    var _objectSpread2;

    var display = sizes[size].display || {};
    var hide = sizes[size].hide || {};
    var textSize = sizes[size].textSize || {};
    var textAlignment = sizes[size].textAlignment || {};

    var obj = _objectSpread({}, classes, (_objectSpread2 = {}, responsives_defineProperty(_objectSpread2, "is-".concat(display.value, "-").concat(size).concat(display.only ? '-only' : ''), display.value), responsives_defineProperty(_objectSpread2, "is-hidden-".concat(size).concat(hide.only ? '-only' : ''), hide.value), responsives_defineProperty(_objectSpread2, "has-text-".concat(textAlignment.value, "-").concat(size).concat(textAlignment.only ? '-only' : ''), textAlignment.value), responsives_defineProperty(_objectSpread2, "is-size-".concat(textSize.value, "-").concat(size), textSize.value > 0), _objectSpread2));

    return obj;
  }, {});
};

var sizeShape = external_prop_types_default.a.shape({
  display: external_prop_types_default.a.shape({
    value: external_prop_types_default.a.oneOf(displays),
    only: external_prop_types_default.a.bool
  }),
  hide: external_prop_types_default.a.shape({
    value: external_prop_types_default.a.bool,
    only: external_prop_types_default.a.bool
  }),
  textSize: external_prop_types_default.a.shape({
    value: external_prop_types_default.a.oneOf([1, 2, 3, 4, 5, 6])
  }),
  textAlignment: external_prop_types_default.a.shape({
    value: external_prop_types_default.a.oneOf(['centered', 'justified', 'left', 'right']),
    only: external_prop_types_default.a.bool
  })
});
/* harmony default export */ var responsives = ({
  propTypes: {
    responsive: external_prop_types_default.a.shape({
      mobile: sizeShape,
      tablet: sizeShape,
      desktop: sizeShape,
      widescreen: sizeShape,
      fullhd: sizeShape,
      touch: sizeShape
    })
  },
  defaultProps: {
    responsive: undefined
  },
  classnames: function classnames(props) {
    return classnames_default()(_objectSpread({}, getSizeClassFromProp(props.responsive || {})));
  },
  clean: function clean(_ref) {
    var responsive = _ref.responsive,
        hide = _ref.hide,
        props = responsives_objectWithoutProperties(_ref, ["responsive", "hide"]);

    return props;
  }
});
// CONCATENATED MODULE: ./src/modifiers/colors.js
function colors_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = colors_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function colors_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function colors_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // const colors = ['white', 'black', 'light', 'dark', 'primary', 'info', 'link', 'success', 'warning', 'danger', 'black-bis', 'black-ter', 'grey-darker', 'grey-dark', 'grey', 'grey-light', 'grey-lighter', 'white-ter', 'white-bis'];

/* harmony default export */ var colors = ({
  propTypes: {
    textColor: external_prop_types_default.a.string,
    backgroundColor: external_prop_types_default.a.string,
    colorVariant: external_prop_types_default.a.oneOf(['light', 'dark'])
  },
  defaultProps: {
    textColor: undefined,
    backgroundColor: undefined,
    colorVariant: undefined
  },
  classnames: function classnames(props) {
    var _classnames2;

    return classnames_default()((_classnames2 = {}, colors_defineProperty(_classnames2, "has-text-".concat(props.textColor), props.textColor), colors_defineProperty(_classnames2, "has-background-".concat(props.backgroundColor), props.backgroundColor), colors_defineProperty(_classnames2, "is-".concat(props.colorVariant), props.colorVariant), _classnames2));
  },
  clean: function clean(_ref) {
    var textColor = _ref.textColor,
        backgroundColor = _ref.backgroundColor,
        colorVariant = _ref.colorVariant,
        props = colors_objectWithoutProperties(_ref, ["textColor", "backgroundColor", "colorVariant"]);

    return props;
  }
});
// CONCATENATED MODULE: ./src/modifiers/typography.js
function typography_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = typography_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function typography_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function typography_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/* harmony default export */ var typography = ({
  propTypes: {
    textSize: external_prop_types_default.a.oneOf([1, 2, 3, 4, 5, 6]),
    textAlignment: external_prop_types_default.a.oneOf(['centered', 'justified', 'left', 'right']),
    textTransform: external_prop_types_default.a.oneOf(['capitalized', 'lowercase', 'uppercase']),
    textWeight: external_prop_types_default.a.oneOf(['light', 'normal', 'semibold', 'bold']),
    italic: external_prop_types_default.a.bool
  },
  defaultProps: {
    textSize: undefined,
    textAlignment: undefined,
    textTransform: undefined,
    italic: undefined,
    textWeight: undefined
  },
  classnames: function classnames(props) {
    var _classnames2;

    return classnames_default()((_classnames2 = {}, typography_defineProperty(_classnames2, "has-text-".concat(props.textAlignment), props.textAlignment), typography_defineProperty(_classnames2, "has-text-weight-".concat(props.textWeight), props.textWeight), typography_defineProperty(_classnames2, "is-size-".concat(props.textSize), props.textSize), typography_defineProperty(_classnames2, "is-".concat(props.textTransform), props.textTransform), typography_defineProperty(_classnames2, 'is-italic', props.italic), _classnames2));
  },
  clean: function clean(_ref) {
    var textWeight = _ref.textWeight,
        textTransform = _ref.textTransform,
        italic = _ref.italic,
        textSize = _ref.textSize,
        textAlignment = _ref.textAlignment,
        props = typography_objectWithoutProperties(_ref, ["textWeight", "textTransform", "italic", "textSize", "textAlignment"]);

    return props;
  }
});
// CONCATENATED MODULE: ./src/modifiers/index.js
function modifiers_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function modifiers_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { modifiers_ownKeys(source, true).forEach(function (key) { modifiers_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { modifiers_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function modifiers_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var compose = function compose() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function (args) {
    return fns.reduce(function (arg, fn) {
      return fn(arg);
    }, args);
  };
};

/* harmony default export */ var modifiers = ({
  propTypes: modifiers_objectSpread({}, helpers.propTypes, {}, responsives.propTypes, {}, colors.propTypes, {}, typography.propTypes),
  defaultProps: modifiers_objectSpread({}, helpers.defaultProps, {}, responsives.defaultProps, {}, colors.defaultProps, {}, typography.defaultProps),
  classnames: function classnames(props) {
    return classnames_default()(helpers.classnames(props), responsives.classnames(props), colors.classnames(props), typography.classnames(props));
  },
  clean: function clean(props) {
    return compose(helpers.clean, responsives.clean, colors.clean, typography.clean)(props);
  }
});
// CONCATENATED MODULE: ./src/modifiers/render-as.js

var renderAsShape = external_prop_types_default.a.oneOfType([external_prop_types_default.a.string, external_prop_types_default.a.func, external_prop_types_default.a.object]);
/* harmony default export */ var render_as = (renderAsShape);
// CONCATENATED MODULE: ./src/components/element/element.js
function element_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function element_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { element_ownKeys(source, true).forEach(function (key) { element_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { element_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function element_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function element_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = element_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function element_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var element_Element = function Element(_ref) {
  var className = _ref.className,
      renderAs = _ref.renderAs,
      domRef = _ref.domRef,
      allProps = element_objectWithoutProperties(_ref, ["className", "renderAs", "domRef"]);

  var RenderAs = renderAs;
  var props = modifiers.clean(allProps);
  return external_react_default.a.createElement(RenderAs, _extends({
    ref: domRef,
    className: classnames_default()(className, modifiers.classnames(allProps)) || undefined
  }, props));
};

element_Element.propTypes = element_objectSpread({}, modifiers.propTypes, {
  /**
   * Reference to Dom element
   */
  domRef: external_prop_types_default.a.object,
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
element_Element.defaultProps = element_objectSpread({}, modifiers.defaultProps, {
  domRef: undefined,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var element_element = (element_Element);
// CONCATENATED MODULE: ./src/components/element/index.js

/* harmony default export */ var components_element = (element_element);
// CONCATENATED MODULE: ./src/components/form/components/field/field-label.js
function field_label_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function field_label_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { field_label_ownKeys(source, true).forEach(function (key) { field_label_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { field_label_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function field_label_extends() { field_label_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return field_label_extends.apply(this, arguments); }

function field_label_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function field_label_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = field_label_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function field_label_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var field_label_FieldLabel = function FieldLabel(_ref) {
  var children = _ref.children,
      className = _ref.className,
      size = _ref.size,
      props = field_label_objectWithoutProperties(_ref, ["children", "className", "size"]);

  return external_react_default.a.createElement(components_element, field_label_extends({}, props, {
    className: classnames_default()('field-label', className, field_label_defineProperty({}, "is-".concat(size), size))
  }), children);
};

field_label_FieldLabel.propTypes = field_label_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  size: external_prop_types_default.a.oneOf(['small', 'normal', 'medium', 'large'])
});
field_label_FieldLabel.defaultProps = field_label_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div',
  size: undefined
});
/* harmony default export */ var field_label = (field_label_FieldLabel);
// CONCATENATED MODULE: ./src/components/form/components/field/field-body.js
function field_body_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function field_body_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { field_body_ownKeys(source, true).forEach(function (key) { field_body_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { field_body_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function field_body_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function field_body_extends() { field_body_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return field_body_extends.apply(this, arguments); }

function field_body_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = field_body_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function field_body_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var field_body_FieldBody = function FieldBody(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = field_body_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, field_body_extends({}, props, {
    className: classnames_default()('field-body', className, {})
  }), children);
};

field_body_FieldBody.propTypes = field_body_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
field_body_FieldBody.defaultProps = field_body_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var field_body = (field_body_FieldBody);
// CONCATENATED MODULE: ./src/components/form/components/field/field.js
function field_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function field_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { field_ownKeys(source, true).forEach(function (key) { field_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { field_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function field_extends() { field_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return field_extends.apply(this, arguments); }

function field_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function field_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = field_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function field_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }










var field_Field = function Field(_ref) {
  var _classnames;

  var className = _ref.className,
      align = _ref.align,
      multiline = _ref.multiline,
      horizontal = _ref.horizontal,
      kind = _ref.kind,
      props = field_objectWithoutProperties(_ref, ["className", "align", "multiline", "horizontal", "kind"]);

  var k = null;

  if (kind === 'addons') {
    k = 'has-addons';
  } else if (kind === 'group') {
    k = 'is-grouped';
  }

  return external_react_default.a.createElement(components_element, field_extends({}, props, {
    className: classnames_default()('field', className, (_classnames = {}, field_defineProperty(_classnames, "".concat(k), k), field_defineProperty(_classnames, "".concat(k, "-").concat(align), k && align), field_defineProperty(_classnames, "".concat(k, "-multiline"), k === 'is-grouped' && multiline), field_defineProperty(_classnames, 'is-horizontal', horizontal), _classnames))
  }));
};

field_Field.Label = field_label;
field_Field.Body = field_body;
field_Field.propTypes = field_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  align: external_prop_types_default.a.oneOf(['centered', 'right']),
  kind: external_prop_types_default.a.oneOf(['addons', 'group']),
  multiline: external_prop_types_default.a.bool,
  horizontal: external_prop_types_default.a.bool
});
field_Field.defaultProps = field_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div',
  align: undefined,
  kind: undefined,
  multiline: undefined,
  horizontal: undefined
});
/* harmony default export */ var field = (field_Field);
// CONCATENATED MODULE: ./src/components/form/components/field/index.js

// CONCATENATED MODULE: ./src/components/form/components/control.js
function control_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function control_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { control_ownKeys(source, true).forEach(function (key) { control_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { control_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function control_extends() { control_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return control_extends.apply(this, arguments); }

function control_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function control_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = control_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function control_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var control_Control = function Control(_ref) {
  var children = _ref.children,
      className = _ref.className,
      fullwidth = _ref.fullwidth,
      iconLeft = _ref.iconLeft,
      iconRight = _ref.iconRight,
      loading = _ref.loading,
      size = _ref.size,
      props = control_objectWithoutProperties(_ref, ["children", "className", "fullwidth", "iconLeft", "iconRight", "loading", "size"]);

  return external_react_default.a.createElement(components_element, control_extends({}, props, {
    className: classnames_default()('control', className, control_defineProperty({
      'is-expanded': fullwidth,
      'has-icons-left': iconLeft,
      'has-icons-right': iconRight,
      'is-loading': loading
    }, "is-".concat(size), size))
  }), children);
};

control_Control.propTypes = control_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  fullwidth: external_prop_types_default.a.bool,
  iconLeft: external_prop_types_default.a.bool,
  iconRight: external_prop_types_default.a.bool,
  loading: external_prop_types_default.a.bool,
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large'])
});
control_Control.defaultProps = control_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div',
  fullwidth: undefined,
  iconLeft: undefined,
  iconRight: undefined,
  loading: undefined,
  size: undefined
});
/* harmony default export */ var control = (control_Control);
// CONCATENATED MODULE: ./src/constants.js
/* harmony default export */ var constants = ({
  BREAKPOINTS: {
    DESKTOP: 'desktop',
    TABLET: 'tablet',
    MOBILE: 'mobile',
    WIDESCREEN: 'widescreen',
    FULLHD: 'fullhd',
    TOUCH: 'touch'
  },
  COLORS: {
    PRIMARY: 'primary',
    SUCCESS: 'success',
    INFO: 'info',
    WARNING: 'warning',
    DANGER: 'danger',
    LIGHT: 'light',
    DARK: 'dark',
    WHITE: 'white',
    BLACK: 'black',
    LINK: 'link'
  },
  COLOR_VARIANT: {
    light: 'light',
    dark: 'dark'
  }
});
// CONCATENATED MODULE: ./src/components/form/components/input.js
function input_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function input_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { input_ownKeys(source, true).forEach(function (key) { input_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { input_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function input_extends() { input_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return input_extends.apply(this, arguments); }

function input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function input_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = input_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function input_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var input_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var input_Input = function Input(_ref) {
  var _classnames;

  var className = _ref.className,
      type = _ref.type,
      size = _ref.size,
      color = _ref.color,
      readOnly = _ref.readOnly,
      isStatic = _ref.isStatic,
      disabled = _ref.disabled,
      placeholder = _ref.placeholder,
      value = _ref.value,
      name = _ref.name,
      props = input_objectWithoutProperties(_ref, ["className", "type", "size", "color", "readOnly", "isStatic", "disabled", "placeholder", "value", "name"]);

  return external_react_default.a.createElement(components_element, input_extends({}, props, {
    renderAs: "input",
    name: name,
    value: value,
    type: type,
    placeholder: placeholder,
    readOnly: readOnly || isStatic,
    disabled: disabled,
    className: classnames_default()('input', className, (_classnames = {
      'is-static': isStatic
    }, input_defineProperty(_classnames, "is-".concat(size), size), input_defineProperty(_classnames, "is-".concat(color), color), _classnames))
  }));
};

input_Input.propTypes = input_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  type: external_prop_types_default.a.oneOf(['text', 'email', 'tel', 'password', 'number', 'search', 'color', 'date', 'time', 'datetime-local']),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),
  color: external_prop_types_default.a.oneOf(input_colors),
  readOnly: external_prop_types_default.a.bool,
  isStatic: external_prop_types_default.a.bool,
  disabled: external_prop_types_default.a.bool,
  placeholder: external_prop_types_default.a.string,
  value: external_prop_types_default.a.oneOfType([external_prop_types_default.a.string, external_prop_types_default.a.number]),

  /**
   * The name of the input field Commonly used for [multi-input handling](https://reactjs.org/docs/forms.html#handling-multiple-inputs)
   */
  name: external_prop_types_default.a.string
});
input_Input.defaultProps = input_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  value: '',
  style: undefined,
  type: 'text',
  size: undefined,
  color: undefined,
  readOnly: false,
  isStatic: false,
  disabled: false,
  placeholder: '',
  name: undefined
});
/* harmony default export */ var input = (input_Input);
// CONCATENATED MODULE: ./src/components/form/components/label.js
function label_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function label_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { label_ownKeys(source, true).forEach(function (key) { label_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { label_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function label_extends() { label_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return label_extends.apply(this, arguments); }

function label_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function label_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = label_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function label_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var label_Label = function Label(_ref) {
  var children = _ref.children,
      className = _ref.className,
      size = _ref.size,
      props = label_objectWithoutProperties(_ref, ["children", "className", "size"]);

  return external_react_default.a.createElement(components_element, label_extends({
    renderAs: "label"
  }, props, {
    className: classnames_default()('label', className, label_defineProperty({}, "is-".concat(size), size))
  }), children);
};

label_Label.propTypes = label_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  htmlFor: external_prop_types_default.a.string,
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large'])
});
label_Label.defaultProps = label_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  size: undefined,
  htmlFor: undefined
});
/* harmony default export */ var components_label = (label_Label);
// CONCATENATED MODULE: ./src/components/form/components/textarea.js
function textarea_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function textarea_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { textarea_ownKeys(source, true).forEach(function (key) { textarea_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { textarea_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function textarea_extends() { textarea_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return textarea_extends.apply(this, arguments); }

function textarea_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function textarea_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = textarea_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function textarea_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var textarea_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var textarea_Textarea = function Textarea(_ref) {
  var _classnames;

  var className = _ref.className,
      size = _ref.size,
      color = _ref.color,
      readOnly = _ref.readOnly,
      disabled = _ref.disabled,
      placeholder = _ref.placeholder,
      rows = _ref.rows,
      value = _ref.value,
      name = _ref.name,
      props = textarea_objectWithoutProperties(_ref, ["className", "size", "color", "readOnly", "disabled", "placeholder", "rows", "value", "name"]);

  return external_react_default.a.createElement(components_element, textarea_extends({
    renderAs: "textarea",
    name: name
  }, props, {
    value: value,
    rows: rows,
    placeholder: placeholder,
    readOnly: readOnly,
    disabled: disabled,
    className: classnames_default()('textarea', className, (_classnames = {}, textarea_defineProperty(_classnames, "is-".concat(size), size), textarea_defineProperty(_classnames, "is-".concat(color), color), _classnames))
  }));
};

textarea_Textarea.propTypes = textarea_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),
  color: external_prop_types_default.a.oneOf(textarea_colors),
  readOnly: external_prop_types_default.a.bool,
  disabled: external_prop_types_default.a.bool,
  placeholder: external_prop_types_default.a.string,
  rows: external_prop_types_default.a.number,
  value: external_prop_types_default.a.string,

  /**
   * The name of the input field Commonly used for [multi-input handling](https://reactjs.org/docs/forms.html#handling-multiple-inputs)
   */
  name: external_prop_types_default.a.string
});
textarea_Textarea.defaultProps = textarea_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  style: undefined,
  size: undefined,
  color: undefined,
  readOnly: false,
  disabled: false,
  placeholder: '',
  rows: 4,
  value: '',
  name: ''
});
/* harmony default export */ var components_textarea = (textarea_Textarea);
// CONCATENATED MODULE: ./src/components/form/components/select.js
function select_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { select_ownKeys(source, true).forEach(function (key) { select_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { select_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function select_extends() { select_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return select_extends.apply(this, arguments); }

function select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function select_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = select_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function select_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var select_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var select_Select = function Select(_ref) {
  var _classnames;

  var className = _ref.className,
      style = _ref.style,
      size = _ref.size,
      color = _ref.color,
      loading = _ref.loading,
      readOnly = _ref.readOnly,
      disabled = _ref.disabled,
      value = _ref.value,
      multiple = _ref.multiple,
      children = _ref.children,
      name = _ref.name,
      domRef = _ref.domRef,
      props = select_objectWithoutProperties(_ref, ["className", "style", "size", "color", "loading", "readOnly", "disabled", "value", "multiple", "children", "name", "domRef"]);

  return external_react_default.a.createElement(components_element, {
    domRef: domRef,
    className: classnames_default()('select', className, (_classnames = {}, select_defineProperty(_classnames, "is-".concat(size), size), select_defineProperty(_classnames, "is-".concat(color), color), select_defineProperty(_classnames, 'is-loading', loading), select_defineProperty(_classnames, 'is-multiple', multiple), _classnames)),
    style: style
  }, external_react_default.a.createElement(components_element, select_extends({
    renderAs: "select"
  }, props, {
    multiple: multiple,
    value: value,
    readOnly: readOnly,
    disabled: disabled,
    name: name
  }), children));
};

select_Select.propTypes = select_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),
  color: external_prop_types_default.a.oneOf(select_colors),
  readOnly: external_prop_types_default.a.bool,
  disabled: external_prop_types_default.a.bool,
  multiple: external_prop_types_default.a.bool,
  loading: external_prop_types_default.a.bool,
  value: external_prop_types_default.a.oneOfType([external_prop_types_default.a.string, external_prop_types_default.a.number]),

  /**
   * The name of the input field Commonly used for [multi-input handling](https://reactjs.org/docs/forms.html#handling-multiple-inputs)
   */
  name: external_prop_types_default.a.string
});
select_Select.defaultProps = select_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  value: '',
  style: undefined,
  size: undefined,
  color: undefined,
  readOnly: false,
  disabled: false,
  multiple: false,
  loading: false,
  name: undefined
});
/* harmony default export */ var components_select = (select_Select);
// CONCATENATED MODULE: ./src/components/form/components/checkbox.js
function checkbox_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function checkbox_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { checkbox_ownKeys(source, true).forEach(function (key) { checkbox_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { checkbox_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function checkbox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function checkbox_extends() { checkbox_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return checkbox_extends.apply(this, arguments); }

function checkbox_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = checkbox_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function checkbox_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var checkbox_Checkbox = function Checkbox(_ref) {
  var className = _ref.className,
      style = _ref.style,
      disabled = _ref.disabled,
      value = _ref.value,
      children = _ref.children,
      checked = _ref.checked,
      name = _ref.name,
      domRef = _ref.domRef,
      props = checkbox_objectWithoutProperties(_ref, ["className", "style", "disabled", "value", "children", "checked", "name", "domRef"]);

  return external_react_default.a.createElement(components_element, {
    renderAs: "label",
    domRef: domRef,
    disabled: disabled,
    className: classnames_default()('checkbox', className),
    style: style
  }, external_react_default.a.createElement(components_element, checkbox_extends({}, props, {
    renderAs: "input",
    name: name,
    type: "checkbox",
    value: value,
    disabled: disabled,
    checked: checked
  })), children);
};

checkbox_Checkbox.propTypes = checkbox_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  disabled: external_prop_types_default.a.bool,
  value: external_prop_types_default.a.string,
  checked: external_prop_types_default.a.bool,

  /**
   * The name of the input field Commonly used for [multi-input handling](https://reactjs.org/docs/forms.html#handling-multiple-inputs)
   */
  name: external_prop_types_default.a.string
});
checkbox_Checkbox.defaultProps = checkbox_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  value: undefined,
  style: undefined,
  disabled: undefined,
  checked: undefined,
  name: undefined
});
/* harmony default export */ var components_checkbox = (checkbox_Checkbox);
// CONCATENATED MODULE: ./src/components/form/components/radio.js
function radio_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function radio_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radio_ownKeys(source, true).forEach(function (key) { radio_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radio_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radio_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function radio_extends() { radio_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return radio_extends.apply(this, arguments); }

function radio_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = radio_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function radio_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var radio_Radio = function Radio(_ref) {
  var className = _ref.className,
      style = _ref.style,
      disabled = _ref.disabled,
      checked = _ref.checked,
      value = _ref.value,
      name = _ref.name,
      children = _ref.children,
      domRef = _ref.domRef,
      props = radio_objectWithoutProperties(_ref, ["className", "style", "disabled", "checked", "value", "name", "children", "domRef"]);

  return external_react_default.a.createElement(components_element, {
    renderAs: "label",
    domRef: domRef,
    disabled: disabled,
    className: classnames_default()('radio', className),
    style: style
  }, external_react_default.a.createElement(components_element, radio_extends({
    renderAs: "input"
  }, props, {
    name: name,
    checked: checked,
    type: "radio",
    value: value,
    disabled: disabled
  })), children);
};

radio_Radio.propTypes = radio_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,

  /**
   * The name of the input field Commonly used for [multi-input handling](https://reactjs.org/docs/forms.html#handling-multiple-inputs)
   */
  name: external_prop_types_default.a.string.isRequired,
  style: external_prop_types_default.a.shape({}),
  disabled: external_prop_types_default.a.bool,
  checked: external_prop_types_default.a.bool,
  value: external_prop_types_default.a.string
});
radio_Radio.defaultProps = radio_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  value: '',
  style: undefined,
  disabled: false,
  checked: false
});
/* harmony default export */ var components_radio = (radio_Radio);
// CONCATENATED MODULE: ./src/components/form/components/help.js
function help_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function help_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { help_ownKeys(source, true).forEach(function (key) { help_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { help_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function help_extends() { help_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return help_extends.apply(this, arguments); }

function help_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function help_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = help_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function help_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var help_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var help_Help = function Help(_ref) {
  var className = _ref.className,
      children = _ref.children,
      color = _ref.color,
      props = help_objectWithoutProperties(_ref, ["className", "children", "color"]);

  return external_react_default.a.createElement(components_element, help_extends({}, props, {
    className: classnames_default()('help', className, help_defineProperty({}, "is-".concat(color), color))
  }), children);
};

help_Help.propTypes = help_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  color: external_prop_types_default.a.oneOf(help_colors),
  children: external_prop_types_default.a.node
});
help_Help.defaultProps = help_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  color: undefined,
  renderAs: 'p'
});
/* harmony default export */ var help = (help_Help);
// CONCATENATED MODULE: ./src/components/form/components/input-file.js
function input_file_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function input_file_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { input_file_ownKeys(source, true).forEach(function (key) { input_file_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { input_file_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function input_file_extends() { input_file_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return input_file_extends.apply(this, arguments); }

function input_file_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = input_file_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function input_file_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function input_file_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var input_file_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var input_file_InputFile =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(InputFile, _PureComponent);

  function InputFile(props) {
    var _this;

    _classCallCheck(this, InputFile);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(InputFile).call(this, props));

    input_file_defineProperty(_assertThisInitialized(_this), "select", function (event) {
      var files = event.target.files;

      _this.setState({
        filename: files.length > 0 ? files[0].name : undefined
      });

      if (_this.props.onChange) {
        _this.props.onChange(event);
      }
    });

    _this.state = {
      filename: undefined
    };
    return _this;
  }

  _createClass(InputFile, [{
    key: "render",
    value: function render() {
      var _classnames;

      var _this$props = this.props,
          className = _this$props.className,
          style = _this$props.style,
          onChange = _this$props.onChange,
          color = _this$props.color,
          size = _this$props.size,
          fileName = _this$props.fileName,
          fullwidth = _this$props.fullwidth,
          right = _this$props.right,
          boxed = _this$props.boxed,
          name = _this$props.name,
          label = _this$props.label,
          icon = _this$props.icon,
          inputProps = _this$props.inputProps,
          props = input_file_objectWithoutProperties(_this$props, ["className", "style", "onChange", "color", "size", "fileName", "fullwidth", "right", "boxed", "name", "label", "icon", "inputProps"]);

      var filename = this.state.filename;
      return external_react_default.a.createElement(components_element, input_file_extends({
        style: style
      }, props, {
        className: classnames_default()('file', className, (_classnames = {}, input_file_defineProperty(_classnames, "is-".concat(size), size), input_file_defineProperty(_classnames, "is-".concat(color), color), input_file_defineProperty(_classnames, 'has-name', !fileName), input_file_defineProperty(_classnames, 'is-right', right), input_file_defineProperty(_classnames, 'is-boxed', boxed), input_file_defineProperty(_classnames, 'is-fullwidth', fullwidth), _classnames))
      }), external_react_default.a.createElement("label", {
        className: "file-label"
      }, external_react_default.a.createElement("input", input_file_extends({}, inputProps, {
        name: name,
        type: "file",
        className: "file-input",
        onChange: this.select
      })), external_react_default.a.createElement("span", {
        className: "file-cta"
      }, icon && external_react_default.a.createElement("span", {
        className: "file-icon"
      }, icon), external_react_default.a.createElement("span", {
        className: "file-label"
      }, label)), fileName && filename && external_react_default.a.createElement("span", {
        className: "file-name"
      }, filename)));
    }
  }]);

  return InputFile;
}(external_react_["PureComponent"]);


input_file_InputFile.propTypes = input_file_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  onChange: external_prop_types_default.a.func,
  color: external_prop_types_default.a.oneOf(input_file_colors),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),
  fileName: external_prop_types_default.a.bool,
  fullwidth: external_prop_types_default.a.bool,
  right: external_prop_types_default.a.bool,
  boxed: external_prop_types_default.a.bool,

  /**
   * The name of the input field Commonly used for [multi-input handling](https://reactjs.org/docs/forms.html#handling-multiple-inputs)
   */
  name: external_prop_types_default.a.string,
  label: external_prop_types_default.a.string,
  icon: external_prop_types_default.a.element,
  inputProps: external_prop_types_default.a.shape({
    accept: external_prop_types_default.a.string,
    capture: external_prop_types_default.a.string,
    multiple: external_prop_types_default.a.bool
  })
});
input_file_InputFile.defaultProps = input_file_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  style: undefined,
  onChange: function onChange() {},
  color: undefined,
  size: undefined,
  fileName: true,
  fullwidth: undefined,
  right: undefined,
  boxed: undefined,
  name: undefined,
  icon: undefined,
  label: 'Choose a file...',
  inputProps: {
    accept: undefined,
    capture: undefined,
    multiple: undefined
  }
});
// CONCATENATED MODULE: ./src/components/form/index.js











// CONCATENATED MODULE: ./src/components/box/box.js
function box_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function box_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { box_ownKeys(source, true).forEach(function (key) { box_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { box_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function box_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function box_extends() { box_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return box_extends.apply(this, arguments); }

function box_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = box_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function box_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var box_Box = function Box(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = box_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, box_extends({}, props, {
    className: classnames_default()('box', className)
  }), children);
};

box_Box.propTypes = box_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
box_Box.defaultProps = box_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var box = (box_Box);
// EXTERNAL MODULE: ./src/components/box/box.sass
var box_box = __webpack_require__(7);

// CONCATENATED MODULE: ./src/components/box/index.js


/* harmony default export */ var components_box = (box);
// EXTERNAL MODULE: ./src/components/button/button.sass
var button_button = __webpack_require__(8);

// CONCATENATED MODULE: ./src/components/button/components/button-group.js
function button_group_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function button_group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { button_group_ownKeys(source, true).forEach(function (key) { button_group_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { button_group_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function button_group_extends() { button_group_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return button_group_extends.apply(this, arguments); }

function button_group_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function button_group_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = button_group_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function button_group_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var button_group_ButtonGroup = function ButtonGroup(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      hasAddons = _ref.hasAddons,
      position = _ref.position,
      size = _ref.size,
      props = button_group_objectWithoutProperties(_ref, ["children", "className", "hasAddons", "position", "size"]);

  return external_react_default.a.createElement(components_element, button_group_extends({}, props, {
    className: classnames_default()('buttons', className, (_classnames = {
      'has-addons': hasAddons
    }, button_group_defineProperty(_classnames, "is-".concat([position]), position), button_group_defineProperty(_classnames, "are-".concat(size), size), _classnames))
  }), children);
};

button_group_ButtonGroup.propTypes = button_group_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  hasAddons: external_prop_types_default.a.bool,
  size: external_prop_types_default.a.string,
  position: external_prop_types_default.a.oneOf(['centered', 'right']),
  renderAs: render_as
});
button_group_ButtonGroup.defaultProps = button_group_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  hasAddons: undefined,
  position: undefined,
  size: undefined,
  renderAs: 'div'
});
/* harmony default export */ var button_group = (button_group_ButtonGroup);
// CONCATENATED MODULE: ./src/components/button/button.js
function button_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { button_ownKeys(source, true).forEach(function (key) { button_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { button_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function button_extends() { button_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return button_extends.apply(this, arguments); }

function button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function button_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = button_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function button_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var button_colors = [null, ''].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var button_Button = function Button(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      renderAs = _ref.renderAs,
      color = _ref.color,
      size = _ref.size,
      outlined = _ref.outlined,
      inverted = _ref.inverted,
      state = _ref.state,
      submit = _ref.submit,
      reset = _ref.reset,
      fullwidth = _ref.fullwidth,
      loading = _ref.loading,
      disabled = _ref.disabled,
      remove = _ref.remove,
      isSelected = _ref.isSelected,
      isStatic = _ref.isStatic,
      rounded = _ref.rounded,
      onClick = _ref.onClick,
      text = _ref.text,
      props = button_objectWithoutProperties(_ref, ["children", "className", "renderAs", "color", "size", "outlined", "inverted", "state", "submit", "reset", "fullwidth", "loading", "disabled", "remove", "isSelected", "isStatic", "rounded", "onClick", "text"]);

  // let Element = isStatic ? 'span' : renderAs;
  var otherProps = {};

  if (submit) {
    otherProps = {
      type: 'submit',
      renderAs: renderAs || 'button'
    };
  }

  if (reset) {
    otherProps = {
      type: 'reset',
      renderAs: renderAs || 'button'
    };
  }

  if (isStatic) {
    otherProps = {
      renderAs: 'span'
    };
  }

  return external_react_default.a.createElement(components_element, button_extends({
    tabIndex: disabled ? -1 : 0,
    renderAs: renderAs
  }, props, otherProps, {
    disabled: disabled,
    onClick: disabled ? undefined : onClick,
    className: classnames_default()(className, (_classnames = {}, button_defineProperty(_classnames, "is-".concat(color), color), button_defineProperty(_classnames, "is-".concat(size), size), button_defineProperty(_classnames, "is-".concat(state), state), button_defineProperty(_classnames, 'is-selected', isSelected), button_defineProperty(_classnames, 'is-static', isStatic), button_defineProperty(_classnames, 'is-rounded', rounded), button_defineProperty(_classnames, 'is-outlined', outlined), button_defineProperty(_classnames, 'is-inverted', inverted), button_defineProperty(_classnames, 'is-fullwidth', fullwidth), button_defineProperty(_classnames, 'is-loading', loading), button_defineProperty(_classnames, 'is-text', text), button_defineProperty(_classnames, "delete", remove), button_defineProperty(_classnames, "button", !remove), _classnames))
  }), children);
};

button_Button.Group = button_group;
button_Button.propTypes = button_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  onClick: external_prop_types_default.a.func,
  color: external_prop_types_default.a.oneOf(button_colors),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),
  state: external_prop_types_default.a.oneOf(['hover', 'focus', 'active', 'loading']),
  outlined: external_prop_types_default.a.bool,
  inverted: external_prop_types_default.a.bool,
  submit: external_prop_types_default.a.bool,
  reset: external_prop_types_default.a.bool,
  loading: external_prop_types_default.a.bool,
  fullwidth: external_prop_types_default.a.bool,
  disabled: external_prop_types_default.a.bool,
  remove: external_prop_types_default.a.bool,
  isSelected: external_prop_types_default.a.bool,
  isStatic: external_prop_types_default.a.bool,
  rounded: external_prop_types_default.a.bool,
  text: external_prop_types_default.a.bool
});
button_Button.defaultProps = button_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'button',
  onClick: function onClick() {
    return null;
  },
  color: undefined,
  size: undefined,
  state: undefined,
  outlined: false,
  inverted: false,
  submit: false,
  reset: false,
  fullwidth: false,
  loading: false,
  disabled: false,
  remove: false,
  isSelected: false,
  isStatic: false,
  rounded: false,
  text: false
});
/* harmony default export */ var components_button_button = (button_Button);
// CONCATENATED MODULE: ./src/components/button/index.js


// CONCATENATED MODULE: ./src/components/breadcrumb/breadcrumb.js
function breadcrumb_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function breadcrumb_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { breadcrumb_ownKeys(source, true).forEach(function (key) { breadcrumb_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { breadcrumb_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function breadcrumb_extends() { breadcrumb_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return breadcrumb_extends.apply(this, arguments); }

function breadcrumb_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function breadcrumb_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = breadcrumb_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function breadcrumb_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var breadcrumb_Breadcrumb = function Breadcrumb(_ref) {
  var _classnames;

  var className = _ref.className,
      items = _ref.items,
      renderAs = _ref.renderAs,
      hrefAttr = _ref.hrefAttr,
      separator = _ref.separator,
      size = _ref.size,
      align = _ref.align,
      props = breadcrumb_objectWithoutProperties(_ref, ["className", "items", "renderAs", "hrefAttr", "separator", "size", "align"]);

  return external_react_default.a.createElement(components_element, breadcrumb_extends({
    renderAs: "nav"
  }, props, {
    className: classnames_default()('breadcrumb', className, (_classnames = {}, breadcrumb_defineProperty(_classnames, "has-".concat(separator, "-separator"), separator), breadcrumb_defineProperty(_classnames, "is-".concat(size), size), breadcrumb_defineProperty(_classnames, "is-".concat(align), align), _classnames))
  }), external_react_default.a.createElement("ul", null, items.map(function (item) {
    var p = breadcrumb_defineProperty({
      renderAs: renderAs
    }, hrefAttr, item.url);

    return external_react_default.a.createElement("li", {
      key: item.url,
      className: classnames_default()({
        'is-active': item.active
      })
    }, external_react_default.a.createElement(components_element, p, item.name));
  })));
};

breadcrumb_Breadcrumb.propTypes = breadcrumb_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  separator: external_prop_types_default.a.oneOf(['arrow', 'bullet', 'dot', 'succeeds']),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),
  align: external_prop_types_default.a.oneOf(['right', 'center']),
  items: external_prop_types_default.a.arrayOf(external_prop_types_default.a.shape({
    url: external_prop_types_default.a.string.isRequired,
    active: external_prop_types_default.a.bool,
    name: external_prop_types_default.a.node
  })),
  renderAs: render_as,
  hrefAttr: external_prop_types_default.a.string
});
breadcrumb_Breadcrumb.defaultProps = breadcrumb_objectSpread({}, modifiers.defaultProps, {
  items: [],
  hrefAttr: 'href',
  separator: undefined,
  renderAs: 'a',
  className: undefined,
  style: undefined,
  size: undefined,
  align: undefined
});
/* harmony default export */ var breadcrumb = (breadcrumb_Breadcrumb);
// EXTERNAL MODULE: ./src/components/breadcrumb/breadcrumb.sass
var breadcrumb_breadcrumb = __webpack_require__(9);

// CONCATENATED MODULE: ./src/components/breadcrumb/index.js


/* harmony default export */ var components_breadcrumb = (breadcrumb);
// EXTERNAL MODULE: ./src/components/card/card.sass
var card = __webpack_require__(10);

// EXTERNAL MODULE: ./src/components/image/image.sass
var image_image = __webpack_require__(11);

// CONCATENATED MODULE: ./src/components/image/constants.js
/* harmony default export */ var image_constants = ({
  SIZES: [16, 24, 32, 48, 64, 96, 128, 'square', '1by1', '4by3', '3by2', '16by9', '2by1', '5by4', '5by3', '3by1', '4by5', '3by4', '2by3', '3by5', '9by16', '1by2', '1by3']
});
// CONCATENATED MODULE: ./src/components/image/image.js
function image_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function image_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { image_ownKeys(source, true).forEach(function (key) { image_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { image_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function image_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { image_typeof = function _typeof(obj) { return typeof obj; }; } else { image_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return image_typeof(obj); }

function image_extends() { image_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return image_extends.apply(this, arguments); }

function image_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = image_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function image_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function image_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function image_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function image_createClass(Constructor, protoProps, staticProps) { if (protoProps) image_defineProperties(Constructor.prototype, protoProps); if (staticProps) image_defineProperties(Constructor, staticProps); return Constructor; }

function image_possibleConstructorReturn(self, call) { if (call && (image_typeof(call) === "object" || typeof call === "function")) { return call; } return image_assertThisInitialized(self); }

function image_getPrototypeOf(o) { image_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return image_getPrototypeOf(o); }

function image_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function image_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) image_setPrototypeOf(subClass, superClass); }

function image_setPrototypeOf(o, p) { image_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return image_setPrototypeOf(o, p); }

function image_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var image_Image =
/*#__PURE__*/
function (_PureComponent) {
  image_inherits(Image, _PureComponent);

  function Image(props) {
    var _this;

    image_classCallCheck(this, Image);

    _this = image_possibleConstructorReturn(this, image_getPrototypeOf(Image).call(this, props));

    image_defineProperty(image_assertThisInitialized(_this), "onError", function () {
      _this.setState({
        src: _this.props.fallback
      });
    });

    _this.state = {};
    return _this;
  }

  image_createClass(Image, [{
    key: "render",
    value: function render() {
      var _classnames;

      var _this$props = this.props,
          className = _this$props.className,
          alt = _this$props.alt,
          size = _this$props.size,
          fallback = _this$props.fallback,
          rounded = _this$props.rounded,
          src = _this$props.src,
          fullwidth = _this$props.fullwidth,
          props = image_objectWithoutProperties(_this$props, ["className", "alt", "size", "fallback", "rounded", "src", "fullwidth"]);

      var s = size;

      if (typeof size === 'number') {
        s = "".concat(s, "x").concat(s);
      }

      return external_react_default.a.createElement(components_element, image_extends({}, props, {
        renderAs: "figure",
        className: classnames_default()('image', className, (_classnames = {}, image_defineProperty(_classnames, "is-".concat(s), s), image_defineProperty(_classnames, 'is-fullwidth', fullwidth), _classnames))
      }), external_react_default.a.createElement("img", {
        className: classnames_default()({
          'is-rounded': rounded
        }),
        onError: this.onError,
        src: this.state.src,
        alt: alt
      }));
    }
  }]);

  return Image;
}(external_react_["PureComponent"]);

image_defineProperty(image_Image, "getDerivedStateFromProps", function (props, state) {
  return {
    src: state.default !== props.src ? props.src : state.src,
    default: props.src
  };
});


image_Image.propTypes = image_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  src: external_prop_types_default.a.string,
  alt: external_prop_types_default.a.string,
  rounded: external_prop_types_default.a.bool,
  style: external_prop_types_default.a.shape({}),
  size: external_prop_types_default.a.oneOf(image_constants.SIZES),
  fallback: external_prop_types_default.a.string,
  fullwidth: external_prop_types_default.a.bool
});
image_Image.defaultProps = image_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  src: '',
  alt: '',
  rounded: false,
  style: undefined,
  size: undefined,
  fallback: 'https://bulma.io/images/placeholders/480x480.png',
  fullwidth: false
});
// CONCATENATED MODULE: ./src/components/image/index.js


// CONCATENATED MODULE: ./src/components/card/components/image.js
function components_image_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_image_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_image_ownKeys(source, true).forEach(function (key) { components_image_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_image_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_image_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function components_image_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_image_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_image_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var image_CardImage = function CardImage(_ref) {
  var className = _ref.className,
      domRef = _ref.domRef,
      props = components_image_objectWithoutProperties(_ref, ["className", "domRef"]);

  return external_react_default.a.createElement(components_element, {
    domRef: domRef,
    className: classnames_default()('card-image', className)
  }, external_react_default.a.createElement(image_Image, props));
};

image_CardImage.propTypes = components_image_objectSpread({}, modifiers.propTypes, {}, image_Image.propTypes);
image_CardImage.defaultProps = components_image_objectSpread({}, modifiers.defaultProps, {}, image_Image.defaultProps);
/* harmony default export */ var components_image = (image_CardImage);
// CONCATENATED MODULE: ./src/components/card/components/content.js
function content_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function content_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { content_ownKeys(source, true).forEach(function (key) { content_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { content_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function content_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function content_extends() { content_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return content_extends.apply(this, arguments); }

function content_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = content_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function content_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var content_CardContent = function CardContent(_ref) {
  var className = _ref.className,
      props = content_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, content_extends({}, props, {
    className: classnames_default()('card-content', className)
  }));
};

content_CardContent.propTypes = content_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
content_CardContent.defaultProps = content_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var content = (content_CardContent);
// CONCATENATED MODULE: ./src/components/card/components/header/components/header-title.js
function header_title_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function header_title_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { header_title_ownKeys(source, true).forEach(function (key) { header_title_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { header_title_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function header_title_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function header_title_extends() { header_title_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return header_title_extends.apply(this, arguments); }

function header_title_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = header_title_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function header_title_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var header_title_CardHeaderTitle = function CardHeaderTitle(_ref) {
  var className = _ref.className,
      props = header_title_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, header_title_extends({}, props, {
    className: classnames_default()('card-header-title', className)
  }));
};

header_title_CardHeaderTitle.propTypes = header_title_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
header_title_CardHeaderTitle.defaultProps = header_title_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var header_title = (header_title_CardHeaderTitle);
// CONCATENATED MODULE: ./src/components/card/components/header/components/header-icon.js
function header_icon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function header_icon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { header_icon_ownKeys(source, true).forEach(function (key) { header_icon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { header_icon_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function header_icon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function header_icon_extends() { header_icon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return header_icon_extends.apply(this, arguments); }

function header_icon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = header_icon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function header_icon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var header_icon_CardHeaderIcon = function CardHeaderIcon(_ref) {
  var className = _ref.className,
      props = header_icon_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, header_icon_extends({}, props, {
    className: classnames_default()('card-header-icon', className)
  }));
};

header_icon_CardHeaderIcon.propTypes = header_icon_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
header_icon_CardHeaderIcon.defaultProps = header_icon_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var header_icon = (header_icon_CardHeaderIcon);
// CONCATENATED MODULE: ./src/components/card/components/header/header.js
function header_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function header_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { header_ownKeys(source, true).forEach(function (key) { header_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { header_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function header_extends() { header_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return header_extends.apply(this, arguments); }

function header_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = header_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function header_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }










var header_CardHeader = function CardHeader(_ref) {
  var className = _ref.className,
      props = header_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, header_extends({}, props, {
    className: classnames_default()('card-header', className)
  }));
};

header_CardHeader.Title = header_title;
header_CardHeader.Icon = header_icon;
header_CardHeader.propTypes = header_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
header_CardHeader.defaultProps = header_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var header = (header_CardHeader);
// CONCATENATED MODULE: ./src/components/card/components/header/index.js

// CONCATENATED MODULE: ./src/components/card/components/footer/components/footer-item.js
function footer_item_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function footer_item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { footer_item_ownKeys(source, true).forEach(function (key) { footer_item_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { footer_item_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function footer_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function footer_item_extends() { footer_item_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return footer_item_extends.apply(this, arguments); }

function footer_item_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = footer_item_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function footer_item_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var footer_item_CardFooterItem = function CardFooterItem(_ref) {
  var className = _ref.className,
      props = footer_item_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, footer_item_extends({}, props, {
    className: classnames_default()('card-footer-item', className)
  }));
};

footer_item_CardFooterItem.propTypes = footer_item_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
footer_item_CardFooterItem.defaultProps = footer_item_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var footer_item = (footer_item_CardFooterItem);
// CONCATENATED MODULE: ./src/components/card/components/footer/footer.js
function footer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function footer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { footer_ownKeys(source, true).forEach(function (key) { footer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { footer_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function footer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function footer_extends() { footer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return footer_extends.apply(this, arguments); }

function footer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = footer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function footer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var footer_CardFooter = function CardFooter(_ref) {
  var className = _ref.className,
      props = footer_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, footer_extends({}, props, {
    className: classnames_default()('card-footer', className)
  }));
};

footer_CardFooter.Item = footer_item;
footer_CardFooter.propTypes = footer_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
footer_CardFooter.defaultProps = footer_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var footer = (footer_CardFooter);
// CONCATENATED MODULE: ./src/components/card/components/footer/index.js

// CONCATENATED MODULE: ./src/components/card/card.js
function card_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function card_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { card_ownKeys(source, true).forEach(function (key) { card_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { card_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function card_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function card_extends() { card_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return card_extends.apply(this, arguments); }

function card_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = card_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function card_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }












var card_Card = function Card(_ref) {
  var className = _ref.className,
      children = _ref.children,
      props = card_objectWithoutProperties(_ref, ["className", "children"]);

  return external_react_default.a.createElement(components_element, card_extends({
    className: classnames_default()('card', className)
  }, props), children);
};

card_Card.Image = components_image;
card_Card.Content = content;
card_Card.Header = header;
card_Card.Footer = footer;
card_Card.propTypes = card_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  children: external_prop_types_default.a.node,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
card_Card.defaultProps = card_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  children: null,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var card_card = (card_Card);
// CONCATENATED MODULE: ./src/components/card/index.js


// CONCATENATED MODULE: ./src/components/columns/constants.js
/* harmony default export */ var columns_constants = ({
  SIZES: {
    THREEQUARTERS: 'three-quarters',
    TWOTHIRDS: 'two-thirds',
    HALF: 'half',
    ONETHIRD: 'one-third',
    ONEQUARTER: 'one-quarter',
    ONEFIFTH: 'one-fifth',
    TWOFIFTHS: 'two-fifths',
    THREEFIFTHS: 'three-fifths',
    FOURFIFTHS: 'four-fifths'
  }
});
// CONCATENATED MODULE: ./src/components/columns/components/column.js
function column_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function column_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { column_ownKeys(source, true).forEach(function (key) { column_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { column_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function column_extends() { column_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return column_extends.apply(this, arguments); }

function column_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function column_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = column_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function column_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var sizes = [null, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].concat(Object.keys(columns_constants.SIZES).map(function (key) {
  return columns_constants.SIZES[key];
}));

var column_Column = function Column(_ref) {
  var _classNames;

  var children = _ref.children,
      className = _ref.className,
      size = _ref.size,
      offset = _ref.offset,
      narrow = _ref.narrow,
      mobile = _ref.mobile,
      tablet = _ref.tablet,
      desktop = _ref.desktop,
      widescreen = _ref.widescreen,
      fullhd = _ref.fullhd,
      touch = _ref.touch,
      props = column_objectWithoutProperties(_ref, ["children", "className", "size", "offset", "narrow", "mobile", "tablet", "desktop", "widescreen", "fullhd", "touch"]);

  return external_react_default.a.createElement(components_element, column_extends({}, props, {
    className: classnames_default()(className, 'column', (_classNames = {}, column_defineProperty(_classNames, "is-".concat(size), size), column_defineProperty(_classNames, "is-".concat(touch.size, "-mobile"), touch.size), column_defineProperty(_classNames, "is-".concat(mobile.size, "-mobile"), mobile.size), column_defineProperty(_classNames, "is-".concat(tablet.size, "-tablet"), tablet.size), column_defineProperty(_classNames, "is-".concat(desktop.size, "-desktop"), desktop.size), column_defineProperty(_classNames, "is-".concat(widescreen.size, "-widescreen"), widescreen.size), column_defineProperty(_classNames, "is-".concat(fullhd.size, "-fullhd"), fullhd.size), column_defineProperty(_classNames, "is-offset-".concat(touch.offset, "-mobile"), touch.offset), column_defineProperty(_classNames, "is-offset-".concat(mobile.offset, "-mobile"), mobile.offset), column_defineProperty(_classNames, "is-offset-".concat(tablet.offset, "-tablet"), tablet.offset), column_defineProperty(_classNames, "is-offset-".concat(desktop.offset, "-desktop"), desktop.offset), column_defineProperty(_classNames, "is-offset-".concat(widescreen.offset, "-widescreen"), widescreen.offset), column_defineProperty(_classNames, "is-offset-".concat(fullhd.offset, "-fullhd"), fullhd.offset), column_defineProperty(_classNames, "is-offset-".concat(offset), offset), column_defineProperty(_classNames, 'is-narrow', narrow), column_defineProperty(_classNames, 'is-narrow-touch', touch.narrow), column_defineProperty(_classNames, 'is-narrow-mobile', mobile.narrow), column_defineProperty(_classNames, 'is-narrow-tablet', tablet.narrow), column_defineProperty(_classNames, 'is-narrow-desktop', desktop.narrow), column_defineProperty(_classNames, 'is-narrow-widescreen', widescreen.narrow), column_defineProperty(_classNames, 'is-narrow-fullhd', fullhd.narrow), _classNames))
  }), children);
};

column_Column.propTypes = column_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),

  /**
   * The size of the column. the maximum size of a row is 12
   */
  size: external_prop_types_default.a.oneOf(sizes),

  /**
   * Create horizontal space around Column elements
   */
  offset: external_prop_types_default.a.oneOf(sizes),

  /**
   * If you want a column to only take the space it needs, use the narrow modifier. The other column(s) will fill up the remaining space.
   */
  narrow: external_prop_types_default.a.bool,

  /**
   * Size, Offset and Narrow props for Mobile devices (Up to 768px)
   */
  touch: external_prop_types_default.a.shape({
    size: external_prop_types_default.a.oneOf(sizes),
    offset: external_prop_types_default.a.oneOf(sizes),
    narrow: external_prop_types_default.a.bool
  }),

  /**
   * Size, Offset and Narrow props for Mobile devices (Up to 768px)
   */
  mobile: external_prop_types_default.a.shape({
    size: external_prop_types_default.a.oneOf(sizes),
    offset: external_prop_types_default.a.oneOf(sizes),
    narrow: external_prop_types_default.a.bool
  }),

  /**
   * Size, Offset and Narrow props for Tablet devices (Between 769px and 1023px)
   */
  tablet: external_prop_types_default.a.shape({
    size: external_prop_types_default.a.oneOf(sizes),
    offset: external_prop_types_default.a.oneOf(sizes),
    narrow: external_prop_types_default.a.bool
  }),

  /**
   * Size, Offset and Narrow props for Desktop devices (Between 1024px and 1215px)
   */
  desktop: external_prop_types_default.a.shape({
    size: external_prop_types_default.a.oneOf(sizes),
    offset: external_prop_types_default.a.oneOf(sizes),
    narrow: external_prop_types_default.a.bool
  }),

  /**
   * Size, Offset and Narrow props for WideScreen devices (Between 1216px and 1407px)
   */
  widescreen: external_prop_types_default.a.shape({
    size: external_prop_types_default.a.oneOf(sizes),
    offset: external_prop_types_default.a.oneOf(sizes),
    narrow: external_prop_types_default.a.bool
  }),

  /**
   * Size, Offset and Narrow props for FullHD devices (1408px and above)
   */
  fullhd: external_prop_types_default.a.shape({
    size: external_prop_types_default.a.oneOf(sizes),
    offset: external_prop_types_default.a.oneOf(sizes),
    narrow: external_prop_types_default.a.bool
  })
});
column_Column.defaultProps = column_objectSpread({}, modifiers.defaultProps, {
  children: undefined,
  className: undefined,
  style: undefined,
  size: undefined,
  offset: undefined,
  narrow: undefined,
  mobile: {
    size: undefined,
    offset: undefined,
    narrow: undefined
  },
  touch: {
    size: undefined,
    offset: undefined,
    narrow: undefined
  },
  tablet: {
    size: undefined,
    offset: undefined,
    narrow: undefined
  },
  desktop: {
    size: undefined,
    offset: undefined,
    narrow: undefined
  },
  widescreen: {
    size: undefined,
    offset: undefined,
    narrow: undefined
  },
  fullhd: {
    size: undefined,
    offset: undefined,
    narrow: undefined
  }
});
/* harmony default export */ var column = (column_Column);
// CONCATENATED MODULE: ./src/components/columns/columns.js
function columns_extends() { columns_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return columns_extends.apply(this, arguments); }

function columns_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function columns_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { columns_ownKeys(source, true).forEach(function (key) { columns_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { columns_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function columns_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function columns_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = columns_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function columns_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var breakpoints = [null].concat(Object.keys(constants.BREAKPOINTS).map(function (key) {
  return constants.BREAKPOINTS[key];
}));
var columns_sizes = [0, 1, 2, 3, 4, 5, 6, 7, 8];

var columns_Columns = function Columns(_ref) {
  var _objectSpread2, _ref2;

  var className = _ref.className,
      breakpoint = _ref.breakpoint,
      gapless = _ref.gapless,
      multiline = _ref.multiline,
      centered = _ref.centered,
      vCentered = _ref.vCentered,
      variableGap = _ref.variableGap,
      props = columns_objectWithoutProperties(_ref, ["className", "breakpoint", "gapless", "multiline", "centered", "vCentered", "variableGap"]);

  return external_react_default.a.createElement(components_element, columns_extends({}, props, {
    className: classnames_default()(className, 'columns', columns_objectSpread((_objectSpread2 = {}, columns_defineProperty(_objectSpread2, "is-".concat(breakpoint), breakpoint), columns_defineProperty(_objectSpread2, 'is-gapless', gapless), columns_defineProperty(_objectSpread2, 'is-multiline', multiline), columns_defineProperty(_objectSpread2, 'is-centered', centered), columns_defineProperty(_objectSpread2, 'is-vcentered', vCentered), columns_defineProperty(_objectSpread2, 'is-variable', Object.keys(variableGap).length > 0), _objectSpread2), variableGap ? (_ref2 = {}, columns_defineProperty(_ref2, "is-".concat(variableGap.touch, "-touch"), variableGap.touch), columns_defineProperty(_ref2, "is-".concat(variableGap.mobile, "-mobile"), variableGap.mobile), columns_defineProperty(_ref2, "is-".concat(variableGap.tablet, "-tablet"), variableGap.tablet), columns_defineProperty(_ref2, "is-".concat(variableGap.desktop, "-desktop"), variableGap.desktop), columns_defineProperty(_ref2, "is-".concat(variableGap.widescreen, "-widescreen"), variableGap.widescreen), columns_defineProperty(_ref2, "is-".concat(variableGap.fullhd, "-fullhd"), variableGap.fullhd), _ref2) : {}))
  }));
};

columns_Columns.Column = column;
columns_Columns.CONSTANTS = columns_constants;
columns_Columns.propTypes = columns_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  variableGap: external_prop_types_default.a.shape(columns_objectSpread({}, Object.values(constants.BREAKPOINTS).reduce(function (values, breakpoint) {
    return columns_objectSpread({}, values, columns_defineProperty({}, breakpoint, external_prop_types_default.a.oneOf(columns_sizes)));
  }, {}))),

  /**
   * Breakpoint where columns become stacked.
   */
  breakpoint: external_prop_types_default.a.oneOf(breakpoints),

  /**
   * `true` to remove space between columns
   */
  gapless: external_prop_types_default.a.bool,

  /**
   * `true` if you want to use more than one line if you add more column elements that would fit in a single row.
   */
  multiline: external_prop_types_default.a.bool,

  /**
   * `true` you want the columns inside to be horizontaly centered
   */
  centered: external_prop_types_default.a.bool,

  /**
   * `true` if you want to vertically align columns
   */
  vCentered: external_prop_types_default.a.bool
});
columns_Columns.defaultProps = columns_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  breakpoint: undefined,
  gapless: false,
  centered: false,
  vCentered: false,
  multiline: true,
  variableGap: {}
});
/* harmony default export */ var columns = (columns_Columns);
// EXTERNAL MODULE: ./src/components/columns/columns.sass
var columns_columns = __webpack_require__(12);

// CONCATENATED MODULE: ./src/components/columns/index.js


/* harmony default export */ var components_columns = (columns);
// EXTERNAL MODULE: ./src/components/container/container.sass
var container = __webpack_require__(13);

// CONCATENATED MODULE: ./src/components/container/container.js
function container_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function container_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { container_ownKeys(source, true).forEach(function (key) { container_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { container_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function container_extends() { container_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return container_extends.apply(this, arguments); }

function container_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function container_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = container_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function container_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var container_breakpoints = [null].concat(Object.keys(constants.BREAKPOINTS).map(function (key) {
  return constants.BREAKPOINTS[key];
}));

var container_Container = function Container(_ref) {
  var children = _ref.children,
      fluid = _ref.fluid,
      breakpoint = _ref.breakpoint,
      className = _ref.className,
      props = container_objectWithoutProperties(_ref, ["children", "fluid", "breakpoint", "className"]);

  return external_react_default.a.createElement(components_element, container_extends({}, props, {
    className: classnames_default()('container', className, container_defineProperty({
      'is-fluid': fluid
    }, "is-".concat(breakpoint), breakpoint))
  }), children);
};

container_Container.propTypes = container_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  fluid: external_prop_types_default.a.bool,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  breakpoint: external_prop_types_default.a.oneOf(container_breakpoints),
  renderAs: render_as
});
container_Container.defaultProps = container_objectSpread({}, modifiers.defaultProps, {
  fluid: false,
  children: null,
  breakpoint: undefined,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var container_container = (container_Container);
// CONCATENATED MODULE: ./src/components/container/index.js


// EXTERNAL MODULE: ./src/components/content/content.sass
var content_content = __webpack_require__(14);

// CONCATENATED MODULE: ./src/components/content/content.js
function content_content_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function content_content_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { content_content_ownKeys(source, true).forEach(function (key) { content_content_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { content_content_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function content_content_extends() { content_content_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return content_content_extends.apply(this, arguments); }

function content_content_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function content_content_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = content_content_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function content_content_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var content_Content = function Content(_ref) {
  var children = _ref.children,
      className = _ref.className,
      size = _ref.size,
      props = content_content_objectWithoutProperties(_ref, ["children", "className", "size"]);

  return external_react_default.a.createElement(components_element, content_content_extends({}, props, {
    className: classnames_default()('content', className, content_content_defineProperty({}, "is-".concat(size), size))
  }), children);
};

content_Content.propTypes = content_content_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),
  renderAs: render_as
});
content_Content.defaultProps = content_content_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  size: undefined,
  renderAs: 'div'
});
/* harmony default export */ var components_content_content = (content_Content);
// CONCATENATED MODULE: ./src/components/content/index.js


// EXTERNAL MODULE: ./src/components/footer/footer.sass
var footer_footer = __webpack_require__(15);

// CONCATENATED MODULE: ./src/components/footer/footer.js
function footer_footer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function footer_footer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { footer_footer_ownKeys(source, true).forEach(function (key) { footer_footer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { footer_footer_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function footer_footer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function footer_footer_extends() { footer_footer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return footer_footer_extends.apply(this, arguments); }

function footer_footer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = footer_footer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function footer_footer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var footer_Footer = function Footer(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = footer_footer_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, footer_footer_extends({}, props, {
    className: classnames_default()('footer', className)
  }), children);
};

footer_Footer.propTypes = footer_footer_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
footer_Footer.defaultProps = footer_footer_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var components_footer_footer = (footer_Footer);
// CONCATENATED MODULE: ./src/components/footer/index.js


// EXTERNAL MODULE: ./src/components/heading/heading.sass
var heading_heading = __webpack_require__(16);

// CONCATENATED MODULE: ./src/components/heading/heading.js
function heading_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function heading_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heading_ownKeys(source, true).forEach(function (key) { heading_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heading_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heading_extends() { heading_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return heading_extends.apply(this, arguments); }

function heading_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function heading_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = heading_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function heading_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var heading_Heading = function Heading(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      size = _ref.size,
      subtitle = _ref.subtitle,
      weight = _ref.weight,
      spaced = _ref.spaced,
      heading = _ref.heading,
      props = heading_objectWithoutProperties(_ref, ["children", "className", "size", "subtitle", "weight", "spaced", "heading"]);

  return external_react_default.a.createElement(components_element, heading_extends({}, props, {
    className: classnames_default()(className, (_classnames = {
      title: !subtitle && !heading,
      subtitle: subtitle,
      heading: heading
    }, heading_defineProperty(_classnames, "is-".concat(size), size), heading_defineProperty(_classnames, "has-text-weight-".concat(weight), weight), heading_defineProperty(_classnames, 'is-spaced', spaced && !subtitle), _classnames))
  }), children);
};

heading_Heading.propTypes = heading_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  renderAs: render_as,
  size: external_prop_types_default.a.oneOf([1, 2, 3, 4, 5, 6]),
  weight: external_prop_types_default.a.oneOf(['light', 'normal', 'semibold', 'bold']),
  subtitle: external_prop_types_default.a.bool,
  heading: external_prop_types_default.a.bool,
  spaced: external_prop_types_default.a.bool
});
heading_Heading.defaultProps = heading_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  renderAs: 'h1',
  size: undefined,
  weight: undefined,
  subtitle: false,
  heading: false,
  spaced: false
});
/* harmony default export */ var components_heading_heading = (heading_Heading);
// CONCATENATED MODULE: ./src/components/heading/index.js


// EXTERNAL MODULE: ./src/components/hero/hero.sass
var hero = __webpack_require__(17);

// CONCATENATED MODULE: ./src/components/hero/components/hero-head.js
function hero_head_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function hero_head_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { hero_head_ownKeys(source, true).forEach(function (key) { hero_head_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { hero_head_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function hero_head_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function hero_head_extends() { hero_head_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return hero_head_extends.apply(this, arguments); }

function hero_head_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = hero_head_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function hero_head_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var hero_head_HeroHead = function HeroHead(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = hero_head_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, hero_head_extends({}, props, {
    className: classnames_default()(className, 'hero-head')
  }), children);
};

hero_head_HeroHead.propTypes = hero_head_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
hero_head_HeroHead.defaultProps = hero_head_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var hero_head = (hero_head_HeroHead);
// CONCATENATED MODULE: ./src/components/hero/components/hero-body.js
function hero_body_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function hero_body_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { hero_body_ownKeys(source, true).forEach(function (key) { hero_body_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { hero_body_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function hero_body_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function hero_body_extends() { hero_body_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return hero_body_extends.apply(this, arguments); }

function hero_body_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = hero_body_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function hero_body_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var hero_body_HeroBody = function HeroBody(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = hero_body_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, hero_body_extends({}, props, {
    className: classnames_default()(className, 'hero-body')
  }), children);
};

hero_body_HeroBody.propTypes = hero_body_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
hero_body_HeroBody.defaultProps = hero_body_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var hero_body = (hero_body_HeroBody);
// CONCATENATED MODULE: ./src/components/hero/components/hero-footer.js
function hero_footer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function hero_footer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { hero_footer_ownKeys(source, true).forEach(function (key) { hero_footer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { hero_footer_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function hero_footer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function hero_footer_extends() { hero_footer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return hero_footer_extends.apply(this, arguments); }

function hero_footer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = hero_footer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function hero_footer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var hero_footer_HeroFooter = function HeroFooter(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = hero_footer_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, hero_footer_extends({}, props, {
    className: classnames_default()(className, 'hero-foot')
  }), children);
};

hero_footer_HeroFooter.propTypes = hero_footer_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
hero_footer_HeroFooter.defaultProps = hero_footer_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var hero_footer = (hero_footer_HeroFooter);
// CONCATENATED MODULE: ./src/components/hero/hero.js
function hero_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function hero_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { hero_ownKeys(source, true).forEach(function (key) { hero_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { hero_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function hero_extends() { hero_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return hero_extends.apply(this, arguments); }

function hero_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function hero_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = hero_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function hero_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }











var hero_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var hero_Hero = function Hero(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      color = _ref.color,
      gradient = _ref.gradient,
      size = _ref.size,
      hasNavbar = _ref.hasNavbar,
      props = hero_objectWithoutProperties(_ref, ["children", "className", "color", "gradient", "size", "hasNavbar"]);

  return external_react_default.a.createElement(components_element, hero_extends({}, props, {
    className: classnames_default()('hero', className, (_classnames = {}, hero_defineProperty(_classnames, "is-".concat(color), color), hero_defineProperty(_classnames, "is-".concat(size), size), hero_defineProperty(_classnames, 'is-bold', gradient), hero_defineProperty(_classnames, 'is-fullheight-with-navbar', hasNavbar), _classnames))
  }), children);
};

hero_Hero.Head = hero_head;
hero_Hero.Body = hero_body;
hero_Hero.Footer = hero_footer;
hero_Hero.propTypes = hero_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  color: external_prop_types_default.a.oneOf(hero_colors),
  gradient: external_prop_types_default.a.bool,
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large', 'fullheight']),
  hasNavbar: external_prop_types_default.a.bool
});
hero_Hero.defaultProps = hero_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'section',
  color: undefined,
  gradient: undefined,
  size: undefined,
  hasNavbar: undefined
});
/* harmony default export */ var hero_hero = (hero_Hero);
// CONCATENATED MODULE: ./src/components/hero/index.js


// EXTERNAL MODULE: ./src/components/level/level.sass
var level = __webpack_require__(18);

// CONCATENATED MODULE: ./src/components/level/components/level-side.js
function level_side_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function level_side_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { level_side_ownKeys(source, true).forEach(function (key) { level_side_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { level_side_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function level_side_extends() { level_side_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return level_side_extends.apply(this, arguments); }

function level_side_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function level_side_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = level_side_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function level_side_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var level_side_LevelSide = function LevelSide(_ref) {
  var children = _ref.children,
      className = _ref.className,
      align = _ref.align,
      props = level_side_objectWithoutProperties(_ref, ["children", "className", "align"]);

  return external_react_default.a.createElement(components_element, level_side_extends({}, props, {
    className: classnames_default()(className, level_side_defineProperty({}, "level-".concat(align), align))
  }), children);
};

level_side_LevelSide.propTypes = level_side_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  align: external_prop_types_default.a.string
});
level_side_LevelSide.defaultProps = level_side_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div',
  align: 'left'
});
/* harmony default export */ var level_side = (level_side_LevelSide);
// CONCATENATED MODULE: ./src/components/level/components/level-item.js
function level_item_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function level_item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { level_item_ownKeys(source, true).forEach(function (key) { level_item_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { level_item_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function level_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function level_item_extends() { level_item_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return level_item_extends.apply(this, arguments); }

function level_item_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = level_item_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function level_item_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var level_item_LevelItem = function LevelItem(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = level_item_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, level_item_extends({}, props, {
    className: classnames_default()('level-item', className, {})
  }), children);
};

level_item_LevelItem.propTypes = level_item_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
level_item_LevelItem.defaultProps = level_item_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var level_item = (level_item_LevelItem);
// CONCATENATED MODULE: ./src/components/level/level.js
function level_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function level_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { level_ownKeys(source, true).forEach(function (key) { level_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { level_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function level_extends() { level_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return level_extends.apply(this, arguments); }

function level_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function level_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = level_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function level_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }










var level_breakpoints = [null].concat(Object.keys(constants.BREAKPOINTS).map(function (key) {
  return constants.BREAKPOINTS[key];
}));

var level_Level = function Level(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      breakpoint = _ref.breakpoint,
      mobile = _ref.mobile,
      props = level_objectWithoutProperties(_ref, ["children", "className", "breakpoint", "mobile"]);

  return external_react_default.a.createElement(components_element, level_extends({}, props, {
    className: classnames_default()('level', className, (_classnames = {}, level_defineProperty(_classnames, "is-".concat(breakpoint), breakpoint), level_defineProperty(_classnames, 'is-mobile', mobile), _classnames))
  }), children);
};

level_Level.Side = level_side;
level_Level.Item = level_item;
level_Level.propTypes = level_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  mobile: external_prop_types_default.a.bool,
  style: external_prop_types_default.a.shape({}),
  breakpoint: external_prop_types_default.a.oneOf(level_breakpoints),
  renderAs: render_as
});
level_Level.defaultProps = level_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  mobile: false,
  style: undefined,
  breakpoint: undefined,
  renderAs: 'div'
});
/* harmony default export */ var level_level = (level_Level);
// CONCATENATED MODULE: ./src/components/level/index.js


// CONCATENATED MODULE: ./src/components/list/components/list-item.js
function list_item_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function list_item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { list_item_ownKeys(source, true).forEach(function (key) { list_item_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { list_item_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function list_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function list_item_extends() { list_item_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return list_item_extends.apply(this, arguments); }

function list_item_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = list_item_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function list_item_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var list_item_ListItem = function ListItem(_ref) {
  var children = _ref.children,
      className = _ref.className,
      active = _ref.active,
      props = list_item_objectWithoutProperties(_ref, ["children", "className", "active"]);

  return external_react_default.a.createElement(components_element, list_item_extends({}, props, {
    className: classnames_default()('list-item', className, {
      'is-active': active
    })
  }), children);
};

list_item_ListItem.propTypes = list_item_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
list_item_ListItem.defaultProps = list_item_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var list_item = (list_item_ListItem);
// CONCATENATED MODULE: ./src/components/list/list.js
function list_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function list_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { list_ownKeys(source, true).forEach(function (key) { list_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { list_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function list_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function list_extends() { list_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return list_extends.apply(this, arguments); }

function list_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = list_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function list_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var list_List = function List(_ref) {
  var children = _ref.children,
      className = _ref.className,
      hoverable = _ref.hoverable,
      props = list_objectWithoutProperties(_ref, ["children", "className", "hoverable"]);

  return external_react_default.a.createElement(components_element, list_extends({}, props, {
    className: classnames_default()('list', className, {
      'is-hoverable': hoverable
    })
  }), children);
};

list_List.propTypes = list_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
list_List.defaultProps = list_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
list_List.Item = list_item;
/* harmony default export */ var list = (list_List);
// EXTERNAL MODULE: ./src/components/list/list.sass
var list_list = __webpack_require__(19);

// CONCATENATED MODULE: ./src/components/list/index.js


/* harmony default export */ var components_list = (list);
// EXTERNAL MODULE: ./src/components/media/media.sass
var media = __webpack_require__(20);

// CONCATENATED MODULE: ./src/components/media/components/media-item.js
function media_item_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function media_item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { media_item_ownKeys(source, true).forEach(function (key) { media_item_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { media_item_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function media_item_extends() { media_item_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return media_item_extends.apply(this, arguments); }

function media_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function media_item_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = media_item_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function media_item_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var media_item_MediaItem = function MediaItem(_ref) {
  var children = _ref.children,
      className = _ref.className,
      position = _ref.position,
      props = media_item_objectWithoutProperties(_ref, ["children", "className", "position"]);

  var p = position === 'center' ? 'content' : position;
  return external_react_default.a.createElement(components_element, media_item_extends({}, props, {
    className: classnames_default()(className, media_item_defineProperty({}, "media-".concat(p), p))
  }), children);
};

media_item_MediaItem.propTypes = media_item_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  position: external_prop_types_default.a.oneOf(['center', 'right', 'left'])
});
media_item_MediaItem.defaultProps = media_item_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div',
  position: 'center'
});
/* harmony default export */ var media_item = (media_item_MediaItem);
// CONCATENATED MODULE: ./src/components/media/components/media-content.js
function media_content_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function media_content_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { media_content_ownKeys(source, true).forEach(function (key) { media_content_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { media_content_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function media_content_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function media_content_extends() { media_content_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return media_content_extends.apply(this, arguments); }

function media_content_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = media_content_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function media_content_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var media_content_MediaContent = function MediaContent(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = media_content_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, media_content_extends({}, props, {
    className: classnames_default()(className, 'content')
  }), children);
};

media_content_MediaContent.propTypes = media_content_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
media_content_MediaContent.defaultProps = media_content_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var media_content = (media_content_MediaContent);
// CONCATENATED MODULE: ./src/components/media/media.js
function media_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function media_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { media_ownKeys(source, true).forEach(function (key) { media_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { media_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function media_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function media_extends() { media_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return media_extends.apply(this, arguments); }

function media_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = media_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function media_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }










var media_Media = function Media(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = media_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, media_extends({}, props, {
    className: classnames_default()('media', className, {})
  }), children);
};

media_Media.Item = media_item;
media_Media.Content = media_content;
media_Media.propTypes = media_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
media_Media.defaultProps = media_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'article'
});
/* harmony default export */ var media_media = (media_Media);
// CONCATENATED MODULE: ./src/components/media/index.js


// EXTERNAL MODULE: ./src/components/notification/notification.sass
var notification_notification = __webpack_require__(21);

// CONCATENATED MODULE: ./src/components/notification/notification.js
function notification_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function notification_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { notification_ownKeys(source, true).forEach(function (key) { notification_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { notification_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function notification_extends() { notification_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return notification_extends.apply(this, arguments); }

function notification_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function notification_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = notification_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function notification_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var notification_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var notification_Notification = function Notification(_ref) {
  var children = _ref.children,
      className = _ref.className,
      color = _ref.color,
      props = notification_objectWithoutProperties(_ref, ["children", "className", "color"]);

  return external_react_default.a.createElement(components_element, notification_extends({}, props, {
    className: classnames_default()('notification', notification_defineProperty({}, "is-".concat(color), color), className)
  }), children);
};

notification_Notification.propTypes = notification_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  color: external_prop_types_default.a.oneOf(notification_colors)
});
notification_Notification.defaultProps = notification_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div',
  color: undefined
});
/* harmony default export */ var components_notification_notification = (notification_Notification);
// CONCATENATED MODULE: ./src/components/notification/index.js


// EXTERNAL MODULE: ./src/components/progress/progress.sass
var progress = __webpack_require__(22);

// CONCATENATED MODULE: ./src/components/progress/progress.js
function progress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function progress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { progress_ownKeys(source, true).forEach(function (key) { progress_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { progress_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function progress_extends() { progress_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return progress_extends.apply(this, arguments); }

function progress_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function progress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = progress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function progress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var progress_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var progress_Progress = function Progress(_ref) {
  var _classnames;

  var className = _ref.className,
      value = _ref.value,
      max = _ref.max,
      color = _ref.color,
      size = _ref.size,
      props = progress_objectWithoutProperties(_ref, ["className", "value", "max", "color", "size"]);

  return external_react_default.a.createElement(components_element, progress_extends({
    renderAs: "progress"
  }, props, {
    value: value,
    max: max,
    className: classnames_default()('progress', className, (_classnames = {}, progress_defineProperty(_classnames, "is-".concat(color), color), progress_defineProperty(_classnames, "is-".concat(size), size), _classnames))
  }));
};

progress_Progress.propTypes = progress_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  color: external_prop_types_default.a.oneOf(progress_colors),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),
  value: external_prop_types_default.a.number,
  max: external_prop_types_default.a.number
});
progress_Progress.defaultProps = progress_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  style: undefined,
  color: undefined,
  size: undefined,
  value: undefined,
  max: undefined
});
/* harmony default export */ var progress_progress = (progress_Progress);
// CONCATENATED MODULE: ./src/components/progress/index.js


// EXTERNAL MODULE: ./src/components/section/section.sass
var section = __webpack_require__(23);

// CONCATENATED MODULE: ./src/components/section/section.js
function section_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function section_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { section_ownKeys(source, true).forEach(function (key) { section_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { section_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function section_extends() { section_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return section_extends.apply(this, arguments); }

function section_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function section_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = section_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function section_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var section_Section = function Section(_ref) {
  var children = _ref.children,
      className = _ref.className,
      size = _ref.size,
      props = section_objectWithoutProperties(_ref, ["children", "className", "size"]);

  return external_react_default.a.createElement(components_element, section_extends({}, props, {
    className: classnames_default()('section', className, section_defineProperty({}, "is-".concat(size), size))
  }), children);
};

section_Section.propTypes = section_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  size: external_prop_types_default.a.oneOf(['medium', 'large'])
});
section_Section.defaultProps = section_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'section',
  size: undefined
});
/* harmony default export */ var section_section = (section_Section);
// CONCATENATED MODULE: ./src/components/section/index.js


// EXTERNAL MODULE: ./src/components/table/table.sass
var table = __webpack_require__(24);

// CONCATENATED MODULE: ./src/components/table/table.js
function table_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function table_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { table_ownKeys(source, true).forEach(function (key) { table_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { table_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function table_extends() { table_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return table_extends.apply(this, arguments); }

function table_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function table_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = table_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function table_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var table_Table = function Table(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      size = _ref.size,
      striped = _ref.striped,
      bordered = _ref.bordered,
      props = table_objectWithoutProperties(_ref, ["children", "className", "size", "striped", "bordered"]);

  return external_react_default.a.createElement(components_element, table_extends({
    renderAs: "table"
  }, props, {
    className: classnames_default()('table', className, (_classnames = {}, table_defineProperty(_classnames, "is-".concat(size), size), table_defineProperty(_classnames, 'is-bordered', bordered), table_defineProperty(_classnames, 'is-striped', striped), _classnames))
  }), children);
};

table_Table.propTypes = table_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  size: external_prop_types_default.a.oneOf(['fullwidth', 'narrow']),
  striped: external_prop_types_default.a.bool,
  bordered: external_prop_types_default.a.bool
});
table_Table.defaultProps = table_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  size: 'fullwidth',
  striped: true,
  bordered: false
});
/* harmony default export */ var table_table = (table_Table);
// CONCATENATED MODULE: ./src/components/table/index.js


// EXTERNAL MODULE: ./src/components/tag/tag.sass
var tag = __webpack_require__(25);

// CONCATENATED MODULE: ./src/components/tag/components/tag-group.js
function tag_group_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tag_group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tag_group_ownKeys(source, true).forEach(function (key) { tag_group_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tag_group_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function tag_group_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function tag_group_extends() { tag_group_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return tag_group_extends.apply(this, arguments); }

function tag_group_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = tag_group_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function tag_group_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var tag_group_TagGroup = function TagGroup(_ref) {
  var children = _ref.children,
      className = _ref.className,
      gapless = _ref.gapless,
      props = tag_group_objectWithoutProperties(_ref, ["children", "className", "gapless"]);

  return external_react_default.a.createElement(components_element, tag_group_extends({
    renderAs: "span"
  }, props, {
    className: classnames_default()('tags', className, {
      'has-addons': gapless
    })
  }), children);
};

tag_group_TagGroup.propTypes = tag_group_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  gapless: external_prop_types_default.a.bool
});
tag_group_TagGroup.defaultProps = tag_group_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  gapless: false
});
/* harmony default export */ var tag_group = (tag_group_TagGroup);
// CONCATENATED MODULE: ./src/components/tag/tag.js
function tag_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tag_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tag_ownKeys(source, true).forEach(function (key) { tag_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tag_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function tag_extends() { tag_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return tag_extends.apply(this, arguments); }

function tag_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function tag_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = tag_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function tag_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var tag_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var tag_Tag = function Tag(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      color = _ref.color,
      size = _ref.size,
      rounded = _ref.rounded,
      remove = _ref.remove,
      props = tag_objectWithoutProperties(_ref, ["children", "className", "color", "size", "rounded", "remove"]);

  return external_react_default.a.createElement(components_element, tag_extends({}, props, {
    className: classnames_default()('tag', className, (_classnames = {}, tag_defineProperty(_classnames, "is-".concat(size), size), tag_defineProperty(_classnames, "is-".concat(color), color), tag_defineProperty(_classnames, 'is-rounded', rounded), tag_defineProperty(_classnames, 'is-delete', remove), _classnames))
  }), !remove && children);
};

tag_Tag.Group = tag_group;
tag_Tag.propTypes = tag_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  color: external_prop_types_default.a.oneOf(tag_colors),
  size: external_prop_types_default.a.oneOf(['medium', 'large']),
  rounded: external_prop_types_default.a.bool,
  remove: external_prop_types_default.a.bool,
  renderAs: render_as
});
tag_Tag.defaultProps = tag_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  color: undefined,
  size: undefined,
  rounded: false,
  remove: false,
  renderAs: 'span'
});
/* harmony default export */ var tag_tag = (tag_Tag);
// CONCATENATED MODULE: ./src/components/tag/index.js


// EXTERNAL MODULE: ./src/components/tile/tile.sass
var tile = __webpack_require__(26);

// CONCATENATED MODULE: ./src/components/tile/tile.js
function tile_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tile_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tile_ownKeys(source, true).forEach(function (key) { tile_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tile_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function tile_extends() { tile_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return tile_extends.apply(this, arguments); }

function tile_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function tile_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = tile_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function tile_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var tile_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var tile_Tile = function Tile(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      kind = _ref.kind,
      vertical = _ref.vertical,
      size = _ref.size,
      color = _ref.color,
      notification = _ref.notification,
      props = tile_objectWithoutProperties(_ref, ["children", "className", "kind", "vertical", "size", "color", "notification"]);

  return external_react_default.a.createElement(components_element, tile_extends({}, props, {
    className: classnames_default()('tile', className, (_classnames = {
      notification: notification
    }, tile_defineProperty(_classnames, "is-".concat(kind), kind), tile_defineProperty(_classnames, "is-".concat(size), size), tile_defineProperty(_classnames, "is-".concat(color), color), tile_defineProperty(_classnames, 'is-vertical', vertical), _classnames))
  }), children);
};

tile_Tile.propTypes = tile_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  kind: external_prop_types_default.a.oneOf(['ancestor', 'parent', 'child']),
  vertical: external_prop_types_default.a.bool,
  size: external_prop_types_default.a.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
  color: external_prop_types_default.a.oneOf(tile_colors),
  notification: external_prop_types_default.a.bool
});
tile_Tile.defaultProps = tile_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div',
  kind: undefined,
  vertical: false,
  size: undefined,
  color: undefined,
  notification: false
});
/* harmony default export */ var tile_tile = (tile_Tile);
// CONCATENATED MODULE: ./src/components/tile/index.js


// EXTERNAL MODULE: ./src/components/modal/modal.sass
var modal = __webpack_require__(27);

// EXTERNAL MODULE: external "react-dom"
var external_react_dom_ = __webpack_require__(4);
var external_react_dom_default = /*#__PURE__*/__webpack_require__.n(external_react_dom_);

// CONCATENATED MODULE: ./src/components/modal/components/content.js
function components_content_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_content_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_content_ownKeys(source, true).forEach(function (key) { components_content_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_content_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_content_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function components_content_extends() { components_content_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return components_content_extends.apply(this, arguments); }

function components_content_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_content_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_content_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var content_ModalContent = function ModalContent(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = components_content_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, components_content_extends({}, props, {
    className: classnames_default()('modal-content', className)
  }), children);
};

content_ModalContent.propTypes = components_content_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
content_ModalContent.defaultProps = components_content_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var components_content = (content_ModalContent);
// CONCATENATED MODULE: ./src/components/modal/components/card/head.js
function head_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function head_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { head_ownKeys(source, true).forEach(function (key) { head_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { head_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function head_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function head_extends() { head_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return head_extends.apply(this, arguments); }

function head_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = head_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function head_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var head_ModalCardHead = function ModalCardHead(_ref) {
  var children = _ref.children,
      className = _ref.className,
      showClose = _ref.showClose,
      onClose = _ref.onClose,
      props = head_objectWithoutProperties(_ref, ["children", "className", "showClose", "onClose"]);

  return external_react_default.a.createElement(components_element, head_extends({}, props, {
    className: classnames_default()('modal-card-head', className)
  }), children, showClose && external_react_default.a.createElement(components_button_button, {
    remove: true,
    onClick: onClose
  }));
};

head_ModalCardHead.propTypes = head_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  showClose: external_prop_types_default.a.bool,
  onClose: external_prop_types_default.a.func
});
head_ModalCardHead.defaultProps = head_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  showClose: true,
  onClose: undefined,
  renderAs: 'header'
});
/* harmony default export */ var head = (head_ModalCardHead);
// CONCATENATED MODULE: ./src/components/modal/components/card/body.js
function body_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function body_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { body_ownKeys(source, true).forEach(function (key) { body_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { body_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function body_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function body_extends() { body_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return body_extends.apply(this, arguments); }

function body_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = body_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function body_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var body_ModalCardBody = function ModalCardBody(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = body_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, body_extends({}, props, {
    className: classnames_default()('modal-card-body', className)
  }), children);
};

body_ModalCardBody.propTypes = body_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
body_ModalCardBody.defaultProps = body_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'section'
});
/* harmony default export */ var body = (body_ModalCardBody);
// CONCATENATED MODULE: ./src/components/modal/components/card/foot.js
function foot_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function foot_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { foot_ownKeys(source, true).forEach(function (key) { foot_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { foot_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function foot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function foot_extends() { foot_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return foot_extends.apply(this, arguments); }

function foot_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = foot_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function foot_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var foot_ModalCardFoot = function ModalCardFoot(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = foot_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, foot_extends({}, props, {
    className: classnames_default()('modal-card-foot', className)
  }), children);
};

foot_ModalCardFoot.propTypes = foot_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({})
});
foot_ModalCardFoot.defaultProps = foot_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'footer'
});
/* harmony default export */ var foot = (foot_ModalCardFoot);
// CONCATENATED MODULE: ./src/components/modal/components/card/title.js
function title_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function title_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { title_ownKeys(source, true).forEach(function (key) { title_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { title_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function title_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function title_extends() { title_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return title_extends.apply(this, arguments); }

function title_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = title_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function title_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var title_ModalCardTitle = function ModalCardTitle(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = title_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, title_extends({}, props, {
    className: classnames_default()('modal-card-title', className)
  }), children);
};

title_ModalCardTitle.propTypes = title_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({})
});
title_ModalCardTitle.defaultProps = title_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'p'
});
/* harmony default export */ var card_title = (title_ModalCardTitle);
// CONCATENATED MODULE: ./src/components/modal/components/card/card.js
function card_card_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function card_card_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { card_card_ownKeys(source, true).forEach(function (key) { card_card_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { card_card_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function card_card_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function card_card_extends() { card_card_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return card_card_extends.apply(this, arguments); }

function card_card_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = card_card_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function card_card_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }











var card_ModalCard = function ModalCard(_ref) {
  var className = _ref.className,
      onClose = _ref.onClose,
      children = _ref.children,
      props = card_card_objectWithoutProperties(_ref, ["className", "onClose", "children"]);

  return external_react_default.a.createElement(components_element, card_card_extends({}, props, {
    className: classnames_default()('modal-card', className)
  }), children);
};

card_ModalCard.Head = head;
card_ModalCard.Body = body;
card_ModalCard.Foot = foot;
card_ModalCard.Title = card_title;
card_ModalCard.propTypes = card_card_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  onClose: external_prop_types_default.a.func
});
card_ModalCard.defaultProps = card_card_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  onClose: undefined
});
/* harmony default export */ var components_card_card = (card_ModalCard);
// CONCATENATED MODULE: ./src/components/modal/components/card/index.js

/* harmony default export */ var components_card = (components_card_card);
// CONCATENATED MODULE: ./src/components/modal/modal.js
function modal_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { modal_typeof = function _typeof(obj) { return typeof obj; }; } else { modal_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return modal_typeof(obj); }

function modal_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function modal_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function modal_createClass(Constructor, protoProps, staticProps) { if (protoProps) modal_defineProperties(Constructor.prototype, protoProps); if (staticProps) modal_defineProperties(Constructor, staticProps); return Constructor; }

function modal_possibleConstructorReturn(self, call) { if (call && (modal_typeof(call) === "object" || typeof call === "function")) { return call; } return modal_assertThisInitialized(self); }

function modal_getPrototypeOf(o) { modal_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return modal_getPrototypeOf(o); }

function modal_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function modal_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) modal_setPrototypeOf(subClass, superClass); }

function modal_setPrototypeOf(o, p) { modal_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return modal_setPrototypeOf(o, p); }

function modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var KEYCODES = {
  ESCAPE: 27
};

var modal_Modal =
/*#__PURE__*/
function (_PureComponent) {
  modal_inherits(Modal, _PureComponent);

  function Modal(props) {
    var _this;

    modal_classCallCheck(this, Modal);

    _this = modal_possibleConstructorReturn(this, modal_getPrototypeOf(Modal).call(this, props));

    modal_defineProperty(modal_assertThisInitialized(_this), "portalElement", null);

    modal_defineProperty(modal_assertThisInitialized(_this), "getDocument", function () {
      if (_this.props.document) {
        return _this.props.document;
      }

      if (typeof document !== 'undefined') {
        return document;
      }

      return null;
    });

    modal_defineProperty(modal_assertThisInitialized(_this), "handleKeydown", function (e) {
      if (e.keyCode === KEYCODES.ESCAPE && _this.props.show) {
        _this.props.onClose();
      }
    });

    _this.state = {};
    return _this;
  }

  modal_createClass(Modal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var closeOnEsc = this.props.closeOnEsc;
      var doc = this.getDocument();
      this.portalElement = doc.createElement('div');
      this.portalElement.setAttribute('class', 'modal-container');
      doc.body.appendChild(this.portalElement); // eslint-disable-next-line

      if (closeOnEsc) {
        doc.addEventListener('keydown', this.handleKeydown);
      }

      this.forceUpdate();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var doc = this.getDocument();
      var closeOnEsc = this.props.closeOnEsc;

      if (closeOnEsc && doc) {
        doc.removeEventListener('keydown', this.handleKeydown);
      } // IE11 fix


      this.portalElement.parentNode.removeChild(this.portalElement);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          domRef = _this$props.domRef,
          closeOnBlur = _this$props.closeOnBlur,
          show = _this$props.show,
          className = _this$props.className;

      if (!this.getDocument() || !this.portalElement || !show) {
        return null;
      }

      var children = this.props.children;
      var isCard;

      try {
        isCard = external_react_default.a.Children.only(children).type.toString().indexOf('ModalCard') !== -1;
      } catch (e) {
        isCard = false;
      }

      var showClose = !isCard && this.props.showClose;

      if (isCard) {
        children = external_react_default.a.cloneElement(children, {
          onClose: this.props.onClose
        });
      }

      return external_react_dom_default.a.createPortal(external_react_default.a.createElement("div", {
        ref: domRef,
        className: classnames_default()('modal', className, {
          'is-active': show
        })
      }, external_react_default.a.createElement("div", {
        role: "presentation",
        className: "modal-background",
        onClick: closeOnBlur ? this.props.onClose : undefined
      }), children, showClose && external_react_default.a.createElement("button", {
        type: "button",
        onClick: this.props.onClose,
        className: "modal-close is-large",
        "aria-label": "close"
      })), this.portalElement);
    }
  }]);

  return Modal;
}(external_react_["PureComponent"]);

modal_Modal.Content = components_content;
modal_Modal.Card = components_card;
modal_Modal.propTypes = {
  show: external_prop_types_default.a.bool.isRequired,
  onClose: external_prop_types_default.a.func.isRequired,
  closeOnEsc: external_prop_types_default.a.bool,
  closeOnBlur: external_prop_types_default.a.bool,
  showClose: external_prop_types_default.a.bool,
  children: external_prop_types_default.a.node.isRequired,
  document: external_prop_types_default.a.object,
  className: external_prop_types_default.a.string,
  domRef: external_prop_types_default.a.object
};
modal_Modal.defaultProps = {
  closeOnEsc: true,
  showClose: true,
  closeOnBlur: false,
  className: undefined,
  domRef: external_react_default.a.createRef(),
  // Expose mount point for testing
  document: undefined
};
/* harmony default export */ var modal_modal = (modal_Modal);
// CONCATENATED MODULE: ./src/components/modal/index.js


// EXTERNAL MODULE: ./src/components/dropdown/dropdown.sass
var dropdown_dropdown = __webpack_require__(28);

// CONCATENATED MODULE: ./src/components/dropdown/components/item.js
function item_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { item_ownKeys(source, true).forEach(function (key) { item_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { item_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function item_extends() { item_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return item_extends.apply(this, arguments); }

function item_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = item_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function item_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var item_DropdownItem = function DropdownItem(_ref) {
  var active = _ref.active,
      children = _ref.children,
      value = _ref.value,
      className = _ref.className,
      props = item_objectWithoutProperties(_ref, ["active", "children", "value", "className"]);

  return external_react_default.a.createElement(components_element, item_extends({
    title: value
  }, props, {
    role: "presentation",
    className: classnames_default()(className, 'dropdown-item', {
      'is-active': active
    })
  }), children);
};

item_DropdownItem.propTypes = item_objectSpread({}, modifiers.propTypes, {
  active: external_prop_types_default.a.bool,
  children: external_prop_types_default.a.node,
  value: external_prop_types_default.a.any.isRequired,
  onClick: external_prop_types_default.a.func
});
item_DropdownItem.defaultProps = item_objectSpread({}, modifiers.defaultProps, {
  active: false,
  onClick: undefined,
  children: null
});
/* harmony default export */ var components_item = (item_DropdownItem);
// CONCATENATED MODULE: ./src/components/dropdown/components/divider.js
function divider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function divider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { divider_ownKeys(source, true).forEach(function (key) { divider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { divider_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function divider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function divider_extends() { divider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return divider_extends.apply(this, arguments); }

function divider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = divider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function divider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var divider_DropdownDivider = function DropdownDivider(_ref) {
  var className = _ref.className,
      props = divider_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, divider_extends({
    renderAs: "hr"
  }, props, {
    className: classnames_default()('dropdown-divider', className)
  }));
};

divider_DropdownDivider.propTypes = divider_objectSpread({}, modifiers.propTypes, {
  style: external_prop_types_default.a.shape({}),
  className: external_prop_types_default.a.string
});
divider_DropdownDivider.defaultProps = divider_objectSpread({}, modifiers.defaultProps, {
  style: undefined,
  className: undefined
});
/* harmony default export */ var divider = (divider_DropdownDivider);
// EXTERNAL MODULE: ./src/components/icon/icon.sass
var icon_icon = __webpack_require__(29);

// CONCATENATED MODULE: ./src/components/icon/icon.js
function icon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function icon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { icon_ownKeys(source, true).forEach(function (key) { icon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { icon_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function icon_extends() { icon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return icon_extends.apply(this, arguments); }

function icon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function icon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = icon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function icon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var icon_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var icon_Icon = function Icon(_ref) {
  var _classnames;

  var icon = _ref.icon,
      size = _ref.size,
      color = _ref.color,
      className = _ref.className,
      align = _ref.align,
      children = _ref.children,
      props = icon_objectWithoutProperties(_ref, ["icon", "size", "color", "className", "align", "children"]);

  return external_react_default.a.createElement(components_element, icon_extends({
    renderAs: "span"
  }, props, {
    className: classnames_default()('icon', className, (_classnames = {}, icon_defineProperty(_classnames, "is-".concat(size), size), icon_defineProperty(_classnames, "is-".concat(align), align), icon_defineProperty(_classnames, "has-text-".concat(color), color), _classnames))
  }), children || external_react_default.a.createElement("i", {
    className: classnames_default()('rbc', icon_defineProperty({}, "rbc-".concat(icon), icon))
  }));
};

icon_Icon.propTypes = icon_objectSpread({}, modifiers.propTypes, {
  icon: external_prop_types_default.a.string,
  children: external_prop_types_default.a.element,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large', 'auto']),
  align: external_prop_types_default.a.oneOf(['left', 'right']),
  color: external_prop_types_default.a.oneOf(icon_colors)
});
icon_Icon.defaultProps = icon_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  style: undefined,
  size: undefined,
  color: undefined,
  children: null,
  align: undefined,
  icon: undefined
});
/* harmony default export */ var components_icon_icon = (icon_Icon);
// CONCATENATED MODULE: ./src/components/icon/index.js


// CONCATENATED MODULE: ./src/components/dropdown/dropdown.js
function dropdown_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function dropdown_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dropdown_ownKeys(source, true).forEach(function (key) { dropdown_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dropdown_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dropdown_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { dropdown_typeof = function _typeof(obj) { return typeof obj; }; } else { dropdown_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return dropdown_typeof(obj); }

function dropdown_extends() { dropdown_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return dropdown_extends.apply(this, arguments); }

function dropdown_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = dropdown_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function dropdown_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function dropdown_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function dropdown_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function dropdown_createClass(Constructor, protoProps, staticProps) { if (protoProps) dropdown_defineProperties(Constructor.prototype, protoProps); if (staticProps) dropdown_defineProperties(Constructor, staticProps); return Constructor; }

function dropdown_possibleConstructorReturn(self, call) { if (call && (dropdown_typeof(call) === "object" || typeof call === "function")) { return call; } return dropdown_assertThisInitialized(self); }

function dropdown_getPrototypeOf(o) { dropdown_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return dropdown_getPrototypeOf(o); }

function dropdown_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function dropdown_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) dropdown_setPrototypeOf(subClass, superClass); }

function dropdown_setPrototypeOf(o, p) { dropdown_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return dropdown_setPrototypeOf(o, p); }

function dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











var dropdown_colors = [null].concat(Object.values(constants.COLORS));

var dropdown_Dropdown =
/*#__PURE__*/
function (_PureComponent) {
  dropdown_inherits(Dropdown, _PureComponent);

  function Dropdown(props) {
    var _this;

    dropdown_classCallCheck(this, Dropdown);

    _this = dropdown_possibleConstructorReturn(this, dropdown_getPrototypeOf(Dropdown).call(this, props));

    dropdown_defineProperty(dropdown_assertThisInitialized(_this), "close", function (evt) {
      // IDK yet how to test using the ref in enzime
      // istanbul ignore if
      if (_this.props.hoverable || evt && _this.domRef && _this.domRef.current && _this.domRef.current.contains(evt.target)) {
        return;
      }

      if (_this.domRef.current) {
        _this.setState({
          open: false
        });
      }
    });

    dropdown_defineProperty(dropdown_assertThisInitialized(_this), "toggle", function (evt) {
      if (_this.props.hoverable) {
        return;
      }

      if (evt) {
        evt.preventDefault();
      }

      _this.setState(function (_ref) {
        var open = _ref.open;
        return {
          open: !open
        };
      });
    });

    dropdown_defineProperty(dropdown_assertThisInitialized(_this), "select", function (value) {
      return function () {
        if (_this.props.onChange) {
          _this.props.onChange(value);
        }

        if (_this.props.closeOnSelect) {
          _this.close();
        }
      };
    });

    _this.domRef = props.domRef || external_react_default.a.createRef();
    _this.state = {
      open: false
    };
    return _this;
  }

  dropdown_createClass(Dropdown, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      document.addEventListener('click', this.close);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.removeEventListener('click', this.close);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          className = _this$props.className,
          children = _this$props.children,
          value = _this$props.value,
          color = _this$props.color,
          align = _this$props.align,
          right = _this$props.right,
          up = _this$props.up,
          hoverable = _this$props.hoverable,
          label = _this$props.label,
          onChange = _this$props.onChange,
          closeOnSelect = _this$props.closeOnSelect,
          props = dropdown_objectWithoutProperties(_this$props, ["className", "children", "value", "color", "align", "right", "up", "hoverable", "label", "onChange", "closeOnSelect"]);

      var current = label;
      var childrenArray = external_react_default.a.Children.map(children, function (child, i) {
        if (child.type === components_item && (i === 0 && !label || child.props.value === value)) {
          current = child.props.children;
        }

        return external_react_default.a.cloneElement(child, child.type === components_item ? {
          active: child.props.value === value,
          onClick: _this2.select(child.props.value)
        } : {});
      });

      if (align === 'right') {
        // eslint-disable-next-line no-console
        console.warn('react-bulma-components: "Align" prop will be replaced by "right" prop in future releases. Please update your code to avoid breaking changes.');
      }

      return external_react_default.a.createElement(components_element, dropdown_extends({}, props, {
        domRef: this.domRef,
        className: classnames_default()('dropdown', className, {
          'is-active': this.state.open,
          'is-up': up,
          'is-right': right || align === 'right',
          'is-hoverable': hoverable
        })
      }), external_react_default.a.createElement("div", {
        className: "dropdown-trigger",
        role: "presentation",
        onClick: this.toggle
      }, external_react_default.a.createElement(components_button_button, {
        color: color
      }, external_react_default.a.createElement("span", null, current), external_react_default.a.createElement(components_icon_icon, {
        icon: "angle-down",
        size: "small"
      }))), external_react_default.a.createElement("div", {
        className: "dropdown-menu",
        id: "dropdown-menu",
        role: "menu"
      }, external_react_default.a.createElement("div", {
        className: "dropdown-content"
      }, childrenArray)));
    }
  }]);

  return Dropdown;
}(external_react_["PureComponent"]);


dropdown_Dropdown.Item = components_item;
dropdown_Dropdown.Divider = divider;
dropdown_Dropdown.propTypes = dropdown_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  children: external_prop_types_default.a.node,
  value: external_prop_types_default.a.any,
  onChange: external_prop_types_default.a.func,
  color: external_prop_types_default.a.oneOf(dropdown_colors),
  right: external_prop_types_default.a.bool,
  up: external_prop_types_default.a.bool,
  align: external_prop_types_default.a.oneOf(['right']),
  hoverable: external_prop_types_default.a.bool,
  label: external_prop_types_default.a.node,
  closeOnSelect: external_prop_types_default.a.bool
});
dropdown_Dropdown.defaultProps = dropdown_objectSpread({}, modifiers.defaultProps, {
  closeOnSelect: true,
  className: undefined,
  renderAs: 'div',
  domRef: undefined,
  style: undefined,
  value: undefined,
  children: [],
  onChange: undefined,
  color: undefined,
  align: undefined,
  hoverable: undefined,
  label: undefined
});
// CONCATENATED MODULE: ./src/components/dropdown/index.js


// EXTERNAL MODULE: ./src/components/loader/loader.sass
var loader = __webpack_require__(30);

// CONCATENATED MODULE: ./src/components/loader/loader.js
function loader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function loader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { loader_ownKeys(source, true).forEach(function (key) { loader_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { loader_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function loader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function loader_extends() { loader_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return loader_extends.apply(this, arguments); }

function loader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = loader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function loader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var loader_Loader = function Loader(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = loader_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, loader_extends({}, props, {
    className: classnames_default()('loader', className)
  }), children);
};

loader_Loader.propTypes = loader_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as
});
loader_Loader.defaultProps = loader_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div'
});
/* harmony default export */ var loader_loader = (loader_Loader);
// CONCATENATED MODULE: ./src/components/loader/index.js


// CONCATENATED MODULE: ./src/services/can-use-dom.js
/* harmony default export */ var can_use_dom = (!!(typeof window !== 'undefined' && window.document && window.document.createElement));
// CONCATENATED MODULE: ./src/components/navbar/components/brand.js
function brand_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function brand_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { brand_ownKeys(source, true).forEach(function (key) { brand_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { brand_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function brand_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function brand_extends() { brand_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return brand_extends.apply(this, arguments); }

function brand_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = brand_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function brand_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var brand_NavbarBrand = function NavbarBrand(_ref) {
  var className = _ref.className,
      children = _ref.children,
      props = brand_objectWithoutProperties(_ref, ["className", "children"]);

  return external_react_default.a.createElement(components_element, brand_extends({}, props, {
    className: classnames_default()('navbar-brand', className)
  }), children);
};

brand_NavbarBrand.propTypes = brand_objectSpread({}, modifiers.propTypes, {
  style: external_prop_types_default.a.shape({}),
  className: external_prop_types_default.a.string,
  children: external_prop_types_default.a.node
});
brand_NavbarBrand.defaultProps = brand_objectSpread({}, modifiers.defaultProps, {
  style: undefined,
  className: undefined,
  children: null
});
/* harmony default export */ var brand = (brand_NavbarBrand);
// CONCATENATED MODULE: ./src/components/navbar/context.js

var ShowContext = external_react_default.a.createContext(false);
// CONCATENATED MODULE: ./src/components/navbar/components/burger.js
function burger_extends() { burger_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return burger_extends.apply(this, arguments); }

function burger_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function burger_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { burger_ownKeys(source, true).forEach(function (key) { burger_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { burger_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function burger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function burger_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = burger_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function burger_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var burger_NavbarBurger = function NavbarBurger(_ref) {
  var style = _ref.style,
      className = _ref.className,
      props = burger_objectWithoutProperties(_ref, ["style", "className"]);

  return external_react_default.a.createElement(ShowContext.Consumer, null, function (active) {
    return external_react_default.a.createElement(components_element, burger_extends({
      role: "button",
      tabIndex: "0",
      style: burger_objectSpread({
        outline: 'none'
      }, style),
      className: classnames_default()('navbar-burger', className, {
        'is-active': active
      })
    }, props), external_react_default.a.createElement("span", null), external_react_default.a.createElement("span", null), external_react_default.a.createElement("span", null));
  });
};

burger_NavbarBurger.propTypes = burger_objectSpread({}, modifiers.propTypes, {
  style: external_prop_types_default.a.shape({}),
  className: external_prop_types_default.a.string,
  onClick: external_prop_types_default.a.func
});
burger_NavbarBurger.defaultProps = burger_objectSpread({}, modifiers.defaultProps, {
  style: undefined,
  className: undefined,
  onClick: function onClick() {}
});
/* harmony default export */ var burger = (burger_NavbarBurger);
// CONCATENATED MODULE: ./src/components/navbar/components/menu.js
function menu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function menu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { menu_ownKeys(source, true).forEach(function (key) { menu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { menu_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function menu_extends() { menu_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return menu_extends.apply(this, arguments); }

function menu_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = menu_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function menu_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var menu_NavbarMenu = function NavbarMenu(_ref) {
  var className = _ref.className,
      children = _ref.children,
      props = menu_objectWithoutProperties(_ref, ["className", "children"]);

  return external_react_default.a.createElement(ShowContext.Consumer, null, function (active) {
    return external_react_default.a.createElement(components_element, menu_extends({}, props, {
      className: classnames_default()('navbar-menu', className, {
        'is-active': active
      })
    }), children);
  });
};

menu_NavbarMenu.propTypes = menu_objectSpread({}, modifiers.propTypes, {
  style: external_prop_types_default.a.shape({}),
  className: external_prop_types_default.a.string,
  children: external_prop_types_default.a.node
});
menu_NavbarMenu.defaultProps = menu_objectSpread({}, modifiers.defaultProps, {
  style: undefined,
  className: undefined,
  children: null
});
/* harmony default export */ var menu = (menu_NavbarMenu);
// CONCATENATED MODULE: ./src/components/navbar/components/item.js
function components_item_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_item_ownKeys(source, true).forEach(function (key) { components_item_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_item_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function components_item_extends() { components_item_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return components_item_extends.apply(this, arguments); }

function components_item_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_item_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_item_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var item_NavbarItem = function NavbarItem(_ref) {
  var className = _ref.className,
      active = _ref.active,
      children = _ref.children,
      dropdown = _ref.dropdown,
      dropdownUp = _ref.dropdownUp,
      hoverable = _ref.hoverable,
      renderAs = _ref.renderAs,
      arrowless = _ref.arrowless,
      props = components_item_objectWithoutProperties(_ref, ["className", "active", "children", "dropdown", "dropdownUp", "hoverable", "renderAs", "arrowless"]);

  var as = renderAs;

  if (dropdown && renderAs === 'a') {
    as = 'span';
  }

  return external_react_default.a.createElement(components_element, components_item_extends({}, props, {
    renderAs: as,
    className: classnames_default()('navbar-item', className, {
      'is-active': active,
      'has-dropdown': dropdown,
      'is-hoverable': hoverable,
      'has-dropdown-up': dropdownUp,
      'is-arrowless': arrowless
    })
  }), children);
};

item_NavbarItem.propTypes = components_item_objectSpread({}, modifiers.propTypes, {
  style: external_prop_types_default.a.shape({}),
  className: external_prop_types_default.a.string,
  active: external_prop_types_default.a.bool,
  dropdown: external_prop_types_default.a.bool,
  dropdownUp: external_prop_types_default.a.bool,
  hoverable: external_prop_types_default.a.bool,
  children: external_prop_types_default.a.node,
  arrowless: external_prop_types_default.a.bool,
  renderAs: render_as
});
item_NavbarItem.defaultProps = components_item_objectSpread({}, modifiers.defaultProps, {
  style: undefined,
  className: undefined,
  active: undefined,
  children: null,
  dropdown: undefined,
  hoverable: undefined,
  dropdownUp: undefined,
  arrowless: undefined,
  renderAs: 'a'
});
/* harmony default export */ var navbar_components_item = (item_NavbarItem);
// CONCATENATED MODULE: ./src/components/navbar/components/dropdown.js
function components_dropdown_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_dropdown_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_dropdown_ownKeys(source, true).forEach(function (key) { components_dropdown_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_dropdown_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function components_dropdown_extends() { components_dropdown_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return components_dropdown_extends.apply(this, arguments); }

function components_dropdown_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_dropdown_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_dropdown_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var dropdown_NavbarDropdown = function NavbarDropdown(_ref) {
  var className = _ref.className,
      boxed = _ref.boxed,
      right = _ref.right,
      children = _ref.children,
      props = components_dropdown_objectWithoutProperties(_ref, ["className", "boxed", "right", "children"]);

  return external_react_default.a.createElement(components_element, components_dropdown_extends({}, props, {
    className: classnames_default()('navbar-dropdown', className, {
      'is-boxed': boxed,
      'is-right': right
    })
  }), children);
};

dropdown_NavbarDropdown.propTypes = components_dropdown_objectSpread({}, modifiers.propTypes, {
  style: external_prop_types_default.a.shape({}),
  className: external_prop_types_default.a.string,
  children: external_prop_types_default.a.node,
  renderAs: render_as,
  boxed: external_prop_types_default.a.bool,
  right: external_prop_types_default.a.bool
});
dropdown_NavbarDropdown.defaultProps = components_dropdown_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  children: null,
  renderAs: 'span',
  boxed: false,
  right: false
});
/* harmony default export */ var components_dropdown = (dropdown_NavbarDropdown);
// CONCATENATED MODULE: ./src/components/navbar/components/divider.js
function components_divider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_divider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_divider_ownKeys(source, true).forEach(function (key) { components_divider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_divider_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_divider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function components_divider_extends() { components_divider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return components_divider_extends.apply(this, arguments); }

function components_divider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_divider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_divider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var divider_NavbarDivider = function NavbarDivider(_ref) {
  var className = _ref.className,
      props = components_divider_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, components_divider_extends({}, props, {
    className: classnames_default()('navbar-divider', className)
  }));
};

divider_NavbarDivider.propTypes = components_divider_objectSpread({}, modifiers.propTypes, {
  style: external_prop_types_default.a.shape({}),
  className: external_prop_types_default.a.string
});
divider_NavbarDivider.defaultProps = components_divider_objectSpread({}, modifiers.defaultProps, {
  style: undefined,
  className: undefined
});
/* harmony default export */ var components_divider = (divider_NavbarDivider);
// CONCATENATED MODULE: ./src/components/navbar/components/link.js
function link_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function link_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { link_ownKeys(source, true).forEach(function (key) { link_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { link_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function link_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function link_extends() { link_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return link_extends.apply(this, arguments); }

function link_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = link_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function link_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var link_NavbarLink = function NavbarLink(_ref) {
  var className = _ref.className,
      children = _ref.children,
      arrowless = _ref.arrowless,
      props = link_objectWithoutProperties(_ref, ["className", "children", "arrowless"]);

  return external_react_default.a.createElement(components_element, link_extends({}, props, {
    className: classnames_default()('navbar-link', className, {
      'is-arrowless': arrowless
    })
  }), children);
};

link_NavbarLink.propTypes = link_objectSpread({}, modifiers.propTypes, {
  style: external_prop_types_default.a.shape({}),
  className: external_prop_types_default.a.string,
  children: external_prop_types_default.a.node,
  renderAs: render_as,
  arrowless: external_prop_types_default.a.bool
});
link_NavbarLink.defaultProps = link_objectSpread({}, modifiers.defaultProps, {
  style: undefined,
  className: undefined,
  children: null,
  arrowless: undefined,
  renderAs: 'span'
});
/* harmony default export */ var components_link = (link_NavbarLink);
// CONCATENATED MODULE: ./src/components/navbar/components/container.js
function components_container_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_container_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_container_ownKeys(source, true).forEach(function (key) { components_container_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_container_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_container_extends() { components_container_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return components_container_extends.apply(this, arguments); }

function components_container_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function components_container_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_container_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_container_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var container_NavbarContainer = function NavbarContainer(_ref) {
  var className = _ref.className,
      children = _ref.children,
      position = _ref.position,
      props = components_container_objectWithoutProperties(_ref, ["className", "children", "position"]);

  return external_react_default.a.createElement(components_element, components_container_extends({}, props, {
    className: classnames_default()(components_container_defineProperty({}, "navbar-".concat(position), position), className)
  }), children);
};

container_NavbarContainer.propTypes = components_container_objectSpread({}, modifiers.propTypes, {
  style: external_prop_types_default.a.shape({}),
  className: external_prop_types_default.a.string,
  children: external_prop_types_default.a.node,
  renderAs: render_as,
  position: external_prop_types_default.a.oneOf(['start', 'end'])
});
container_NavbarContainer.defaultProps = components_container_objectSpread({}, modifiers.defaultProps, {
  style: undefined,
  className: undefined,
  children: null,
  renderAs: 'div',
  position: 'start'
});
/* harmony default export */ var components_container = (container_NavbarContainer);
// CONCATENATED MODULE: ./src/components/navbar/navbar.js
function navbar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function navbar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { navbar_ownKeys(source, true).forEach(function (key) { navbar_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { navbar_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function navbar_extends() { navbar_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return navbar_extends.apply(this, arguments); }

function navbar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function navbar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = navbar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function navbar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


















var navbar_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));
var htmlClass = '';
var getHtmlClasses = function getHtmlClasses() {
  return htmlClass;
};

var navbar_Navbar = function Navbar(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      fixed = _ref.fixed,
      transparent = _ref.transparent,
      color = _ref.color,
      active = _ref.active,
      props = navbar_objectWithoutProperties(_ref, ["children", "className", "fixed", "transparent", "color", "active"]);

  htmlClass = fixed ? "has-navbar-fixed-".concat(fixed) : '';
  Object(external_react_["useEffect"])(function () {
    if (!can_use_dom) {
      return function () {};
    }

    var html = window.document.querySelector('html');

    if (!html.classList.contains("has-navbar-fixed-".concat(fixed))) {
      html.classList.remove('has-navbar-fixed-top');
      html.classList.remove('has-navbar-fixed-bottom');
    }

    if (fixed) {
      html.classList.add("has-navbar-fixed-".concat(fixed));
    }

    return function () {
      return window.document.querySelector('html').classList.remove("has-navbar-fixed-".concat(fixed));
    };
  }, [fixed]);
  return external_react_default.a.createElement(ShowContext.Provider, {
    value: active
  }, external_react_default.a.createElement(components_element, navbar_extends({}, props, {
    role: "navigation",
    className: classnames_default()('navbar', modifiers.classnames(props), className, (_classnames = {
      'is-transparent': transparent
    }, navbar_defineProperty(_classnames, "is-fixed-".concat(fixed), fixed), navbar_defineProperty(_classnames, "is-".concat(color), color), _classnames))
  }), children));
};

navbar_Navbar.propTypes = navbar_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  transparent: external_prop_types_default.a.bool,
  renderAs: render_as,
  fixed: external_prop_types_default.a.oneOf(['top', 'bottom']),
  color: external_prop_types_default.a.oneOf(navbar_colors),
  active: external_prop_types_default.a.bool
});
navbar_Navbar.defaultProps = navbar_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'nav',
  transparent: false,
  active: false,
  fixed: undefined,
  color: undefined
});
navbar_Navbar.Brand = brand;
navbar_Navbar.Burger = burger;
navbar_Navbar.Menu = menu;
navbar_Navbar.Item = navbar_components_item;
navbar_Navbar.Dropdown = components_dropdown;
navbar_Navbar.Link = components_link;
navbar_Navbar.Divider = components_divider;
navbar_Navbar.Container = components_container;
/* harmony default export */ var navbar = (navbar_Navbar);
// EXTERNAL MODULE: ./src/components/navbar/navbar.sass
var navbar_navbar = __webpack_require__(31);

// CONCATENATED MODULE: ./src/components/navbar/index.js


/* harmony default export */ var components_navbar = (navbar);

// EXTERNAL MODULE: ./src/components/tabs/tabs.sass
var tabs = __webpack_require__(32);

// CONCATENATED MODULE: ./src/components/tabs/components/tab.js
function tab_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tab_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tab_ownKeys(source, true).forEach(function (key) { tab_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tab_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function tab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function tab_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = tab_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function tab_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var tab_Tab = function Tab(_ref) {
  var children = _ref.children,
      className = _ref.className,
      style = _ref.style,
      active = _ref.active,
      domRef = _ref.domRef,
      props = tab_objectWithoutProperties(_ref, ["children", "className", "style", "active", "domRef"]);

  return external_react_default.a.createElement("li", {
    ref: domRef,
    style: style,
    className: classnames_default()(className, {
      'is-active': active
    })
  }, external_react_default.a.createElement(components_element, props, children));
};

tab_Tab.propTypes = tab_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  active: external_prop_types_default.a.bool
});
tab_Tab.defaultProps = tab_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'a',
  active: false
});
/* harmony default export */ var tab = (tab_Tab);
// CONCATENATED MODULE: ./src/components/tabs/tabs.js
function tabs_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tabs_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tabs_ownKeys(source, true).forEach(function (key) { tabs_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tabs_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function tabs_extends() { tabs_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return tabs_extends.apply(this, arguments); }

function tabs_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function tabs_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = tabs_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function tabs_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var tabs_Tabs = function Tabs(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      align = _ref.align,
      size = _ref.size,
      type = _ref.type,
      fullwidth = _ref.fullwidth,
      props = tabs_objectWithoutProperties(_ref, ["children", "className", "align", "size", "type", "fullwidth"]);

  return external_react_default.a.createElement(components_element, tabs_extends({}, props, {
    className: classnames_default()('tabs', className, (_classnames = {}, tabs_defineProperty(_classnames, "is-".concat(align), align), tabs_defineProperty(_classnames, "is-".concat(size), size), tabs_defineProperty(_classnames, 'is-toggle', type === 'toggle-rounded'), tabs_defineProperty(_classnames, "is-".concat(type), type), tabs_defineProperty(_classnames, 'is-fullwidth', fullwidth), _classnames))
  }), external_react_default.a.createElement("ul", null, children));
};

tabs_Tabs.Tab = tab;
tabs_Tabs.propTypes = tabs_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  align: external_prop_types_default.a.oneOf(['centered', 'right']),
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),

  /** This is called style on Bulma documentation */
  type: external_prop_types_default.a.oneOf(['toggle', 'boxed', 'toggle-rounded']),
  fullwidth: external_prop_types_default.a.bool
});
tabs_Tabs.defaultProps = tabs_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'div',
  align: undefined,
  size: undefined,
  type: undefined,
  fullwidth: false
});
/* harmony default export */ var tabs_tabs = (tabs_Tabs);
// CONCATENATED MODULE: ./src/components/tabs/index.js


// EXTERNAL MODULE: ./src/components/pagination/pagination.sass
var pagination = __webpack_require__(33);

// CONCATENATED MODULE: ./src/components/pagination/pagination.js
function pagination_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function pagination_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pagination_ownKeys(source, true).forEach(function (key) { pagination_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pagination_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function pagination_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { pagination_typeof = function _typeof(obj) { return typeof obj; }; } else { pagination_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return pagination_typeof(obj); }

function pagination_extends() { pagination_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return pagination_extends.apply(this, arguments); }

function pagination_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = pagination_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function pagination_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function pagination_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function pagination_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function pagination_createClass(Constructor, protoProps, staticProps) { if (protoProps) pagination_defineProperties(Constructor.prototype, protoProps); if (staticProps) pagination_defineProperties(Constructor, staticProps); return Constructor; }

function pagination_possibleConstructorReturn(self, call) { if (call && (pagination_typeof(call) === "object" || typeof call === "function")) { return call; } return pagination_assertThisInitialized(self); }

function pagination_getPrototypeOf(o) { pagination_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return pagination_getPrototypeOf(o); }

function pagination_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function pagination_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) pagination_setPrototypeOf(subClass, superClass); }

function pagination_setPrototypeOf(o, p) { pagination_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return pagination_setPrototypeOf(o, p); }

function pagination_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var pagination_Pagination =
/*#__PURE__*/
function (_React$PureComponent) {
  pagination_inherits(Pagination, _React$PureComponent);

  function Pagination() {
    var _getPrototypeOf2;

    var _this;

    pagination_classCallCheck(this, Pagination);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = pagination_possibleConstructorReturn(this, (_getPrototypeOf2 = pagination_getPrototypeOf(Pagination)).call.apply(_getPrototypeOf2, [this].concat(args)));

    pagination_defineProperty(pagination_assertThisInitialized(_this), "goToPage", function (page) {
      return function (evt) {
        evt.preventDefault();
        var onChange = _this.props.onChange;
        onChange(page);
      };
    });

    pagination_defineProperty(pagination_assertThisInitialized(_this), "firstPage", function (current, last) {
      var delta = _this.props.delta;

      if (current === 1) {
        return 1;
      }

      var minPage = last - delta * 2;
      var page = Math.min(current - delta, minPage);
      return page <= 0 ? 1 : page;
    });

    pagination_defineProperty(pagination_assertThisInitialized(_this), "lastPage", function (current, total) {
      var delta = _this.props.delta;

      if (current === total) {
        return total;
      }

      var maxPage = delta * 2 + 1;
      var page = Math.max(current + delta, maxPage);
      return page > total ? total : page;
    });

    return _this;
  }

  pagination_createClass(Pagination, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          current = _this$props.current,
          disabled = _this$props.disabled,
          total = _this$props.total,
          next = _this$props.next,
          previous = _this$props.previous,
          showPrevNext = _this$props.showPrevNext,
          delta = _this$props.delta,
          autoHide = _this$props.autoHide,
          className = _this$props.className,
          onChange = _this$props.onChange,
          props = pagination_objectWithoutProperties(_this$props, ["current", "disabled", "total", "next", "previous", "showPrevNext", "delta", "autoHide", "className", "onChange"]);

      if (total <= 1 && autoHide) {
        return null;
      }

      if (current > total) {
        return null;
      }

      var lastPage = this.lastPage(current, total);
      var firstPage = this.firstPage(current, lastPage);
      var prevDisabled = current === 1 || disabled;
      var nextDisabled = current === total || disabled;
      return external_react_default.a.createElement(components_element, pagination_extends({}, props, {
        className: classnames_default()('pagination', className),
        "aria-label": "pagination"
      }), showPrevNext && external_react_default.a.createElement(external_react_default.a.Fragment, null, external_react_default.a.createElement("a", {
        role: "button",
        tabIndex: 0,
        onClick: prevDisabled ? undefined : this.goToPage(current - 1),
        className: "pagination-previous",
        title: "This is the first page",
        disabled: prevDisabled
      }, previous), external_react_default.a.createElement("a", {
        role: "button",
        tabIndex: 0,
        onClick: nextDisabled ? undefined : this.goToPage(current + 1),
        className: "pagination-next",
        disabled: nextDisabled
      }, next)), delta > 0 && external_react_default.a.createElement(external_react_default.a.Fragment, null, external_react_default.a.createElement("ul", {
        className: "pagination-list"
      }, Array(lastPage - firstPage + 1).fill(0).map(function (_, i) {
        return (// eslint-disable-next-line react/no-array-index-key
          external_react_default.a.createElement("li", {
            key: i + firstPage
          }, external_react_default.a.createElement("a", {
            role: "button",
            tabIndex: 0,
            className: classnames_default()('pagination-link', {
              'is-current': current === i + firstPage
            }),
            onClick: current === firstPage + i ? undefined : _this2.goToPage(firstPage + i),
            "aria-label": "Page ".concat(i + firstPage),
            "aria-current": "page",
            disabled: disabled
          }, i + firstPage))
        );
      }))));
    }
  }]);

  return Pagination;
}(external_react_default.a.PureComponent);


pagination_Pagination.propTypes = pagination_objectSpread({}, modifiers.propTypes, {
  /** Current page */
  current: external_prop_types_default.a.number,

  /** whether to disable the buttons */
  disabled: external_prop_types_default.a.bool,

  /** Total pages in total */
  total: external_prop_types_default.a.number,

  /** Amount og pages to display at the left and right of the current (if delta 2 and current page is 3, the paginator will display pages from 1 to 5) */
  delta: external_prop_types_default.a.number,
  onChange: external_prop_types_default.a.func,

  /** Text of the Next button */
  next: external_prop_types_default.a.node,

  /** Text of the Previous button */
  previous: external_prop_types_default.a.node,
  showPrevNext: external_prop_types_default.a.bool,
  autoHide: external_prop_types_default.a.bool,

  /**
   * Classname of the container of the pagination, this could be used to customize the inner views
   */
  className: external_prop_types_default.a.string
});
pagination_Pagination.defaultProps = pagination_objectSpread({}, modifiers.defaultProps, {
  total: 1,
  current: 1,
  delta: 1,
  onChange: function onChange() {},
  next: 'Next',
  previous: 'Previous',
  showPrevNext: true,
  disabled: undefined,
  autoHide: true,
  className: undefined,
  renderAs: 'nav'
});
// CONCATENATED MODULE: ./src/components/pagination/index.js


// EXTERNAL MODULE: ./src/components/menu/menu.sass
var menu_menu = __webpack_require__(34);

// CONCATENATED MODULE: ./src/components/menu/components/list/components/item.js
function list_components_item_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function list_components_item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { list_components_item_ownKeys(source, true).forEach(function (key) { list_components_item_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { list_components_item_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function list_components_item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function list_components_item_extends() { list_components_item_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return list_components_item_extends.apply(this, arguments); }

function list_components_item_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = list_components_item_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function list_components_item_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




/* eslint-disable-next-line import/no-cycle */






var item_MenuListItem = function MenuListItem(_ref) {
  var children = _ref.children,
      active = _ref.active,
      className = _ref.className,
      ref = _ref.domRef,
      props = list_components_item_objectWithoutProperties(_ref, ["children", "active", "className", "domRef"]);

  if (typeof children !== 'string' && external_react_default.a.Children.toArray(children).length === 1 && external_react_default.a.Children.only(children).type === components_list_list) {
    var child = external_react_default.a.Children.only(children);
    return external_react_default.a.createElement("li", {
      ref: ref
    }, external_react_default.a.createElement(components_element, list_components_item_extends({
      className: classnames_default()(className, {
        'is-active': active
      })
    }, props), child.props.title), external_react_default.a.cloneElement(child, {
      title: undefined
    }));
  }

  return external_react_default.a.createElement("li", {
    ref: ref
  }, external_react_default.a.createElement(components_element, list_components_item_extends({
    className: classnames_default()(className, {
      'is-active': active
    })
  }, props), children));
};

item_MenuListItem.propTypes = list_components_item_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  children: external_prop_types_default.a.oneOfType([external_prop_types_default.a.string, external_prop_types_default.a.element]),
  active: external_prop_types_default.a.bool,
  renderAs: render_as
});
item_MenuListItem.defaultProps = list_components_item_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  children: null,
  active: false,
  renderAs: 'a'
});
/* harmony default export */ var list_components_item = (item_MenuListItem);
// CONCATENATED MODULE: ./src/components/menu/components/list/list.js
function list_list_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function list_list_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { list_list_ownKeys(source, true).forEach(function (key) { list_list_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { list_list_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function list_list_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function list_list_extends() { list_list_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return list_list_extends.apply(this, arguments); }

function list_list_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = list_list_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function list_list_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




/* eslint-disable-next-line import/no-cycle */





var list_MenuList = function MenuList(_ref) {
  var className = _ref.className,
      title = _ref.title,
      props = list_list_objectWithoutProperties(_ref, ["className", "title"]);

  return external_react_default.a.createElement(external_react_default.a.Fragment, null, title && external_react_default.a.createElement("p", {
    className: "menu-label"
  }, title), external_react_default.a.createElement(components_element, list_list_extends({
    renderAs: "ul",
    className: classnames_default()('menu-list', className)
  }, props)));
};

list_MenuList.Item = list_components_item;
list_MenuList.propTypes = list_list_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  title: external_prop_types_default.a.node
});
list_MenuList.defaultProps = list_list_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  title: undefined
});
/* harmony default export */ var components_list_list = (list_MenuList);
// CONCATENATED MODULE: ./src/components/menu/components/list/index.js

// CONCATENATED MODULE: ./src/components/menu/menu.js
function menu_menu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function menu_menu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { menu_menu_ownKeys(source, true).forEach(function (key) { menu_menu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { menu_menu_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function menu_menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function menu_menu_extends() { menu_menu_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return menu_menu_extends.apply(this, arguments); }

function menu_menu_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = menu_menu_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function menu_menu_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var menu_Menu = function Menu(_ref) {
  var className = _ref.className,
      props = menu_menu_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, menu_menu_extends({}, props, {
    className: classnames_default()('menu', className)
  }));
};

menu_Menu.List = components_list_list;
menu_Menu.propTypes = menu_menu_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
menu_Menu.defaultProps = menu_menu_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'aside'
});
/* harmony default export */ var components_menu_menu = (menu_Menu);
// CONCATENATED MODULE: ./src/components/menu/index.js


// EXTERNAL MODULE: ./src/components/message/message.sass
var message = __webpack_require__(35);

// CONCATENATED MODULE: ./src/components/message/components/body.js
function components_body_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_body_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_body_ownKeys(source, true).forEach(function (key) { components_body_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_body_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_body_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function components_body_extends() { components_body_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return components_body_extends.apply(this, arguments); }

function components_body_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_body_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_body_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var body_MessageBody = function MessageBody(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = components_body_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, components_body_extends({}, props, {
    className: classnames_default()('message-body', className)
  }), children);
};

body_MessageBody.propTypes = components_body_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
body_MessageBody.defaultProps = components_body_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var components_body = (body_MessageBody);
// CONCATENATED MODULE: ./src/components/message/components/header.js
function components_header_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_header_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_header_ownKeys(source, true).forEach(function (key) { components_header_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_header_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function components_header_extends() { components_header_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return components_header_extends.apply(this, arguments); }

function components_header_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_header_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_header_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var header_MessageHeader = function MessageHeader(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = components_header_objectWithoutProperties(_ref, ["children", "className"]);

  return external_react_default.a.createElement(components_element, components_header_extends({}, props, {
    className: classnames_default()('message-header', className)
  }), children);
};

header_MessageHeader.propTypes = components_header_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
header_MessageHeader.defaultProps = components_header_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var components_header = (header_MessageHeader);
// CONCATENATED MODULE: ./src/components/message/message.js
function message_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function message_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { message_ownKeys(source, true).forEach(function (key) { message_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { message_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function message_extends() { message_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return message_extends.apply(this, arguments); }

function message_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function message_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = message_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function message_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }










var message_colors = [null].concat(Object.keys(constants.COLORS).map(function (key) {
  return constants.COLORS[key];
}));

var message_Message = function Message(_ref) {
  var _classnames;

  var children = _ref.children,
      className = _ref.className,
      color = _ref.color,
      size = _ref.size,
      props = message_objectWithoutProperties(_ref, ["children", "className", "color", "size"]);

  return external_react_default.a.createElement(components_element, message_extends({}, props, {
    className: classnames_default()('message', className, (_classnames = {}, message_defineProperty(_classnames, "is-".concat(color), color), message_defineProperty(_classnames, "is-".concat(size), size), _classnames))
  }), children);
};

message_Message.Body = components_body;
message_Message.Header = components_header;
message_Message.propTypes = message_objectSpread({}, modifiers.propTypes, {
  children: external_prop_types_default.a.node,
  className: external_prop_types_default.a.string,
  style: external_prop_types_default.a.shape({}),
  renderAs: render_as,
  size: external_prop_types_default.a.oneOf(['small', 'medium', 'large']),
  color: external_prop_types_default.a.oneOf(message_colors)
});
message_Message.defaultProps = message_objectSpread({}, modifiers.defaultProps, {
  children: null,
  className: undefined,
  style: undefined,
  renderAs: 'article',
  color: undefined,
  size: undefined
});
/* harmony default export */ var message_message = (message_Message);
// CONCATENATED MODULE: ./src/components/message/index.js


// EXTERNAL MODULE: ./src/components/panel/panel.sass
var panel = __webpack_require__(36);

// CONCATENATED MODULE: ./src/components/panel/components/block.js
function block_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function block_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { block_ownKeys(source, true).forEach(function (key) { block_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { block_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function block_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function block_extends() { block_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return block_extends.apply(this, arguments); }

function block_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = block_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function block_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var block_PanelBlock = function PanelBlock(_ref) {
  var className = _ref.className,
      active = _ref.active,
      props = block_objectWithoutProperties(_ref, ["className", "active"]);

  return external_react_default.a.createElement(components_element, block_extends({}, props, {
    className: classnames_default()('panel-block', className, {
      'is-active': active
    })
  }));
};

block_PanelBlock.propTypes = block_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as,
  active: external_prop_types_default.a.bool
});
block_PanelBlock.defaultProps = block_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'div',
  active: false
});
/* harmony default export */ var block = (block_PanelBlock);
// CONCATENATED MODULE: ./src/components/panel/components/header.js
function panel_components_header_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function panel_components_header_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { panel_components_header_ownKeys(source, true).forEach(function (key) { panel_components_header_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { panel_components_header_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function panel_components_header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function panel_components_header_extends() { panel_components_header_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return panel_components_header_extends.apply(this, arguments); }

function panel_components_header_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = panel_components_header_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function panel_components_header_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var header_PanelHeader = function PanelHeader(_ref) {
  var className = _ref.className,
      props = panel_components_header_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, panel_components_header_extends({}, props, {
    className: classnames_default()('panel-heading', className)
  }));
};

header_PanelHeader.propTypes = panel_components_header_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
header_PanelHeader.defaultProps = panel_components_header_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var panel_components_header = (header_PanelHeader);
// CONCATENATED MODULE: ./src/components/panel/components/icon.js
function components_icon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_icon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_icon_ownKeys(source, true).forEach(function (key) { components_icon_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_icon_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_icon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function components_icon_extends() { components_icon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return components_icon_extends.apply(this, arguments); }

function components_icon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_icon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_icon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var icon_PanelIcon = function PanelIcon(_ref) {
  var className = _ref.className,
      props = components_icon_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, components_icon_extends({}, props, {
    className: classnames_default()('panel-icon', className)
  }));
};

icon_PanelIcon.propTypes = components_icon_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
icon_PanelIcon.defaultProps = components_icon_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'span'
});
/* harmony default export */ var components_icon = (icon_PanelIcon);
// CONCATENATED MODULE: ./src/components/panel/components/tabs/components/tab.js
function components_tab_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_tab_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_tab_ownKeys(source, true).forEach(function (key) { components_tab_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_tab_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function components_tab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function tab_extends() { tab_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return tab_extends.apply(this, arguments); }

function components_tab_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = components_tab_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function components_tab_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








var tab_PanelTabsTab = function PanelTabsTab(_ref) {
  var className = _ref.className,
      active = _ref.active,
      props = components_tab_objectWithoutProperties(_ref, ["className", "active"]);

  return external_react_default.a.createElement(components_element, tab_extends({}, props, {
    className: classnames_default()(className, {
      'is-active': active
    })
  }));
};

tab_PanelTabsTab.propTypes = components_tab_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as,
  active: external_prop_types_default.a.bool
});
tab_PanelTabsTab.defaultProps = components_tab_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'a',
  active: false
});
/* harmony default export */ var components_tab = (tab_PanelTabsTab);
// CONCATENATED MODULE: ./src/components/panel/components/tabs/tabs.js
function tabs_tabs_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tabs_tabs_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tabs_tabs_ownKeys(source, true).forEach(function (key) { tabs_tabs_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tabs_tabs_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function tabs_tabs_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function tabs_tabs_extends() { tabs_tabs_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return tabs_tabs_extends.apply(this, arguments); }

function tabs_tabs_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = tabs_tabs_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function tabs_tabs_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var tabs_PanelTabs = function PanelTabs(_ref) {
  var className = _ref.className,
      props = tabs_tabs_objectWithoutProperties(_ref, ["className"]);

  return external_react_default.a.createElement(components_element, tabs_tabs_extends({}, props, {
    className: classnames_default()('panel-tabs', className)
  }));
};

tabs_PanelTabs.Tab = components_tab;
tabs_PanelTabs.propTypes = tabs_tabs_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as
});
tabs_PanelTabs.defaultProps = tabs_tabs_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'div'
});
/* harmony default export */ var components_tabs_tabs = (tabs_PanelTabs);
// CONCATENATED MODULE: ./src/components/panel/components/tabs/index.js

// CONCATENATED MODULE: ./src/components/panel/panel.js
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function panel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function panel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { panel_ownKeys(source, true).forEach(function (key) { panel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { panel_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function panel_extends() { panel_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return panel_extends.apply(this, arguments); }

function panel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function panel_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = panel_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function panel_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }













var panel_Panel = function Panel(_ref) {
  var color = _ref.color,
      className = _ref.className,
      props = panel_objectWithoutProperties(_ref, ["color", "className"]);

  return external_react_default.a.createElement(components_element, panel_extends({}, props, {
    className: classnames_default()('panel', className, panel_defineProperty({}, "is-".concat(color), color))
  }));
};

panel_Panel.Header = panel_components_header;
panel_Panel.Tabs = components_tabs_tabs;
panel_Panel.Block = block;
panel_Panel.Icon = components_icon;
panel_Panel.propTypes = panel_objectSpread({}, modifiers.propTypes, {
  className: external_prop_types_default.a.string,
  renderAs: render_as,
  color: external_prop_types_default.a.oneOf([null, ''].concat(_toConsumableArray(Object.values(constants.COLORS))))
});
panel_Panel.defaultProps = panel_objectSpread({}, modifiers.defaultProps, {
  className: undefined,
  renderAs: 'nav',
  color: undefined
});
/* harmony default export */ var panel_panel = (panel_Panel);
// CONCATENATED MODULE: ./src/components/panel/index.js


// CONCATENATED MODULE: ./src/index.js
/* concated harmony reexport Box */__webpack_require__.d(__webpack_exports__, "Box", function() { return components_box; });
/* concated harmony reexport Button */__webpack_require__.d(__webpack_exports__, "Button", function() { return components_button_button; });
/* concated harmony reexport Breadcrumb */__webpack_require__.d(__webpack_exports__, "Breadcrumb", function() { return components_breadcrumb; });
/* concated harmony reexport Card */__webpack_require__.d(__webpack_exports__, "Card", function() { return card_card; });
/* concated harmony reexport Columns */__webpack_require__.d(__webpack_exports__, "Columns", function() { return components_columns; });
/* concated harmony reexport Container */__webpack_require__.d(__webpack_exports__, "Container", function() { return container_container; });
/* concated harmony reexport Content */__webpack_require__.d(__webpack_exports__, "Content", function() { return components_content_content; });
/* concated harmony reexport Footer */__webpack_require__.d(__webpack_exports__, "Footer", function() { return components_footer_footer; });
/* concated harmony reexport Form */__webpack_require__.d(__webpack_exports__, "Form", function() { return components_form_namespaceObject; });
/* concated harmony reexport Heading */__webpack_require__.d(__webpack_exports__, "Heading", function() { return components_heading_heading; });
/* concated harmony reexport Hero */__webpack_require__.d(__webpack_exports__, "Hero", function() { return hero_hero; });
/* concated harmony reexport Image */__webpack_require__.d(__webpack_exports__, "Image", function() { return image_Image; });
/* concated harmony reexport Level */__webpack_require__.d(__webpack_exports__, "Level", function() { return level_level; });
/* concated harmony reexport List */__webpack_require__.d(__webpack_exports__, "List", function() { return components_list; });
/* concated harmony reexport Media */__webpack_require__.d(__webpack_exports__, "Media", function() { return media_media; });
/* concated harmony reexport Notification */__webpack_require__.d(__webpack_exports__, "Notification", function() { return components_notification_notification; });
/* concated harmony reexport Progress */__webpack_require__.d(__webpack_exports__, "Progress", function() { return progress_progress; });
/* concated harmony reexport Section */__webpack_require__.d(__webpack_exports__, "Section", function() { return section_section; });
/* concated harmony reexport Table */__webpack_require__.d(__webpack_exports__, "Table", function() { return table_table; });
/* concated harmony reexport Tag */__webpack_require__.d(__webpack_exports__, "Tag", function() { return tag_tag; });
/* concated harmony reexport Tile */__webpack_require__.d(__webpack_exports__, "Tile", function() { return tile_tile; });
/* concated harmony reexport Modal */__webpack_require__.d(__webpack_exports__, "Modal", function() { return modal_modal; });
/* concated harmony reexport Dropdown */__webpack_require__.d(__webpack_exports__, "Dropdown", function() { return dropdown_Dropdown; });
/* concated harmony reexport Icon */__webpack_require__.d(__webpack_exports__, "Icon", function() { return components_icon_icon; });
/* concated harmony reexport Loader */__webpack_require__.d(__webpack_exports__, "Loader", function() { return loader_loader; });
/* concated harmony reexport Navbar */__webpack_require__.d(__webpack_exports__, "Navbar", function() { return components_navbar; });
/* concated harmony reexport Tabs */__webpack_require__.d(__webpack_exports__, "Tabs", function() { return tabs_tabs; });
/* concated harmony reexport Pagination */__webpack_require__.d(__webpack_exports__, "Pagination", function() { return pagination_Pagination; });
/* concated harmony reexport Menu */__webpack_require__.d(__webpack_exports__, "Menu", function() { return components_menu_menu; });
/* concated harmony reexport Message */__webpack_require__.d(__webpack_exports__, "Message", function() { return message_message; });
/* concated harmony reexport Panel */__webpack_require__.d(__webpack_exports__, "Panel", function() { return panel_panel; });
/* concated harmony reexport Element */__webpack_require__.d(__webpack_exports__, "Element", function() { return components_element; });



































/***/ })
/******/ ]);
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./src/lib/components/Toggle.react.js":
/*!********************************************!*\
  !*** ./src/lib/components/Toggle.react.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Users_josephdamiba_Downloads_code_work_plotly_dash_components_my_dash_component_node_modules_react_bulma_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/react-bulma-components */ "./node_modules/react-bulma-components/dist/index.js");
/* harmony import */ var _Users_josephdamiba_Downloads_code_work_plotly_dash_components_my_dash_component_node_modules_react_bulma_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Users_josephdamiba_Downloads_code_work_plotly_dash_components_my_dash_component_node_modules_react_bulma_components__WEBPACK_IMPORTED_MODULE_2__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var Toggle = /*#__PURE__*/function (_Component) {
  _inherits(Toggle, _Component);

  var _super = _createSuper(Toggle);

  function Toggle(props) {
    var _this;

    _classCallCheck(this, Toggle);

    _this = _super.call(this, props);
    _this.state = {
      isToggleOn: true,
      counter: 0
    }; // This binding is necessary to make `this` work in the callback

    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Toggle, [{
    key: "handleClick",
    value: function handleClick() {
      this.setState(function (state) {
        return {
          isToggleOn: !state.isToggleOn,
          counter: state.counter + 1
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          id = _this$props.id,
          label = _this$props.label,
          setProps = _this$props.setProps,
          value = _this$props.value;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, label), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Users_josephdamiba_Downloads_code_work_plotly_dash_components_my_dash_component_node_modules_react_bulma_components__WEBPACK_IMPORTED_MODULE_2__["Button"], {
        className: "button",
        onClick: this.handleClick
      }, this.state.isToggleOn ? 'ON' : 'OFF'), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, this.state.counter));
    }
  }]);

  return Toggle;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (Toggle);
Toggle.defaultProps = {};
Toggle.propTypes = {
  /**
   * The ID used to identify this component in Dash callbacks.
   */
  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * A label that will be printed when this component is rendered.
   */
  label: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,

  /**
   * The value displayed in the input.
   */
  value: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * Dash-assigned callback that should be called to report property changes
   * to Dash, to make them available for callbacks.
   */
  setProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func
};

/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9kYXNoX2NvbXBvbmVudC8uL25vZGVfbW9kdWxlcy9yZWFjdC1idWxtYS1jb21wb25lbnRzL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbXlfZGFzaF9jb21wb25lbnQvLi9zcmMvbGliL2NvbXBvbmVudHMvVG9nZ2xlLnJlYWN0LmpzIl0sIm5hbWVzIjpbIlRvZ2dsZSIsInByb3BzIiwic3RhdGUiLCJpc1RvZ2dsZU9uIiwiY291bnRlciIsImhhbmRsZUNsaWNrIiwiYmluZCIsInNldFN0YXRlIiwiaWQiLCJsYWJlbCIsInNldFByb3BzIiwidmFsdWUiLCJDb21wb25lbnQiLCJkZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwiZnVuYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUt1QztBQUM3QyxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsc0RBQVk7O0FBRXJDLE9BQU87QUFDUDtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLDRDQUFPOztBQUVoQyxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxnRUFBZ0UsdUJBQXVCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFN1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU8sS0FBSTtBQUNYO0FBQ0E7QUFDQSxHQUFHLFdBQVcsS0FBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBLDRCQUE0QixjQUFjOztBQUUxQyxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxvREFBVzs7QUFFcEMsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsY0FBYyxFQUFFO0FBQzVGLDhFQUE4RSxnQkFBZ0IsRUFBRTtBQUNoRyw0RUFBNEUsY0FBYyxFQUFFO0FBQzVGLDRFQUE0RSx5QkFBeUIsRUFBRTtBQUN2RywrRUFBK0UsNEJBQTRCLEVBQUU7QUFDN0csNkVBQTZFLDBCQUEwQixFQUFFO0FB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bnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJyZWFjdC1idWxtYS1jb21wb25lbnRzXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJlYWN0LWJ1bG1hLWNvbXBvbmVudHNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicmVhY3QtYnVsbWEtY29tcG9uZW50c1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzcpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187ZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyohXG4gIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuXG4vKiBnbG9iYWwgZGVmaW5lICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKCFhcmcpIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgYXJnVHlwZSA9IF90eXBlb2YoYXJnKTtcblxuICAgICAgaWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChhcmcpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuICAgICAgICB2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cbiAgICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKGlubmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG4gICAgICAgICAgaWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuICB9XG5cbiAgaWYgKCB0cnVlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgY2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG4gIH0gZWxzZSBpZiAoIHRydWUgJiYgX3R5cGVvZihfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKSA9PT0gJ29iamVjdCcgJiYgX193ZWJwYWNrX3JlcXVpcmVfXygzKSkge1xuICAgIC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XG4gICAgfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG4gIH1cbn0pKCk7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oX193ZWJwYWNrX2FtZF9vcHRpb25zX18pIHsvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywge30pKVxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbnZhciBjb21wb25lbnRzX2Zvcm1fbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoY29tcG9uZW50c19mb3JtX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29tcG9uZW50c19mb3JtX25hbWVzcGFjZU9iamVjdCwgXCJGaWVsZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZpZWxkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb21wb25lbnRzX2Zvcm1fbmFtZXNwYWNlT2JqZWN0LCBcIkNvbnRyb2xcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb250cm9sOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb21wb25lbnRzX2Zvcm1fbmFtZXNwYWNlT2JqZWN0LCBcIklucHV0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5wdXQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbXBvbmVudHNfZm9ybV9uYW1lc3BhY2VPYmplY3QsIFwiTGFiZWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wb25lbnRzX2xhYmVsOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb21wb25lbnRzX2Zvcm1fbmFtZXNwYWNlT2JqZWN0LCBcIlRleHRhcmVhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29tcG9uZW50c190ZXh0YXJlYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29tcG9uZW50c19mb3JtX25hbWVzcGFjZU9iamVjdCwgXCJTZWxlY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wb25lbnRzX3NlbGVjdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29tcG9uZW50c19mb3JtX25hbWVzcGFjZU9iamVjdCwgXCJDaGVja2JveFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBvbmVudHNfY2hlY2tib3g7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbXBvbmVudHNfZm9ybV9uYW1lc3BhY2VPYmplY3QsIFwiUmFkaW9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wb25lbnRzX3JhZGlvOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb21wb25lbnRzX2Zvcm1fbmFtZXNwYWNlT2JqZWN0LCBcIkhlbHBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBoZWxwOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb21wb25lbnRzX2Zvcm1fbmFtZXNwYWNlT2JqZWN0LCBcIklucHV0RmlsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlucHV0X2ZpbGVfSW5wdXRGaWxlOyB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9pbmRleC5zYXNzXG52YXIgc3JjXzAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZm9ybS9mb3JtLnNhc3NcbnZhciBmb3JtX2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwicmVhY3RcIlxudmFyIGV4dGVybmFsX3JlYWN0XyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZXh0ZXJuYWxfcmVhY3RfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcInByb3AtdHlwZXNcIlxudmFyIGV4dGVybmFsX3Byb3BfdHlwZXNfID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGV4dGVybmFsX3Byb3BfdHlwZXNfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzXG52YXIgbm9kZV9tb2R1bGVzX2NsYXNzbmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIGNsYXNzbmFtZXNfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obm9kZV9tb2R1bGVzX2NsYXNzbmFtZXMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tb2RpZmllcnMvaGVscGVycy5qc1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGhlbHBlcnMgPSAoe1xuICBwcm9wVHlwZXM6IHtcbiAgICBjbGVhcmZpeDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgICBwdWxsOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbdW5kZWZpbmVkLCAncmlnaHQnLCAnbGVmdCddKSxcbiAgICBtYXJnaW5sZXNzOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICAgIHBhZGRpbmdsZXNzOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICAgIG92ZXJsYXk6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gICAgY2xpcHBlZDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgICByYWRpdXNsZXNzOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICAgIHNoYWRvd2xlc3M6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gICAgdW5zZWxlY3RhYmxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICAgIGludmlzaWJsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgICBoaWRkZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbiAgfSxcbiAgZGVmYXVsdFByb3BzOiB7XG4gICAgY2xlYXJmaXg6IHVuZGVmaW5lZCxcbiAgICBwdWxsOiB1bmRlZmluZWQsXG4gICAgbWFyZ2lubGVzczogdW5kZWZpbmVkLFxuICAgIHBhZGRpbmdsZXNzOiB1bmRlZmluZWQsXG4gICAgb3ZlcmxheTogdW5kZWZpbmVkLFxuICAgIGNsaXBwZWQ6IHVuZGVmaW5lZCxcbiAgICByYWRpdXNsZXNzOiB1bmRlZmluZWQsXG4gICAgc2hhZG93bGVzczogdW5kZWZpbmVkLFxuICAgIHVuc2VsZWN0YWJsZTogdW5kZWZpbmVkLFxuICAgIGludmlzaWJsZTogdW5kZWZpbmVkLFxuICAgIGhpZGRlbjogdW5kZWZpbmVkXG4gIH0sXG4gIGNsYXNzbmFtZXM6IGZ1bmN0aW9uIGNsYXNzbmFtZXMocHJvcHMpIHtcbiAgICB2YXIgX2NsYXNzbmFtZXMyO1xuXG4gICAgcmV0dXJuIGNsYXNzbmFtZXNfZGVmYXVsdCgpKChfY2xhc3NuYW1lczIgPSB7XG4gICAgICAnaXMtY2xlYXJmaXgnOiBwcm9wcy5jbGVhcmZpeFxuICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lczIsIFwiaXMtcHVsbGVkLVwiLmNvbmNhdChwcm9wcy5wdWxsKSwgcHJvcHMucHVsbCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lczIsICdpcy1tYXJnaW5sZXNzJywgcHJvcHMubWFyZ2lubGVzcyksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lczIsICdpcy1wYWRkaW5nbGVzcycsIHByb3BzLnBhZGRpbmdsZXNzKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzMiwgJ2lzLW92ZXJsYXknLCBwcm9wcy5vdmVybGF5KSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzMiwgJ2lzLWNsaXBwZWQnLCBwcm9wcy5jbGlwcGVkKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzMiwgJ2lzLXJhZGl1c2xlc3MnLCBwcm9wcy5yYWRpdXNsZXNzKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzMiwgJ2lzLXNoYWRvd2xlc3MnLCBwcm9wcy5zaGFkb3dsZXNzKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzMiwgJ2lzLXVuc2VsZWN0YWJsZScsIHByb3BzLnVuc2VsZWN0YWJsZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lczIsICdpcy1pbnZpc2libGUnLCBwcm9wcy5pbnZpc2libGUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMyLCAnaXMtaGlkZGVuJywgcHJvcHMuaGlkZGVuKSwgX2NsYXNzbmFtZXMyKSk7XG4gIH0sXG4gIGNsZWFuOiBmdW5jdGlvbiBjbGVhbihfcmVmKSB7XG4gICAgdmFyIGhpZGRlbiA9IF9yZWYuaGlkZGVuLFxuICAgICAgICBjbGVhcmZpeCA9IF9yZWYuY2xlYXJmaXgsXG4gICAgICAgIHBhZGRpbmdsZXNzID0gX3JlZi5wYWRkaW5nbGVzcyxcbiAgICAgICAgcHVsbCA9IF9yZWYucHVsbCxcbiAgICAgICAgbWFyZ2lubGVzcyA9IF9yZWYubWFyZ2lubGVzcyxcbiAgICAgICAgb3ZlcmxheSA9IF9yZWYub3ZlcmxheSxcbiAgICAgICAgY2xpcHBlZCA9IF9yZWYuY2xpcHBlZCxcbiAgICAgICAgcmFkaXVzbGVzcyA9IF9yZWYucmFkaXVzbGVzcyxcbiAgICAgICAgc2hhZG93bGVzcyA9IF9yZWYuc2hhZG93bGVzcyxcbiAgICAgICAgdW5zZWxlY3RhYmxlID0gX3JlZi51bnNlbGVjdGFibGUsXG4gICAgICAgIGludmlzaWJsZSA9IF9yZWYuaW52aXNpYmxlLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJoaWRkZW5cIiwgXCJjbGVhcmZpeFwiLCBcInBhZGRpbmdsZXNzXCIsIFwicHVsbFwiLCBcIm1hcmdpbmxlc3NcIiwgXCJvdmVybGF5XCIsIFwiY2xpcHBlZFwiLCBcInJhZGl1c2xlc3NcIiwgXCJzaGFkb3dsZXNzXCIsIFwidW5zZWxlY3RhYmxlXCIsIFwiaW52aXNpYmxlXCJdKTtcblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tb2RpZmllcnMvcmVzcG9uc2l2ZXMuanNcbmZ1bmN0aW9uIHJlc3BvbnNpdmVzX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSByZXNwb25zaXZlc19vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcmVzcG9uc2l2ZXNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXNwb25zaXZlc19kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcmVzcG9uc2l2ZXNfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cblxudmFyIGRpc3BsYXlzID0gWydibG9jaycsICdmbGV4JywgJ2lubGluZScsICdpbmxpbmUtYmxvY2snLCAnaW5saW5lLWZsZXgnXTtcblxudmFyIGdldFNpemVDbGFzc0Zyb21Qcm9wID0gZnVuY3Rpb24gZ2V0U2l6ZUNsYXNzRnJvbVByb3Aoc2l6ZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNpemVzKS5yZWR1Y2UoZnVuY3Rpb24gKGNsYXNzZXMsIHNpemUpIHtcbiAgICB2YXIgX29iamVjdFNwcmVhZDI7XG5cbiAgICB2YXIgZGlzcGxheSA9IHNpemVzW3NpemVdLmRpc3BsYXkgfHwge307XG4gICAgdmFyIGhpZGUgPSBzaXplc1tzaXplXS5oaWRlIHx8IHt9O1xuICAgIHZhciB0ZXh0U2l6ZSA9IHNpemVzW3NpemVdLnRleHRTaXplIHx8IHt9O1xuICAgIHZhciB0ZXh0QWxpZ25tZW50ID0gc2l6ZXNbc2l6ZV0udGV4dEFsaWdubWVudCB8fCB7fTtcblxuICAgIHZhciBvYmogPSBfb2JqZWN0U3ByZWFkKHt9LCBjbGFzc2VzLCAoX29iamVjdFNwcmVhZDIgPSB7fSwgcmVzcG9uc2l2ZXNfZGVmaW5lUHJvcGVydHkoX29iamVjdFNwcmVhZDIsIFwiaXMtXCIuY29uY2F0KGRpc3BsYXkudmFsdWUsIFwiLVwiKS5jb25jYXQoc2l6ZSkuY29uY2F0KGRpc3BsYXkub25seSA/ICctb25seScgOiAnJyksIGRpc3BsYXkudmFsdWUpLCByZXNwb25zaXZlc19kZWZpbmVQcm9wZXJ0eShfb2JqZWN0U3ByZWFkMiwgXCJpcy1oaWRkZW4tXCIuY29uY2F0KHNpemUpLmNvbmNhdChoaWRlLm9ubHkgPyAnLW9ubHknIDogJycpLCBoaWRlLnZhbHVlKSwgcmVzcG9uc2l2ZXNfZGVmaW5lUHJvcGVydHkoX29iamVjdFNwcmVhZDIsIFwiaGFzLXRleHQtXCIuY29uY2F0KHRleHRBbGlnbm1lbnQudmFsdWUsIFwiLVwiKS5jb25jYXQoc2l6ZSkuY29uY2F0KHRleHRBbGlnbm1lbnQub25seSA/ICctb25seScgOiAnJyksIHRleHRBbGlnbm1lbnQudmFsdWUpLCByZXNwb25zaXZlc19kZWZpbmVQcm9wZXJ0eShfb2JqZWN0U3ByZWFkMiwgXCJpcy1zaXplLVwiLmNvbmNhdCh0ZXh0U2l6ZS52YWx1ZSwgXCItXCIpLmNvbmNhdChzaXplKSwgdGV4dFNpemUudmFsdWUgPiAwKSwgX29iamVjdFNwcmVhZDIpKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn07XG5cbnZhciBzaXplU2hhcGUgPSBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7XG4gIGRpc3BsYXk6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHtcbiAgICB2YWx1ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoZGlzcGxheXMpLFxuICAgIG9ubHk6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbiAgfSksXG4gIGhpZGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHtcbiAgICB2YWx1ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgICBvbmx5OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sXG4gIH0pLFxuICB0ZXh0U2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe1xuICAgIHZhbHVlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbMSwgMiwgMywgNCwgNSwgNl0pXG4gIH0pLFxuICB0ZXh0QWxpZ25tZW50OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7XG4gICAgdmFsdWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsnY2VudGVyZWQnLCAnanVzdGlmaWVkJywgJ2xlZnQnLCAncmlnaHQnXSksXG4gICAgb25seTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbFxuICB9KVxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciByZXNwb25zaXZlcyA9ICh7XG4gIHByb3BUeXBlczoge1xuICAgIHJlc3BvbnNpdmU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHtcbiAgICAgIG1vYmlsZTogc2l6ZVNoYXBlLFxuICAgICAgdGFibGV0OiBzaXplU2hhcGUsXG4gICAgICBkZXNrdG9wOiBzaXplU2hhcGUsXG4gICAgICB3aWRlc2NyZWVuOiBzaXplU2hhcGUsXG4gICAgICBmdWxsaGQ6IHNpemVTaGFwZSxcbiAgICAgIHRvdWNoOiBzaXplU2hhcGVcbiAgICB9KVxuICB9LFxuICBkZWZhdWx0UHJvcHM6IHtcbiAgICByZXNwb25zaXZlOiB1bmRlZmluZWRcbiAgfSxcbiAgY2xhc3NuYW1lczogZnVuY3Rpb24gY2xhc3NuYW1lcyhwcm9wcykge1xuICAgIHJldHVybiBjbGFzc25hbWVzX2RlZmF1bHQoKShfb2JqZWN0U3ByZWFkKHt9LCBnZXRTaXplQ2xhc3NGcm9tUHJvcChwcm9wcy5yZXNwb25zaXZlIHx8IHt9KSkpO1xuICB9LFxuICBjbGVhbjogZnVuY3Rpb24gY2xlYW4oX3JlZikge1xuICAgIHZhciByZXNwb25zaXZlID0gX3JlZi5yZXNwb25zaXZlLFxuICAgICAgICBoaWRlID0gX3JlZi5oaWRlLFxuICAgICAgICBwcm9wcyA9IHJlc3BvbnNpdmVzX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcInJlc3BvbnNpdmVcIiwgXCJoaWRlXCJdKTtcblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tb2RpZmllcnMvY29sb3JzLmpzXG5mdW5jdGlvbiBjb2xvcnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGNvbG9yc19vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29sb3JzX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb2xvcnNfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cbiAvLyBjb25zdCBjb2xvcnMgPSBbJ3doaXRlJywgJ2JsYWNrJywgJ2xpZ2h0JywgJ2RhcmsnLCAncHJpbWFyeScsICdpbmZvJywgJ2xpbmsnLCAnc3VjY2VzcycsICd3YXJuaW5nJywgJ2RhbmdlcicsICdibGFjay1iaXMnLCAnYmxhY2stdGVyJywgJ2dyZXktZGFya2VyJywgJ2dyZXktZGFyaycsICdncmV5JywgJ2dyZXktbGlnaHQnLCAnZ3JleS1saWdodGVyJywgJ3doaXRlLXRlcicsICd3aGl0ZS1iaXMnXTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29sb3JzID0gKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgdGV4dENvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gICAgY29sb3JWYXJpYW50OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ2xpZ2h0JywgJ2RhcmsnXSlcbiAgfSxcbiAgZGVmYXVsdFByb3BzOiB7XG4gICAgdGV4dENvbG9yOiB1bmRlZmluZWQsXG4gICAgYmFja2dyb3VuZENvbG9yOiB1bmRlZmluZWQsXG4gICAgY29sb3JWYXJpYW50OiB1bmRlZmluZWRcbiAgfSxcbiAgY2xhc3NuYW1lczogZnVuY3Rpb24gY2xhc3NuYW1lcyhwcm9wcykge1xuICAgIHZhciBfY2xhc3NuYW1lczI7XG5cbiAgICByZXR1cm4gY2xhc3NuYW1lc19kZWZhdWx0KCkoKF9jbGFzc25hbWVzMiA9IHt9LCBjb2xvcnNfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMyLCBcImhhcy10ZXh0LVwiLmNvbmNhdChwcm9wcy50ZXh0Q29sb3IpLCBwcm9wcy50ZXh0Q29sb3IpLCBjb2xvcnNfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMyLCBcImhhcy1iYWNrZ3JvdW5kLVwiLmNvbmNhdChwcm9wcy5iYWNrZ3JvdW5kQ29sb3IpLCBwcm9wcy5iYWNrZ3JvdW5kQ29sb3IpLCBjb2xvcnNfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMyLCBcImlzLVwiLmNvbmNhdChwcm9wcy5jb2xvclZhcmlhbnQpLCBwcm9wcy5jb2xvclZhcmlhbnQpLCBfY2xhc3NuYW1lczIpKTtcbiAgfSxcbiAgY2xlYW46IGZ1bmN0aW9uIGNsZWFuKF9yZWYpIHtcbiAgICB2YXIgdGV4dENvbG9yID0gX3JlZi50ZXh0Q29sb3IsXG4gICAgICAgIGJhY2tncm91bmRDb2xvciA9IF9yZWYuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBjb2xvclZhcmlhbnQgPSBfcmVmLmNvbG9yVmFyaWFudCxcbiAgICAgICAgcHJvcHMgPSBjb2xvcnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1widGV4dENvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIFwiY29sb3JWYXJpYW50XCJdKTtcblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tb2RpZmllcnMvdHlwb2dyYXBoeS5qc1xuZnVuY3Rpb24gdHlwb2dyYXBoeV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gdHlwb2dyYXBoeV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdHlwb2dyYXBoeV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdHlwb2dyYXBoeV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0eXBvZ3JhcGh5ID0gKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgdGV4dFNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsxLCAyLCAzLCA0LCA1LCA2XSksXG4gICAgdGV4dEFsaWdubWVudDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydjZW50ZXJlZCcsICdqdXN0aWZpZWQnLCAnbGVmdCcsICdyaWdodCddKSxcbiAgICB0ZXh0VHJhbnNmb3JtOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ2NhcGl0YWxpemVkJywgJ2xvd2VyY2FzZScsICd1cHBlcmNhc2UnXSksXG4gICAgdGV4dFdlaWdodDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydsaWdodCcsICdub3JtYWwnLCAnc2VtaWJvbGQnLCAnYm9sZCddKSxcbiAgICBpdGFsaWM6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbiAgfSxcbiAgZGVmYXVsdFByb3BzOiB7XG4gICAgdGV4dFNpemU6IHVuZGVmaW5lZCxcbiAgICB0ZXh0QWxpZ25tZW50OiB1bmRlZmluZWQsXG4gICAgdGV4dFRyYW5zZm9ybTogdW5kZWZpbmVkLFxuICAgIGl0YWxpYzogdW5kZWZpbmVkLFxuICAgIHRleHRXZWlnaHQ6IHVuZGVmaW5lZFxuICB9LFxuICBjbGFzc25hbWVzOiBmdW5jdGlvbiBjbGFzc25hbWVzKHByb3BzKSB7XG4gICAgdmFyIF9jbGFzc25hbWVzMjtcblxuICAgIHJldHVybiBjbGFzc25hbWVzX2RlZmF1bHQoKSgoX2NsYXNzbmFtZXMyID0ge30sIHR5cG9ncmFwaHlfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMyLCBcImhhcy10ZXh0LVwiLmNvbmNhdChwcm9wcy50ZXh0QWxpZ25tZW50KSwgcHJvcHMudGV4dEFsaWdubWVudCksIHR5cG9ncmFwaHlfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMyLCBcImhhcy10ZXh0LXdlaWdodC1cIi5jb25jYXQocHJvcHMudGV4dFdlaWdodCksIHByb3BzLnRleHRXZWlnaHQpLCB0eXBvZ3JhcGh5X2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzMiwgXCJpcy1zaXplLVwiLmNvbmNhdChwcm9wcy50ZXh0U2l6ZSksIHByb3BzLnRleHRTaXplKSwgdHlwb2dyYXBoeV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lczIsIFwiaXMtXCIuY29uY2F0KHByb3BzLnRleHRUcmFuc2Zvcm0pLCBwcm9wcy50ZXh0VHJhbnNmb3JtKSwgdHlwb2dyYXBoeV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lczIsICdpcy1pdGFsaWMnLCBwcm9wcy5pdGFsaWMpLCBfY2xhc3NuYW1lczIpKTtcbiAgfSxcbiAgY2xlYW46IGZ1bmN0aW9uIGNsZWFuKF9yZWYpIHtcbiAgICB2YXIgdGV4dFdlaWdodCA9IF9yZWYudGV4dFdlaWdodCxcbiAgICAgICAgdGV4dFRyYW5zZm9ybSA9IF9yZWYudGV4dFRyYW5zZm9ybSxcbiAgICAgICAgaXRhbGljID0gX3JlZi5pdGFsaWMsXG4gICAgICAgIHRleHRTaXplID0gX3JlZi50ZXh0U2l6ZSxcbiAgICAgICAgdGV4dEFsaWdubWVudCA9IF9yZWYudGV4dEFsaWdubWVudCxcbiAgICAgICAgcHJvcHMgPSB0eXBvZ3JhcGh5X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcInRleHRXZWlnaHRcIiwgXCJ0ZXh0VHJhbnNmb3JtXCIsIFwiaXRhbGljXCIsIFwidGV4dFNpemVcIiwgXCJ0ZXh0QWxpZ25tZW50XCJdKTtcblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tb2RpZmllcnMvaW5kZXguanNcbmZ1bmN0aW9uIG1vZGlmaWVyc19vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBtb2RpZmllcnNfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG1vZGlmaWVyc19vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IG1vZGlmaWVyc19kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBtb2RpZmllcnNfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG1vZGlmaWVyc19kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblxuXG5cblxuXG5cbnZhciBjb21wb3NlID0gZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gZm5zLnJlZHVjZShmdW5jdGlvbiAoYXJnLCBmbikge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSwgYXJncyk7XG4gIH07XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtb2RpZmllcnMgPSAoe1xuICBwcm9wVHlwZXM6IG1vZGlmaWVyc19vYmplY3RTcHJlYWQoe30sIGhlbHBlcnMucHJvcFR5cGVzLCB7fSwgcmVzcG9uc2l2ZXMucHJvcFR5cGVzLCB7fSwgY29sb3JzLnByb3BUeXBlcywge30sIHR5cG9ncmFwaHkucHJvcFR5cGVzKSxcbiAgZGVmYXVsdFByb3BzOiBtb2RpZmllcnNfb2JqZWN0U3ByZWFkKHt9LCBoZWxwZXJzLmRlZmF1bHRQcm9wcywge30sIHJlc3BvbnNpdmVzLmRlZmF1bHRQcm9wcywge30sIGNvbG9ycy5kZWZhdWx0UHJvcHMsIHt9LCB0eXBvZ3JhcGh5LmRlZmF1bHRQcm9wcyksXG4gIGNsYXNzbmFtZXM6IGZ1bmN0aW9uIGNsYXNzbmFtZXMocHJvcHMpIHtcbiAgICByZXR1cm4gY2xhc3NuYW1lc19kZWZhdWx0KCkoaGVscGVycy5jbGFzc25hbWVzKHByb3BzKSwgcmVzcG9uc2l2ZXMuY2xhc3NuYW1lcyhwcm9wcyksIGNvbG9ycy5jbGFzc25hbWVzKHByb3BzKSwgdHlwb2dyYXBoeS5jbGFzc25hbWVzKHByb3BzKSk7XG4gIH0sXG4gIGNsZWFuOiBmdW5jdGlvbiBjbGVhbihwcm9wcykge1xuICAgIHJldHVybiBjb21wb3NlKGhlbHBlcnMuY2xlYW4sIHJlc3BvbnNpdmVzLmNsZWFuLCBjb2xvcnMuY2xlYW4sIHR5cG9ncmFwaHkuY2xlYW4pKHByb3BzKTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tb2RpZmllcnMvcmVuZGVyLWFzLmpzXG5cbnZhciByZW5kZXJBc1NoYXBlID0gZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2ZUeXBlKFtleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsIGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmZ1bmMsIGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9iamVjdF0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcmVuZGVyX2FzID0gKHJlbmRlckFzU2hhcGUpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9lbGVtZW50L2VsZW1lbnQuanNcbmZ1bmN0aW9uIGVsZW1lbnRfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gZWxlbWVudF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgZWxlbWVudF9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGVsZW1lbnRfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgZWxlbWVudF9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZWxlbWVudF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGVsZW1lbnRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGVsZW1lbnRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGVsZW1lbnRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cbnZhciBlbGVtZW50X0VsZW1lbnQgPSBmdW5jdGlvbiBFbGVtZW50KF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcmVuZGVyQXMgPSBfcmVmLnJlbmRlckFzLFxuICAgICAgZG9tUmVmID0gX3JlZi5kb21SZWYsXG4gICAgICBhbGxQcm9wcyA9IGVsZW1lbnRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCIsIFwicmVuZGVyQXNcIiwgXCJkb21SZWZcIl0pO1xuXG4gIHZhciBSZW5kZXJBcyA9IHJlbmRlckFzO1xuICB2YXIgcHJvcHMgPSBtb2RpZmllcnMuY2xlYW4oYWxsUHJvcHMpO1xuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoUmVuZGVyQXMsIF9leHRlbmRzKHtcbiAgICByZWY6IGRvbVJlZixcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKGNsYXNzTmFtZSwgbW9kaWZpZXJzLmNsYXNzbmFtZXMoYWxsUHJvcHMpKSB8fCB1bmRlZmluZWRcbiAgfSwgcHJvcHMpKTtcbn07XG5cbmVsZW1lbnRfRWxlbWVudC5wcm9wVHlwZXMgPSBlbGVtZW50X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIERvbSBlbGVtZW50XG4gICAqL1xuICBkb21SZWY6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuZWxlbWVudF9FbGVtZW50LmRlZmF1bHRQcm9wcyA9IGVsZW1lbnRfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGRvbVJlZjogdW5kZWZpbmVkLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGVsZW1lbnRfZWxlbWVudCA9IChlbGVtZW50X0VsZW1lbnQpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9lbGVtZW50L2luZGV4LmpzXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfZWxlbWVudCA9IChlbGVtZW50X2VsZW1lbnQpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9mb3JtL2NvbXBvbmVudHMvZmllbGQvZmllbGQtbGFiZWwuanNcbmZ1bmN0aW9uIGZpZWxkX2xhYmVsX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGZpZWxkX2xhYmVsX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBmaWVsZF9sYWJlbF9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGZpZWxkX2xhYmVsX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGZpZWxkX2xhYmVsX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBmaWVsZF9sYWJlbF9leHRlbmRzKCkgeyBmaWVsZF9sYWJlbF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGZpZWxkX2xhYmVsX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBmaWVsZF9sYWJlbF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGZpZWxkX2xhYmVsX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBmaWVsZF9sYWJlbF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZmllbGRfbGFiZWxfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGZpZWxkX2xhYmVsX0ZpZWxkTGFiZWwgPSBmdW5jdGlvbiBGaWVsZExhYmVsKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHByb3BzID0gZmllbGRfbGFiZWxfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJzaXplXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBmaWVsZF9sYWJlbF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2ZpZWxkLWxhYmVsJywgY2xhc3NOYW1lLCBmaWVsZF9sYWJlbF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuZmllbGRfbGFiZWxfRmllbGRMYWJlbC5wcm9wVHlwZXMgPSBmaWVsZF9sYWJlbF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzLFxuICBzaXplOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ3NtYWxsJywgJ25vcm1hbCcsICdtZWRpdW0nLCAnbGFyZ2UnXSlcbn0pO1xuZmllbGRfbGFiZWxfRmllbGRMYWJlbC5kZWZhdWx0UHJvcHMgPSBmaWVsZF9sYWJlbF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2RpdicsXG4gIHNpemU6IHVuZGVmaW5lZFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmaWVsZF9sYWJlbCA9IChmaWVsZF9sYWJlbF9GaWVsZExhYmVsKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZm9ybS9jb21wb25lbnRzL2ZpZWxkL2ZpZWxkLWJvZHkuanNcbmZ1bmN0aW9uIGZpZWxkX2JvZHlfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gZmllbGRfYm9keV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgZmllbGRfYm9keV9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGZpZWxkX2JvZHlfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgZmllbGRfYm9keV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZmllbGRfYm9keV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGZpZWxkX2JvZHlfZXh0ZW5kcygpIHsgZmllbGRfYm9keV9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGZpZWxkX2JvZHlfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGZpZWxkX2JvZHlfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGZpZWxkX2JvZHlfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZpZWxkX2JvZHlfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGZpZWxkX2JvZHlfRmllbGRCb2R5ID0gZnVuY3Rpb24gRmllbGRCb2R5KF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcHJvcHMgPSBmaWVsZF9ib2R5X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBmaWVsZF9ib2R5X2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnZmllbGQtYm9keScsIGNsYXNzTmFtZSwge30pXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5maWVsZF9ib2R5X0ZpZWxkQm9keS5wcm9wVHlwZXMgPSBmaWVsZF9ib2R5X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuZmllbGRfYm9keV9GaWVsZEJvZHkuZGVmYXVsdFByb3BzID0gZmllbGRfYm9keV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZmllbGRfYm9keSA9IChmaWVsZF9ib2R5X0ZpZWxkQm9keSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2Zvcm0vY29tcG9uZW50cy9maWVsZC9maWVsZC5qc1xuZnVuY3Rpb24gZmllbGRfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gZmllbGRfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGZpZWxkX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZmllbGRfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgZmllbGRfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZpZWxkX2V4dGVuZHMoKSB7IGZpZWxkX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gZmllbGRfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGZpZWxkX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gZmllbGRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGZpZWxkX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBmaWVsZF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGZpZWxkX0ZpZWxkID0gZnVuY3Rpb24gRmllbGQoX3JlZikge1xuICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgbXVsdGlsaW5lID0gX3JlZi5tdWx0aWxpbmUsXG4gICAgICBob3Jpem9udGFsID0gX3JlZi5ob3Jpem9udGFsLFxuICAgICAga2luZCA9IF9yZWYua2luZCxcbiAgICAgIHByb3BzID0gZmllbGRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCIsIFwiYWxpZ25cIiwgXCJtdWx0aWxpbmVcIiwgXCJob3Jpem9udGFsXCIsIFwia2luZFwiXSk7XG5cbiAgdmFyIGsgPSBudWxsO1xuXG4gIGlmIChraW5kID09PSAnYWRkb25zJykge1xuICAgIGsgPSAnaGFzLWFkZG9ucyc7XG4gIH0gZWxzZSBpZiAoa2luZCA9PT0gJ2dyb3VwJykge1xuICAgIGsgPSAnaXMtZ3JvdXBlZCc7XG4gIH1cblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBmaWVsZF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2ZpZWxkJywgY2xhc3NOYW1lLCAoX2NsYXNzbmFtZXMgPSB7fSwgZmllbGRfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiXCIuY29uY2F0KGspLCBrKSwgZmllbGRfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiXCIuY29uY2F0KGssIFwiLVwiKS5jb25jYXQoYWxpZ24pLCBrICYmIGFsaWduKSwgZmllbGRfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiXCIuY29uY2F0KGssIFwiLW11bHRpbGluZVwiKSwgayA9PT0gJ2lzLWdyb3VwZWQnICYmIG11bHRpbGluZSksIGZpZWxkX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCAnaXMtaG9yaXpvbnRhbCcsIGhvcml6b250YWwpLCBfY2xhc3NuYW1lcykpXG4gIH0pKTtcbn07XG5cbmZpZWxkX0ZpZWxkLkxhYmVsID0gZmllbGRfbGFiZWw7XG5maWVsZF9GaWVsZC5Cb2R5ID0gZmllbGRfYm9keTtcbmZpZWxkX0ZpZWxkLnByb3BUeXBlcyA9IGZpZWxkX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXMsXG4gIGFsaWduOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ2NlbnRlcmVkJywgJ3JpZ2h0J10pLFxuICBraW5kOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ2FkZG9ucycsICdncm91cCddKSxcbiAgbXVsdGlsaW5lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBob3Jpem9udGFsOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sXG59KTtcbmZpZWxkX0ZpZWxkLmRlZmF1bHRQcm9wcyA9IGZpZWxkX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2JyxcbiAgYWxpZ246IHVuZGVmaW5lZCxcbiAga2luZDogdW5kZWZpbmVkLFxuICBtdWx0aWxpbmU6IHVuZGVmaW5lZCxcbiAgaG9yaXpvbnRhbDogdW5kZWZpbmVkXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGZpZWxkID0gKGZpZWxkX0ZpZWxkKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZm9ybS9jb21wb25lbnRzL2ZpZWxkL2luZGV4LmpzXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZm9ybS9jb21wb25lbnRzL2NvbnRyb2wuanNcbmZ1bmN0aW9uIGNvbnRyb2xfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gY29udHJvbF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgY29udHJvbF9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGNvbnRyb2xfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgY29udHJvbF9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29udHJvbF9leHRlbmRzKCkgeyBjb250cm9sX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gY29udHJvbF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gY29udHJvbF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGNvbnRyb2xfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGNvbnRyb2xfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbnRyb2xfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGNvbnRyb2xfQ29udHJvbCA9IGZ1bmN0aW9uIENvbnRyb2woX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBmdWxsd2lkdGggPSBfcmVmLmZ1bGx3aWR0aCxcbiAgICAgIGljb25MZWZ0ID0gX3JlZi5pY29uTGVmdCxcbiAgICAgIGljb25SaWdodCA9IF9yZWYuaWNvblJpZ2h0LFxuICAgICAgbG9hZGluZyA9IF9yZWYubG9hZGluZyxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICBwcm9wcyA9IGNvbnRyb2xfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJmdWxsd2lkdGhcIiwgXCJpY29uTGVmdFwiLCBcImljb25SaWdodFwiLCBcImxvYWRpbmdcIiwgXCJzaXplXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjb250cm9sX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnY29udHJvbCcsIGNsYXNzTmFtZSwgY29udHJvbF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAnaXMtZXhwYW5kZWQnOiBmdWxsd2lkdGgsXG4gICAgICAnaGFzLWljb25zLWxlZnQnOiBpY29uTGVmdCxcbiAgICAgICdoYXMtaWNvbnMtcmlnaHQnOiBpY29uUmlnaHQsXG4gICAgICAnaXMtbG9hZGluZyc6IGxvYWRpbmdcbiAgICB9LCBcImlzLVwiLmNvbmNhdChzaXplKSwgc2l6ZSkpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5jb250cm9sX0NvbnRyb2wucHJvcFR5cGVzID0gY29udHJvbF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzLFxuICBmdWxsd2lkdGg6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIGljb25MZWZ0OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBpY29uUmlnaHQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIGxvYWRpbmc6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJ10pXG59KTtcbmNvbnRyb2xfQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBjb250cm9sX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2JyxcbiAgZnVsbHdpZHRoOiB1bmRlZmluZWQsXG4gIGljb25MZWZ0OiB1bmRlZmluZWQsXG4gIGljb25SaWdodDogdW5kZWZpbmVkLFxuICBsb2FkaW5nOiB1bmRlZmluZWQsXG4gIHNpemU6IHVuZGVmaW5lZFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb250cm9sID0gKGNvbnRyb2xfQ29udHJvbCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb25zdGFudHMuanNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbnN0YW50cyA9ICh7XG4gIEJSRUFLUE9JTlRTOiB7XG4gICAgREVTS1RPUDogJ2Rlc2t0b3AnLFxuICAgIFRBQkxFVDogJ3RhYmxldCcsXG4gICAgTU9CSUxFOiAnbW9iaWxlJyxcbiAgICBXSURFU0NSRUVOOiAnd2lkZXNjcmVlbicsXG4gICAgRlVMTEhEOiAnZnVsbGhkJyxcbiAgICBUT1VDSDogJ3RvdWNoJ1xuICB9LFxuICBDT0xPUlM6IHtcbiAgICBQUklNQVJZOiAncHJpbWFyeScsXG4gICAgU1VDQ0VTUzogJ3N1Y2Nlc3MnLFxuICAgIElORk86ICdpbmZvJyxcbiAgICBXQVJOSU5HOiAnd2FybmluZycsXG4gICAgREFOR0VSOiAnZGFuZ2VyJyxcbiAgICBMSUdIVDogJ2xpZ2h0JyxcbiAgICBEQVJLOiAnZGFyaycsXG4gICAgV0hJVEU6ICd3aGl0ZScsXG4gICAgQkxBQ0s6ICdibGFjaycsXG4gICAgTElOSzogJ2xpbmsnXG4gIH0sXG4gIENPTE9SX1ZBUklBTlQ6IHtcbiAgICBsaWdodDogJ2xpZ2h0JyxcbiAgICBkYXJrOiAnZGFyaydcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2Zvcm0vY29tcG9uZW50cy9pbnB1dC5qc1xuZnVuY3Rpb24gaW5wdXRfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gaW5wdXRfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGlucHV0X293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgaW5wdXRfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgaW5wdXRfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGlucHV0X2V4dGVuZHMoKSB7IGlucHV0X2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gaW5wdXRfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGlucHV0X2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gaW5wdXRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGlucHV0X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBpbnB1dF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxudmFyIGlucHV0X2NvbG9ycyA9IFtudWxsXS5jb25jYXQoT2JqZWN0LmtleXMoY29uc3RhbnRzLkNPTE9SUykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGNvbnN0YW50cy5DT0xPUlNba2V5XTtcbn0pKTtcblxudmFyIGlucHV0X0lucHV0ID0gZnVuY3Rpb24gSW5wdXQoX3JlZikge1xuICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICBjb2xvciA9IF9yZWYuY29sb3IsXG4gICAgICByZWFkT25seSA9IF9yZWYucmVhZE9ubHksXG4gICAgICBpc1N0YXRpYyA9IF9yZWYuaXNTdGF0aWMsXG4gICAgICBkaXNhYmxlZCA9IF9yZWYuZGlzYWJsZWQsXG4gICAgICBwbGFjZWhvbGRlciA9IF9yZWYucGxhY2Vob2xkZXIsXG4gICAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgcHJvcHMgPSBpbnB1dF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIiwgXCJ0eXBlXCIsIFwic2l6ZVwiLCBcImNvbG9yXCIsIFwicmVhZE9ubHlcIiwgXCJpc1N0YXRpY1wiLCBcImRpc2FibGVkXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJ2YWx1ZVwiLCBcIm5hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGlucHV0X2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgcmVuZGVyQXM6IFwiaW5wdXRcIixcbiAgICBuYW1lOiBuYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICByZWFkT25seTogcmVhZE9ubHkgfHwgaXNTdGF0aWMsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2lucHV0JywgY2xhc3NOYW1lLCAoX2NsYXNzbmFtZXMgPSB7XG4gICAgICAnaXMtc3RhdGljJzogaXNTdGF0aWNcbiAgICB9LCBpbnB1dF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpLCBpbnB1dF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoY29sb3IpLCBjb2xvciksIF9jbGFzc25hbWVzKSlcbiAgfSkpO1xufTtcblxuaW5wdXRfSW5wdXQucHJvcFR5cGVzID0gaW5wdXRfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICB0eXBlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ3RleHQnLCAnZW1haWwnLCAndGVsJywgJ3Bhc3N3b3JkJywgJ251bWJlcicsICdzZWFyY2gnLCAnY29sb3InLCAnZGF0ZScsICd0aW1lJywgJ2RhdGV0aW1lLWxvY2FsJ10pLFxuICBzaXplOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddKSxcbiAgY29sb3I6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKGlucHV0X2NvbG9ycyksXG4gIHJlYWRPbmx5OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBpc1N0YXRpYzogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgZGlzYWJsZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHBsYWNlaG9sZGVyOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHZhbHVlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZlR5cGUoW2V4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZywgZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubnVtYmVyXSksXG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBmaWVsZCBDb21tb25seSB1c2VkIGZvciBbbXVsdGktaW5wdXQgaGFuZGxpbmddKGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9mb3Jtcy5odG1sI2hhbmRsaW5nLW11bHRpcGxlLWlucHV0cylcbiAgICovXG4gIG5hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZ1xufSk7XG5pbnB1dF9JbnB1dC5kZWZhdWx0UHJvcHMgPSBpbnB1dF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHZhbHVlOiAnJyxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgdHlwZTogJ3RleHQnLFxuICBzaXplOiB1bmRlZmluZWQsXG4gIGNvbG9yOiB1bmRlZmluZWQsXG4gIHJlYWRPbmx5OiBmYWxzZSxcbiAgaXNTdGF0aWM6IGZhbHNlLFxuICBkaXNhYmxlZDogZmFsc2UsXG4gIHBsYWNlaG9sZGVyOiAnJyxcbiAgbmFtZTogdW5kZWZpbmVkXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGlucHV0ID0gKGlucHV0X0lucHV0KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZm9ybS9jb21wb25lbnRzL2xhYmVsLmpzXG5mdW5jdGlvbiBsYWJlbF9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBsYWJlbF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbGFiZWxfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBsYWJlbF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBsYWJlbF9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbGFiZWxfZXh0ZW5kcygpIHsgbGFiZWxfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBsYWJlbF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gbGFiZWxfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBsYWJlbF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gbGFiZWxfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGxhYmVsX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgbGFiZWxfTGFiZWwgPSBmdW5jdGlvbiBMYWJlbChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICBwcm9wcyA9IGxhYmVsX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwic2l6ZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgbGFiZWxfZXh0ZW5kcyh7XG4gICAgcmVuZGVyQXM6IFwibGFiZWxcIlxuICB9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2xhYmVsJywgY2xhc3NOYW1lLCBsYWJlbF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxubGFiZWxfTGFiZWwucHJvcFR5cGVzID0gbGFiZWxfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgaHRtbEZvcjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzaXplOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddKVxufSk7XG5sYWJlbF9MYWJlbC5kZWZhdWx0UHJvcHMgPSBsYWJlbF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICBzaXplOiB1bmRlZmluZWQsXG4gIGh0bWxGb3I6IHVuZGVmaW5lZFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2xhYmVsID0gKGxhYmVsX0xhYmVsKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZm9ybS9jb21wb25lbnRzL3RleHRhcmVhLmpzXG5mdW5jdGlvbiB0ZXh0YXJlYV9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiB0ZXh0YXJlYV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgdGV4dGFyZWFfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyB0ZXh0YXJlYV9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyB0ZXh0YXJlYV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdGV4dGFyZWFfZXh0ZW5kcygpIHsgdGV4dGFyZWFfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiB0ZXh0YXJlYV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gdGV4dGFyZWFfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiB0ZXh0YXJlYV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gdGV4dGFyZWFfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIHRleHRhcmVhX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgdGV4dGFyZWFfY29sb3JzID0gW251bGxdLmNvbmNhdChPYmplY3Qua2V5cyhjb25zdGFudHMuQ09MT1JTKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gY29uc3RhbnRzLkNPTE9SU1trZXldO1xufSkpO1xuXG52YXIgdGV4dGFyZWFfVGV4dGFyZWEgPSBmdW5jdGlvbiBUZXh0YXJlYShfcmVmKSB7XG4gIHZhciBfY2xhc3NuYW1lcztcblxuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgcmVhZE9ubHkgPSBfcmVmLnJlYWRPbmx5LFxuICAgICAgZGlzYWJsZWQgPSBfcmVmLmRpc2FibGVkLFxuICAgICAgcGxhY2Vob2xkZXIgPSBfcmVmLnBsYWNlaG9sZGVyLFxuICAgICAgcm93cyA9IF9yZWYucm93cyxcbiAgICAgIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBwcm9wcyA9IHRleHRhcmVhX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNsYXNzTmFtZVwiLCBcInNpemVcIiwgXCJjb2xvclwiLCBcInJlYWRPbmx5XCIsIFwiZGlzYWJsZWRcIiwgXCJwbGFjZWhvbGRlclwiLCBcInJvd3NcIiwgXCJ2YWx1ZVwiLCBcIm5hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIHRleHRhcmVhX2V4dGVuZHMoe1xuICAgIHJlbmRlckFzOiBcInRleHRhcmVhXCIsXG4gICAgbmFtZTogbmFtZVxuICB9LCBwcm9wcywge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICByb3dzOiByb3dzLFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICByZWFkT25seTogcmVhZE9ubHksXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ3RleHRhcmVhJywgY2xhc3NOYW1lLCAoX2NsYXNzbmFtZXMgPSB7fSwgdGV4dGFyZWFfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KHNpemUpLCBzaXplKSwgdGV4dGFyZWFfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KGNvbG9yKSwgY29sb3IpLCBfY2xhc3NuYW1lcykpXG4gIH0pKTtcbn07XG5cbnRleHRhcmVhX1RleHRhcmVhLnByb3BUeXBlcyA9IHRleHRhcmVhX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXSksXG4gIGNvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZih0ZXh0YXJlYV9jb2xvcnMpLFxuICByZWFkT25seTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgZGlzYWJsZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHBsYWNlaG9sZGVyOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHJvd3M6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm51bWJlcixcbiAgdmFsdWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGlucHV0IGZpZWxkIENvbW1vbmx5IHVzZWQgZm9yIFttdWx0aS1pbnB1dCBoYW5kbGluZ10oaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Zvcm1zLmh0bWwjaGFuZGxpbmctbXVsdGlwbGUtaW5wdXRzKVxuICAgKi9cbiAgbmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nXG59KTtcbnRleHRhcmVhX1RleHRhcmVhLmRlZmF1bHRQcm9wcyA9IHRleHRhcmVhX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgc2l6ZTogdW5kZWZpbmVkLFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICByZWFkT25seTogZmFsc2UsXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgcGxhY2Vob2xkZXI6ICcnLFxuICByb3dzOiA0LFxuICB2YWx1ZTogJycsXG4gIG5hbWU6ICcnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfdGV4dGFyZWEgPSAodGV4dGFyZWFfVGV4dGFyZWEpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9mb3JtL2NvbXBvbmVudHMvc2VsZWN0LmpzXG5mdW5jdGlvbiBzZWxlY3Rfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gc2VsZWN0X29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBzZWxlY3Rfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBzZWxlY3RfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgc2VsZWN0X293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBzZWxlY3RfZXh0ZW5kcygpIHsgc2VsZWN0X2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gc2VsZWN0X2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBzZWxlY3RfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBzZWxlY3Rfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHNlbGVjdF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gc2VsZWN0X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgc2VsZWN0X2NvbG9ycyA9IFtudWxsXS5jb25jYXQoT2JqZWN0LmtleXMoY29uc3RhbnRzLkNPTE9SUykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGNvbnN0YW50cy5DT0xPUlNba2V5XTtcbn0pKTtcblxudmFyIHNlbGVjdF9TZWxlY3QgPSBmdW5jdGlvbiBTZWxlY3QoX3JlZikge1xuICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgIGxvYWRpbmcgPSBfcmVmLmxvYWRpbmcsXG4gICAgICByZWFkT25seSA9IF9yZWYucmVhZE9ubHksXG4gICAgICBkaXNhYmxlZCA9IF9yZWYuZGlzYWJsZWQsXG4gICAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICBtdWx0aXBsZSA9IF9yZWYubXVsdGlwbGUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgZG9tUmVmID0gX3JlZi5kb21SZWYsXG4gICAgICBwcm9wcyA9IHNlbGVjdF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcInNpemVcIiwgXCJjb2xvclwiLCBcImxvYWRpbmdcIiwgXCJyZWFkT25seVwiLCBcImRpc2FibGVkXCIsIFwidmFsdWVcIiwgXCJtdWx0aXBsZVwiLCBcImNoaWxkcmVuXCIsIFwibmFtZVwiLCBcImRvbVJlZlwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwge1xuICAgIGRvbVJlZjogZG9tUmVmLFxuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ3NlbGVjdCcsIGNsYXNzTmFtZSwgKF9jbGFzc25hbWVzID0ge30sIHNlbGVjdF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpLCBzZWxlY3RfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KGNvbG9yKSwgY29sb3IpLCBzZWxlY3RfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy1sb2FkaW5nJywgbG9hZGluZyksIHNlbGVjdF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2lzLW11bHRpcGxlJywgbXVsdGlwbGUpLCBfY2xhc3NuYW1lcykpLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIHNlbGVjdF9leHRlbmRzKHtcbiAgICByZW5kZXJBczogXCJzZWxlY3RcIlxuICB9LCBwcm9wcywge1xuICAgIG11bHRpcGxlOiBtdWx0aXBsZSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcmVhZE9ubHk6IHJlYWRPbmx5LFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBuYW1lOiBuYW1lXG4gIH0pLCBjaGlsZHJlbikpO1xufTtcblxuc2VsZWN0X1NlbGVjdC5wcm9wVHlwZXMgPSBzZWxlY3Rfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXSksXG4gIGNvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihzZWxlY3RfY29sb3JzKSxcbiAgcmVhZE9ubHk6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIGRpc2FibGVkOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBtdWx0aXBsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgbG9hZGluZzogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgdmFsdWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mVHlwZShbZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLCBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5udW1iZXJdKSxcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGlucHV0IGZpZWxkIENvbW1vbmx5IHVzZWQgZm9yIFttdWx0aS1pbnB1dCBoYW5kbGluZ10oaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Zvcm1zLmh0bWwjaGFuZGxpbmctbXVsdGlwbGUtaW5wdXRzKVxuICAgKi9cbiAgbmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nXG59KTtcbnNlbGVjdF9TZWxlY3QuZGVmYXVsdFByb3BzID0gc2VsZWN0X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHZhbHVlOiAnJyxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgc2l6ZTogdW5kZWZpbmVkLFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICByZWFkT25seTogZmFsc2UsXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgbXVsdGlwbGU6IGZhbHNlLFxuICBsb2FkaW5nOiBmYWxzZSxcbiAgbmFtZTogdW5kZWZpbmVkXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfc2VsZWN0ID0gKHNlbGVjdF9TZWxlY3QpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9mb3JtL2NvbXBvbmVudHMvY2hlY2tib3guanNcbmZ1bmN0aW9uIGNoZWNrYm94X293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGNoZWNrYm94X29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBjaGVja2JveF9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGNoZWNrYm94X2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGNoZWNrYm94X293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjaGVja2JveF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGNoZWNrYm94X2V4dGVuZHMoKSB7IGNoZWNrYm94X2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gY2hlY2tib3hfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGNoZWNrYm94X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBjaGVja2JveF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY2hlY2tib3hfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cbnZhciBjaGVja2JveF9DaGVja2JveCA9IGZ1bmN0aW9uIENoZWNrYm94KF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgZGlzYWJsZWQgPSBfcmVmLmRpc2FibGVkLFxuICAgICAgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2hlY2tlZCA9IF9yZWYuY2hlY2tlZCxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBkb21SZWYgPSBfcmVmLmRvbVJlZixcbiAgICAgIHByb3BzID0gY2hlY2tib3hfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCIsIFwic3R5bGVcIiwgXCJkaXNhYmxlZFwiLCBcInZhbHVlXCIsIFwiY2hpbGRyZW5cIiwgXCJjaGVja2VkXCIsIFwibmFtZVwiLCBcImRvbVJlZlwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwge1xuICAgIHJlbmRlckFzOiBcImxhYmVsXCIsXG4gICAgZG9tUmVmOiBkb21SZWYsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2NoZWNrYm94JywgY2xhc3NOYW1lKSxcbiAgICBzdHlsZTogc3R5bGVcbiAgfSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjaGVja2JveF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlbmRlckFzOiBcImlucHV0XCIsXG4gICAgbmFtZTogbmFtZSxcbiAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBjaGVja2VkOiBjaGVja2VkXG4gIH0pKSwgY2hpbGRyZW4pO1xufTtcblxuY2hlY2tib3hfQ2hlY2tib3gucHJvcFR5cGVzID0gY2hlY2tib3hfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgZGlzYWJsZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHZhbHVlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIGNoZWNrZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBmaWVsZCBDb21tb25seSB1c2VkIGZvciBbbXVsdGktaW5wdXQgaGFuZGxpbmddKGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9mb3Jtcy5odG1sI2hhbmRsaW5nLW11bHRpcGxlLWlucHV0cylcbiAgICovXG4gIG5hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZ1xufSk7XG5jaGVja2JveF9DaGVja2JveC5kZWZhdWx0UHJvcHMgPSBjaGVja2JveF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICB2YWx1ZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICBkaXNhYmxlZDogdW5kZWZpbmVkLFxuICBjaGVja2VkOiB1bmRlZmluZWQsXG4gIG5hbWU6IHVuZGVmaW5lZFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2NoZWNrYm94ID0gKGNoZWNrYm94X0NoZWNrYm94KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZm9ybS9jb21wb25lbnRzL3JhZGlvLmpzXG5mdW5jdGlvbiByYWRpb19vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiByYWRpb19vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgcmFkaW9fb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByYWRpb19kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyByYWRpb19vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcmFkaW9fZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiByYWRpb19leHRlbmRzKCkgeyByYWRpb19leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIHJhZGlvX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiByYWRpb19vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gcmFkaW9fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIHJhZGlvX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgcmFkaW9fUmFkaW8gPSBmdW5jdGlvbiBSYWRpbyhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIGRpc2FibGVkID0gX3JlZi5kaXNhYmxlZCxcbiAgICAgIGNoZWNrZWQgPSBfcmVmLmNoZWNrZWQsXG4gICAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgZG9tUmVmID0gX3JlZi5kb21SZWYsXG4gICAgICBwcm9wcyA9IHJhZGlvX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwiZGlzYWJsZWRcIiwgXCJjaGVja2VkXCIsIFwidmFsdWVcIiwgXCJuYW1lXCIsIFwiY2hpbGRyZW5cIiwgXCJkb21SZWZcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIHtcbiAgICByZW5kZXJBczogXCJsYWJlbFwiLFxuICAgIGRvbVJlZjogZG9tUmVmLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdyYWRpbycsIGNsYXNzTmFtZSksXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgcmFkaW9fZXh0ZW5kcyh7XG4gICAgcmVuZGVyQXM6IFwiaW5wdXRcIlxuICB9LCBwcm9wcywge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgY2hlY2tlZDogY2hlY2tlZCxcbiAgICB0eXBlOiBcInJhZGlvXCIsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICB9KSksIGNoaWxkcmVuKTtcbn07XG5cbnJhZGlvX1JhZGlvLnByb3BUeXBlcyA9IHJhZGlvX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBmaWVsZCBDb21tb25seSB1c2VkIGZvciBbbXVsdGktaW5wdXQgaGFuZGxpbmddKGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9mb3Jtcy5odG1sI2hhbmRsaW5nLW11bHRpcGxlLWlucHV0cylcbiAgICovXG4gIG5hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZy5pc1JlcXVpcmVkLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICBkaXNhYmxlZDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgY2hlY2tlZDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgdmFsdWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZ1xufSk7XG5yYWRpb19SYWRpby5kZWZhdWx0UHJvcHMgPSByYWRpb19vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICB2YWx1ZTogJycsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgY2hlY2tlZDogZmFsc2Vcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19yYWRpbyA9IChyYWRpb19SYWRpbyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2Zvcm0vY29tcG9uZW50cy9oZWxwLmpzXG5mdW5jdGlvbiBoZWxwX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGhlbHBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGhlbHBfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBoZWxwX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGhlbHBfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGhlbHBfZXh0ZW5kcygpIHsgaGVscF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGhlbHBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGhlbHBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBoZWxwX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBoZWxwX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBoZWxwX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgaGVscF9jb2xvcnMgPSBbbnVsbF0uY29uY2F0KE9iamVjdC5rZXlzKGNvbnN0YW50cy5DT0xPUlMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBjb25zdGFudHMuQ09MT1JTW2tleV07XG59KSk7XG5cbnZhciBoZWxwX0hlbHAgPSBmdW5jdGlvbiBIZWxwKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgcHJvcHMgPSBoZWxwX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCIsIFwiY29sb3JcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGhlbHBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdoZWxwJywgY2xhc3NOYW1lLCBoZWxwX2RlZmluZVByb3BlcnR5KHt9LCBcImlzLVwiLmNvbmNhdChjb2xvciksIGNvbG9yKSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbmhlbHBfSGVscC5wcm9wVHlwZXMgPSBoZWxwX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgY29sb3I6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKGhlbHBfY29sb3JzKSxcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGVcbn0pO1xuaGVscF9IZWxwLmRlZmF1bHRQcm9wcyA9IGhlbHBfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgY29sb3I6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdwJ1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBoZWxwID0gKGhlbHBfSGVscCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2Zvcm0vY29tcG9uZW50cy9pbnB1dC1maWxlLmpzXG5mdW5jdGlvbiBpbnB1dF9maWxlX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGlucHV0X2ZpbGVfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGlucHV0X2ZpbGVfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBpbnB1dF9maWxlX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGlucHV0X2ZpbGVfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGlucHV0X2ZpbGVfZXh0ZW5kcygpIHsgaW5wdXRfZmlsZV9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGlucHV0X2ZpbGVfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGlucHV0X2ZpbGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGlucHV0X2ZpbGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGlucHV0X2ZpbGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBpbnB1dF9maWxlX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuXG5cblxuXG5cblxudmFyIGlucHV0X2ZpbGVfY29sb3JzID0gW251bGxdLmNvbmNhdChPYmplY3Qua2V5cyhjb25zdGFudHMuQ09MT1JTKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gY29uc3RhbnRzLkNPTE9SU1trZXldO1xufSkpO1xuXG52YXIgaW5wdXRfZmlsZV9JbnB1dEZpbGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhJbnB1dEZpbGUsIF9QdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBJbnB1dEZpbGUocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5wdXRGaWxlKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKElucHV0RmlsZSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgaW5wdXRfZmlsZV9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZWxlY3RcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgZmlsZXMgPSBldmVudC50YXJnZXQuZmlsZXM7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZmlsZW5hbWU6IGZpbGVzLmxlbmd0aCA+IDAgPyBmaWxlc1swXS5uYW1lIDogdW5kZWZpbmVkXG4gICAgICB9KTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgZmlsZW5hbWU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElucHV0RmlsZSwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgc3R5bGUgPSBfdGhpcyRwcm9wcy5zdHlsZSxcbiAgICAgICAgICBvbkNoYW5nZSA9IF90aGlzJHByb3BzLm9uQ2hhbmdlLFxuICAgICAgICAgIGNvbG9yID0gX3RoaXMkcHJvcHMuY29sb3IsXG4gICAgICAgICAgc2l6ZSA9IF90aGlzJHByb3BzLnNpemUsXG4gICAgICAgICAgZmlsZU5hbWUgPSBfdGhpcyRwcm9wcy5maWxlTmFtZSxcbiAgICAgICAgICBmdWxsd2lkdGggPSBfdGhpcyRwcm9wcy5mdWxsd2lkdGgsXG4gICAgICAgICAgcmlnaHQgPSBfdGhpcyRwcm9wcy5yaWdodCxcbiAgICAgICAgICBib3hlZCA9IF90aGlzJHByb3BzLmJveGVkLFxuICAgICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wcy5uYW1lLFxuICAgICAgICAgIGxhYmVsID0gX3RoaXMkcHJvcHMubGFiZWwsXG4gICAgICAgICAgaWNvbiA9IF90aGlzJHByb3BzLmljb24sXG4gICAgICAgICAgaW5wdXRQcm9wcyA9IF90aGlzJHByb3BzLmlucHV0UHJvcHMsXG4gICAgICAgICAgcHJvcHMgPSBpbnB1dF9maWxlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcIm9uQ2hhbmdlXCIsIFwiY29sb3JcIiwgXCJzaXplXCIsIFwiZmlsZU5hbWVcIiwgXCJmdWxsd2lkdGhcIiwgXCJyaWdodFwiLCBcImJveGVkXCIsIFwibmFtZVwiLCBcImxhYmVsXCIsIFwiaWNvblwiLCBcImlucHV0UHJvcHNcIl0pO1xuXG4gICAgICB2YXIgZmlsZW5hbWUgPSB0aGlzLnN0YXRlLmZpbGVuYW1lO1xuICAgICAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgaW5wdXRfZmlsZV9leHRlbmRzKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICB9LCBwcm9wcywge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdmaWxlJywgY2xhc3NOYW1lLCAoX2NsYXNzbmFtZXMgPSB7fSwgaW5wdXRfZmlsZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpLCBpbnB1dF9maWxlX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImlzLVwiLmNvbmNhdChjb2xvciksIGNvbG9yKSwgaW5wdXRfZmlsZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2hhcy1uYW1lJywgIWZpbGVOYW1lKSwgaW5wdXRfZmlsZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2lzLXJpZ2h0JywgcmlnaHQpLCBpbnB1dF9maWxlX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCAnaXMtYm94ZWQnLCBib3hlZCksIGlucHV0X2ZpbGVfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy1mdWxsd2lkdGgnLCBmdWxsd2lkdGgpLCBfY2xhc3NuYW1lcykpXG4gICAgICB9KSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJmaWxlLWxhYmVsXCJcbiAgICAgIH0sIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgaW5wdXRfZmlsZV9leHRlbmRzKHt9LCBpbnB1dFByb3BzLCB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiZmlsZS1pbnB1dFwiLFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5zZWxlY3RcbiAgICAgIH0pKSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImZpbGUtY3RhXCJcbiAgICAgIH0sIGljb24gJiYgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImZpbGUtaWNvblwiXG4gICAgICB9LCBpY29uKSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImZpbGUtbGFiZWxcIlxuICAgICAgfSwgbGFiZWwpKSwgZmlsZU5hbWUgJiYgZmlsZW5hbWUgJiYgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImZpbGUtbmFtZVwiXG4gICAgICB9LCBmaWxlbmFtZSkpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5wdXRGaWxlO1xufShleHRlcm5hbF9yZWFjdF9bXCJQdXJlQ29tcG9uZW50XCJdKTtcblxuXG5pbnB1dF9maWxlX0lucHV0RmlsZS5wcm9wVHlwZXMgPSBpbnB1dF9maWxlX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgb25DaGFuZ2U6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmZ1bmMsXG4gIGNvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihpbnB1dF9maWxlX2NvbG9ycyksXG4gIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJ10pLFxuICBmaWxlTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgZnVsbHdpZHRoOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICByaWdodDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgYm94ZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBmaWVsZCBDb21tb25seSB1c2VkIGZvciBbbXVsdGktaW5wdXQgaGFuZGxpbmddKGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9mb3Jtcy5odG1sI2hhbmRsaW5nLW11bHRpcGxlLWlucHV0cylcbiAgICovXG4gIG5hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgbGFiZWw6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgaWNvbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuZWxlbWVudCxcbiAgaW5wdXRQcm9wczogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe1xuICAgIGFjY2VwdDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICAgIGNhcHR1cmU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgICBtdWx0aXBsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbFxuICB9KVxufSk7XG5pbnB1dF9maWxlX0lucHV0RmlsZS5kZWZhdWx0UHJvcHMgPSBpbnB1dF9maWxlX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge30sXG4gIGNvbG9yOiB1bmRlZmluZWQsXG4gIHNpemU6IHVuZGVmaW5lZCxcbiAgZmlsZU5hbWU6IHRydWUsXG4gIGZ1bGx3aWR0aDogdW5kZWZpbmVkLFxuICByaWdodDogdW5kZWZpbmVkLFxuICBib3hlZDogdW5kZWZpbmVkLFxuICBuYW1lOiB1bmRlZmluZWQsXG4gIGljb246IHVuZGVmaW5lZCxcbiAgbGFiZWw6ICdDaG9vc2UgYSBmaWxlLi4uJyxcbiAgaW5wdXRQcm9wczoge1xuICAgIGFjY2VwdDogdW5kZWZpbmVkLFxuICAgIGNhcHR1cmU6IHVuZGVmaW5lZCxcbiAgICBtdWx0aXBsZTogdW5kZWZpbmVkXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9mb3JtL2luZGV4LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9ib3gvYm94LmpzXG5mdW5jdGlvbiBib3hfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gYm94X29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBib3hfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBib3hfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgYm94X293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBib3hfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBib3hfZXh0ZW5kcygpIHsgYm94X2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gYm94X2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBib3hfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGJveF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gYm94X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBib3hfQm94ID0gZnVuY3Rpb24gQm94KF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcHJvcHMgPSBib3hfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGJveF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2JveCcsIGNsYXNzTmFtZSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbmJveF9Cb3gucHJvcFR5cGVzID0gYm94X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuYm94X0JveC5kZWZhdWx0UHJvcHMgPSBib3hfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJveCA9IChib3hfQm94KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9ib3gvYm94LnNhc3NcbnZhciBib3hfYm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9ib3gvaW5kZXguanNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2JveCA9IChib3gpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2J1dHRvbi9idXR0b24uc2Fzc1xudmFyIGJ1dHRvbl9idXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2J1dHRvbi9jb21wb25lbnRzL2J1dHRvbi1ncm91cC5qc1xuZnVuY3Rpb24gYnV0dG9uX2dyb3VwX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGJ1dHRvbl9ncm91cF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgYnV0dG9uX2dyb3VwX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgYnV0dG9uX2dyb3VwX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGJ1dHRvbl9ncm91cF9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gYnV0dG9uX2dyb3VwX2V4dGVuZHMoKSB7IGJ1dHRvbl9ncm91cF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGJ1dHRvbl9ncm91cF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gYnV0dG9uX2dyb3VwX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gYnV0dG9uX2dyb3VwX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBidXR0b25fZ3JvdXBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGJ1dHRvbl9ncm91cF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgYnV0dG9uX2dyb3VwX0J1dHRvbkdyb3VwID0gZnVuY3Rpb24gQnV0dG9uR3JvdXAoX3JlZikge1xuICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgaGFzQWRkb25zID0gX3JlZi5oYXNBZGRvbnMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYucG9zaXRpb24sXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgcHJvcHMgPSBidXR0b25fZ3JvdXBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJoYXNBZGRvbnNcIiwgXCJwb3NpdGlvblwiLCBcInNpemVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGJ1dHRvbl9ncm91cF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2J1dHRvbnMnLCBjbGFzc05hbWUsIChfY2xhc3NuYW1lcyA9IHtcbiAgICAgICdoYXMtYWRkb25zJzogaGFzQWRkb25zXG4gICAgfSwgYnV0dG9uX2dyb3VwX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImlzLVwiLmNvbmNhdChbcG9zaXRpb25dKSwgcG9zaXRpb24pLCBidXR0b25fZ3JvdXBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiYXJlLVwiLmNvbmNhdChzaXplKSwgc2l6ZSksIF9jbGFzc25hbWVzKSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbmJ1dHRvbl9ncm91cF9CdXR0b25Hcm91cC5wcm9wVHlwZXMgPSBidXR0b25fZ3JvdXBfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBoYXNBZGRvbnM6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgcG9zaXRpb246IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsnY2VudGVyZWQnLCAncmlnaHQnXSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuYnV0dG9uX2dyb3VwX0J1dHRvbkdyb3VwLmRlZmF1bHRQcm9wcyA9IGJ1dHRvbl9ncm91cF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIGhhc0FkZG9uczogdW5kZWZpbmVkLFxuICBwb3NpdGlvbjogdW5kZWZpbmVkLFxuICBzaXplOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2J1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBidXR0b25fZ3JvdXAgPSAoYnV0dG9uX2dyb3VwX0J1dHRvbkdyb3VwKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi5qc1xuZnVuY3Rpb24gYnV0dG9uX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGJ1dHRvbl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgYnV0dG9uX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgYnV0dG9uX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGJ1dHRvbl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gYnV0dG9uX2V4dGVuZHMoKSB7IGJ1dHRvbl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGJ1dHRvbl9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gYnV0dG9uX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gYnV0dG9uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBidXR0b25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGJ1dHRvbl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG5cbnZhciBidXR0b25fY29sb3JzID0gW251bGwsICcnXS5jb25jYXQoT2JqZWN0LmtleXMoY29uc3RhbnRzLkNPTE9SUykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGNvbnN0YW50cy5DT0xPUlNba2V5XTtcbn0pKTtcblxudmFyIGJ1dHRvbl9CdXR0b24gPSBmdW5jdGlvbiBCdXR0b24oX3JlZikge1xuICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcmVuZGVyQXMgPSBfcmVmLnJlbmRlckFzLFxuICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIG91dGxpbmVkID0gX3JlZi5vdXRsaW5lZCxcbiAgICAgIGludmVydGVkID0gX3JlZi5pbnZlcnRlZCxcbiAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIHN1Ym1pdCA9IF9yZWYuc3VibWl0LFxuICAgICAgcmVzZXQgPSBfcmVmLnJlc2V0LFxuICAgICAgZnVsbHdpZHRoID0gX3JlZi5mdWxsd2lkdGgsXG4gICAgICBsb2FkaW5nID0gX3JlZi5sb2FkaW5nLFxuICAgICAgZGlzYWJsZWQgPSBfcmVmLmRpc2FibGVkLFxuICAgICAgcmVtb3ZlID0gX3JlZi5yZW1vdmUsXG4gICAgICBpc1NlbGVjdGVkID0gX3JlZi5pc1NlbGVjdGVkLFxuICAgICAgaXNTdGF0aWMgPSBfcmVmLmlzU3RhdGljLFxuICAgICAgcm91bmRlZCA9IF9yZWYucm91bmRlZCxcbiAgICAgIG9uQ2xpY2sgPSBfcmVmLm9uQ2xpY2ssXG4gICAgICB0ZXh0ID0gX3JlZi50ZXh0LFxuICAgICAgcHJvcHMgPSBidXR0b25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJyZW5kZXJBc1wiLCBcImNvbG9yXCIsIFwic2l6ZVwiLCBcIm91dGxpbmVkXCIsIFwiaW52ZXJ0ZWRcIiwgXCJzdGF0ZVwiLCBcInN1Ym1pdFwiLCBcInJlc2V0XCIsIFwiZnVsbHdpZHRoXCIsIFwibG9hZGluZ1wiLCBcImRpc2FibGVkXCIsIFwicmVtb3ZlXCIsIFwiaXNTZWxlY3RlZFwiLCBcImlzU3RhdGljXCIsIFwicm91bmRlZFwiLCBcIm9uQ2xpY2tcIiwgXCJ0ZXh0XCJdKTtcblxuICAvLyBsZXQgRWxlbWVudCA9IGlzU3RhdGljID8gJ3NwYW4nIDogcmVuZGVyQXM7XG4gIHZhciBvdGhlclByb3BzID0ge307XG5cbiAgaWYgKHN1Ym1pdCkge1xuICAgIG90aGVyUHJvcHMgPSB7XG4gICAgICB0eXBlOiAnc3VibWl0JyxcbiAgICAgIHJlbmRlckFzOiByZW5kZXJBcyB8fCAnYnV0dG9uJ1xuICAgIH07XG4gIH1cblxuICBpZiAocmVzZXQpIHtcbiAgICBvdGhlclByb3BzID0ge1xuICAgICAgdHlwZTogJ3Jlc2V0JyxcbiAgICAgIHJlbmRlckFzOiByZW5kZXJBcyB8fCAnYnV0dG9uJ1xuICAgIH07XG4gIH1cblxuICBpZiAoaXNTdGF0aWMpIHtcbiAgICBvdGhlclByb3BzID0ge1xuICAgICAgcmVuZGVyQXM6ICdzcGFuJ1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBidXR0b25fZXh0ZW5kcyh7XG4gICAgdGFiSW5kZXg6IGRpc2FibGVkID8gLTEgOiAwLFxuICAgIHJlbmRlckFzOiByZW5kZXJBc1xuICB9LCBwcm9wcywgb3RoZXJQcm9wcywge1xuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBvbkNsaWNrOiBkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IG9uQ2xpY2ssXG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKShjbGFzc05hbWUsIChfY2xhc3NuYW1lcyA9IHt9LCBidXR0b25fZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KGNvbG9yKSwgY29sb3IpLCBidXR0b25fZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KHNpemUpLCBzaXplKSwgYnV0dG9uX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImlzLVwiLmNvbmNhdChzdGF0ZSksIHN0YXRlKSwgYnV0dG9uX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCAnaXMtc2VsZWN0ZWQnLCBpc1NlbGVjdGVkKSwgYnV0dG9uX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCAnaXMtc3RhdGljJywgaXNTdGF0aWMpLCBidXR0b25fZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy1yb3VuZGVkJywgcm91bmRlZCksIGJ1dHRvbl9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2lzLW91dGxpbmVkJywgb3V0bGluZWQpLCBidXR0b25fZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy1pbnZlcnRlZCcsIGludmVydGVkKSwgYnV0dG9uX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCAnaXMtZnVsbHdpZHRoJywgZnVsbHdpZHRoKSwgYnV0dG9uX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCAnaXMtbG9hZGluZycsIGxvYWRpbmcpLCBidXR0b25fZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy10ZXh0JywgdGV4dCksIGJ1dHRvbl9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJkZWxldGVcIiwgcmVtb3ZlKSwgYnV0dG9uX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImJ1dHRvblwiLCAhcmVtb3ZlKSwgX2NsYXNzbmFtZXMpKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuYnV0dG9uX0J1dHRvbi5Hcm91cCA9IGJ1dHRvbl9ncm91cDtcbmJ1dHRvbl9CdXR0b24ucHJvcFR5cGVzID0gYnV0dG9uX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXMsXG4gIG9uQ2xpY2s6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmZ1bmMsXG4gIGNvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihidXR0b25fY29sb3JzKSxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXSksXG4gIHN0YXRlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ2hvdmVyJywgJ2ZvY3VzJywgJ2FjdGl2ZScsICdsb2FkaW5nJ10pLFxuICBvdXRsaW5lZDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgaW52ZXJ0ZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHN1Ym1pdDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgcmVzZXQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIGxvYWRpbmc6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIGZ1bGx3aWR0aDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgZGlzYWJsZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHJlbW92ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgaXNTZWxlY3RlZDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgaXNTdGF0aWM6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHJvdW5kZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHRleHQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbn0pO1xuYnV0dG9uX0J1dHRvbi5kZWZhdWx0UHJvcHMgPSBidXR0b25fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdidXR0b24nLFxuICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICBzaXplOiB1bmRlZmluZWQsXG4gIHN0YXRlOiB1bmRlZmluZWQsXG4gIG91dGxpbmVkOiBmYWxzZSxcbiAgaW52ZXJ0ZWQ6IGZhbHNlLFxuICBzdWJtaXQ6IGZhbHNlLFxuICByZXNldDogZmFsc2UsXG4gIGZ1bGx3aWR0aDogZmFsc2UsXG4gIGxvYWRpbmc6IGZhbHNlLFxuICBkaXNhYmxlZDogZmFsc2UsXG4gIHJlbW92ZTogZmFsc2UsXG4gIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuICBpc1N0YXRpYzogZmFsc2UsXG4gIHJvdW5kZWQ6IGZhbHNlLFxuICB0ZXh0OiBmYWxzZVxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2J1dHRvbl9idXR0b24gPSAoYnV0dG9uX0J1dHRvbik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2J1dHRvbi9pbmRleC5qc1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvYnJlYWRjcnVtYi9icmVhZGNydW1iLmpzXG5mdW5jdGlvbiBicmVhZGNydW1iX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGJyZWFkY3J1bWJfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGJyZWFkY3J1bWJfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBicmVhZGNydW1iX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGJyZWFkY3J1bWJfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGJyZWFkY3J1bWJfZXh0ZW5kcygpIHsgYnJlYWRjcnVtYl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGJyZWFkY3J1bWJfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGJyZWFkY3J1bWJfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBicmVhZGNydW1iX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBicmVhZGNydW1iX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBicmVhZGNydW1iX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBicmVhZGNydW1iX0JyZWFkY3J1bWIgPSBmdW5jdGlvbiBCcmVhZGNydW1iKF9yZWYpIHtcbiAgdmFyIF9jbGFzc25hbWVzO1xuXG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGl0ZW1zID0gX3JlZi5pdGVtcyxcbiAgICAgIHJlbmRlckFzID0gX3JlZi5yZW5kZXJBcyxcbiAgICAgIGhyZWZBdHRyID0gX3JlZi5ocmVmQXR0cixcbiAgICAgIHNlcGFyYXRvciA9IF9yZWYuc2VwYXJhdG9yLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIHByb3BzID0gYnJlYWRjcnVtYl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIiwgXCJpdGVtc1wiLCBcInJlbmRlckFzXCIsIFwiaHJlZkF0dHJcIiwgXCJzZXBhcmF0b3JcIiwgXCJzaXplXCIsIFwiYWxpZ25cIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGJyZWFkY3J1bWJfZXh0ZW5kcyh7XG4gICAgcmVuZGVyQXM6IFwibmF2XCJcbiAgfSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdicmVhZGNydW1iJywgY2xhc3NOYW1lLCAoX2NsYXNzbmFtZXMgPSB7fSwgYnJlYWRjcnVtYl9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJoYXMtXCIuY29uY2F0KHNlcGFyYXRvciwgXCItc2VwYXJhdG9yXCIpLCBzZXBhcmF0b3IpLCBicmVhZGNydW1iX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImlzLVwiLmNvbmNhdChzaXplKSwgc2l6ZSksIGJyZWFkY3J1bWJfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KGFsaWduKSwgYWxpZ24pLCBfY2xhc3NuYW1lcykpXG4gIH0pLCBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChcInVsXCIsIG51bGwsIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBwID0gYnJlYWRjcnVtYl9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICByZW5kZXJBczogcmVuZGVyQXNcbiAgICB9LCBocmVmQXR0ciwgaXRlbS51cmwpO1xuXG4gICAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwibGlcIiwge1xuICAgICAga2V5OiBpdGVtLnVybCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoe1xuICAgICAgICAnaXMtYWN0aXZlJzogaXRlbS5hY3RpdmVcbiAgICAgIH0pXG4gICAgfSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBwLCBpdGVtLm5hbWUpKTtcbiAgfSkpKTtcbn07XG5cbmJyZWFkY3J1bWJfQnJlYWRjcnVtYi5wcm9wVHlwZXMgPSBicmVhZGNydW1iX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgc2VwYXJhdG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ2Fycm93JywgJ2J1bGxldCcsICdkb3QnLCAnc3VjY2VlZHMnXSksXG4gIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJ10pLFxuICBhbGlnbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydyaWdodCcsICdjZW50ZXInXSksXG4gIGl0ZW1zOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5hcnJheU9mKGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHtcbiAgICB1cmw6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjdGl2ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgICBuYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlXG4gIH0pKSxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hcyxcbiAgaHJlZkF0dHI6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZ1xufSk7XG5icmVhZGNydW1iX0JyZWFkY3J1bWIuZGVmYXVsdFByb3BzID0gYnJlYWRjcnVtYl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgaXRlbXM6IFtdLFxuICBocmVmQXR0cjogJ2hyZWYnLFxuICBzZXBhcmF0b3I6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdhJyxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHNpemU6IHVuZGVmaW5lZCxcbiAgYWxpZ246IHVuZGVmaW5lZFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBicmVhZGNydW1iID0gKGJyZWFkY3J1bWJfQnJlYWRjcnVtYik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvYnJlYWRjcnVtYi9icmVhZGNydW1iLnNhc3NcbnZhciBicmVhZGNydW1iX2JyZWFkY3J1bWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2JyZWFkY3J1bWIvaW5kZXguanNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2JyZWFkY3J1bWIgPSAoYnJlYWRjcnVtYik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY2FyZC9jYXJkLnNhc3NcbnZhciBjYXJkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9pbWFnZS9pbWFnZS5zYXNzXG52YXIgaW1hZ2VfaW1hZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9pbWFnZS9jb25zdGFudHMuanNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGltYWdlX2NvbnN0YW50cyA9ICh7XG4gIFNJWkVTOiBbMTYsIDI0LCAzMiwgNDgsIDY0LCA5NiwgMTI4LCAnc3F1YXJlJywgJzFieTEnLCAnNGJ5MycsICczYnkyJywgJzE2Ynk5JywgJzJieTEnLCAnNWJ5NCcsICc1YnkzJywgJzNieTEnLCAnNGJ5NScsICczYnk0JywgJzJieTMnLCAnM2J5NScsICc5YnkxNicsICcxYnkyJywgJzFieTMnXVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2ltYWdlL2ltYWdlLmpzXG5mdW5jdGlvbiBpbWFnZV9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBpbWFnZV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgaW1hZ2Vfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBpbWFnZV9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBpbWFnZV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaW1hZ2VfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgaW1hZ2VfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IGltYWdlX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBpbWFnZV90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpbWFnZV9leHRlbmRzKCkgeyBpbWFnZV9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGltYWdlX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBpbWFnZV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gaW1hZ2Vfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGltYWdlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBpbWFnZV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGltYWdlX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBpbWFnZV9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGltYWdlX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBpbWFnZV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBpbWFnZV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGltYWdlX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gaW1hZ2VfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIGltYWdlX2dldFByb3RvdHlwZU9mKG8pIHsgaW1hZ2VfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gaW1hZ2VfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gaW1hZ2VfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gaW1hZ2VfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgaW1hZ2Vfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGltYWdlX3NldFByb3RvdHlwZU9mKG8sIHApIHsgaW1hZ2Vfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGltYWdlX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIGltYWdlX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuXG5cblxuXG5cblxuXG52YXIgaW1hZ2VfSW1hZ2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIGltYWdlX2luaGVyaXRzKEltYWdlLCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSW1hZ2UocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpbWFnZV9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZSk7XG5cbiAgICBfdGhpcyA9IGltYWdlX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgaW1hZ2VfZ2V0UHJvdG90eXBlT2YoSW1hZ2UpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIGltYWdlX2RlZmluZVByb3BlcnR5KGltYWdlX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25FcnJvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNyYzogX3RoaXMucHJvcHMuZmFsbGJhY2tcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBpbWFnZV9jcmVhdGVDbGFzcyhJbWFnZSwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgYWx0ID0gX3RoaXMkcHJvcHMuYWx0LFxuICAgICAgICAgIHNpemUgPSBfdGhpcyRwcm9wcy5zaXplLFxuICAgICAgICAgIGZhbGxiYWNrID0gX3RoaXMkcHJvcHMuZmFsbGJhY2ssXG4gICAgICAgICAgcm91bmRlZCA9IF90aGlzJHByb3BzLnJvdW5kZWQsXG4gICAgICAgICAgc3JjID0gX3RoaXMkcHJvcHMuc3JjLFxuICAgICAgICAgIGZ1bGx3aWR0aCA9IF90aGlzJHByb3BzLmZ1bGx3aWR0aCxcbiAgICAgICAgICBwcm9wcyA9IGltYWdlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjbGFzc05hbWVcIiwgXCJhbHRcIiwgXCJzaXplXCIsIFwiZmFsbGJhY2tcIiwgXCJyb3VuZGVkXCIsIFwic3JjXCIsIFwiZnVsbHdpZHRoXCJdKTtcblxuICAgICAgdmFyIHMgPSBzaXplO1xuXG4gICAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHMgPSBcIlwiLmNvbmNhdChzLCBcInhcIikuY29uY2F0KHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBpbWFnZV9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICByZW5kZXJBczogXCJmaWd1cmVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnaW1hZ2UnLCBjbGFzc05hbWUsIChfY2xhc3NuYW1lcyA9IHt9LCBpbWFnZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQocyksIHMpLCBpbWFnZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2lzLWZ1bGx3aWR0aCcsIGZ1bGx3aWR0aCksIF9jbGFzc25hbWVzKSlcbiAgICAgIH0pLCBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoe1xuICAgICAgICAgICdpcy1yb3VuZGVkJzogcm91bmRlZFxuICAgICAgICB9KSxcbiAgICAgICAgb25FcnJvcjogdGhpcy5vbkVycm9yLFxuICAgICAgICBzcmM6IHRoaXMuc3RhdGUuc3JjLFxuICAgICAgICBhbHQ6IGFsdFxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZTtcbn0oZXh0ZXJuYWxfcmVhY3RfW1wiUHVyZUNvbXBvbmVudFwiXSk7XG5cbmltYWdlX2RlZmluZVByb3BlcnR5KGltYWdlX0ltYWdlLCBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLCBmdW5jdGlvbiAocHJvcHMsIHN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgc3JjOiBzdGF0ZS5kZWZhdWx0ICE9PSBwcm9wcy5zcmMgPyBwcm9wcy5zcmMgOiBzdGF0ZS5zcmMsXG4gICAgZGVmYXVsdDogcHJvcHMuc3JjXG4gIH07XG59KTtcblxuXG5pbWFnZV9JbWFnZS5wcm9wVHlwZXMgPSBpbWFnZV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHNyYzogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBhbHQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgcm91bmRlZDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoaW1hZ2VfY29uc3RhbnRzLlNJWkVTKSxcbiAgZmFsbGJhY2s6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgZnVsbHdpZHRoOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sXG59KTtcbmltYWdlX0ltYWdlLmRlZmF1bHRQcm9wcyA9IGltYWdlX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3JjOiAnJyxcbiAgYWx0OiAnJyxcbiAgcm91bmRlZDogZmFsc2UsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHNpemU6IHVuZGVmaW5lZCxcbiAgZmFsbGJhY2s6ICdodHRwczovL2J1bG1hLmlvL2ltYWdlcy9wbGFjZWhvbGRlcnMvNDgweDQ4MC5wbmcnLFxuICBmdWxsd2lkdGg6IGZhbHNlXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvaW1hZ2UvaW5kZXguanNcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2NhcmQvY29tcG9uZW50cy9pbWFnZS5qc1xuZnVuY3Rpb24gY29tcG9uZW50c19pbWFnZV9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2ltYWdlX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBjb21wb25lbnRzX2ltYWdlX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgY29tcG9uZW50c19pbWFnZV9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBjb21wb25lbnRzX2ltYWdlX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2ltYWdlX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19pbWFnZV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gY29tcG9uZW50c19pbWFnZV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19pbWFnZV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxudmFyIGltYWdlX0NhcmRJbWFnZSA9IGZ1bmN0aW9uIENhcmRJbWFnZShfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGRvbVJlZiA9IF9yZWYuZG9tUmVmLFxuICAgICAgcHJvcHMgPSBjb21wb25lbnRzX2ltYWdlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNsYXNzTmFtZVwiLCBcImRvbVJlZlwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwge1xuICAgIGRvbVJlZjogZG9tUmVmLFxuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2NhcmQtaW1hZ2UnLCBjbGFzc05hbWUpXG4gIH0sIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGltYWdlX0ltYWdlLCBwcm9wcykpO1xufTtcblxuaW1hZ2VfQ2FyZEltYWdlLnByb3BUeXBlcyA9IGNvbXBvbmVudHNfaW1hZ2Vfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7fSwgaW1hZ2VfSW1hZ2UucHJvcFR5cGVzKTtcbmltYWdlX0NhcmRJbWFnZS5kZWZhdWx0UHJvcHMgPSBjb21wb25lbnRzX2ltYWdlX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge30sIGltYWdlX0ltYWdlLmRlZmF1bHRQcm9wcyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2ltYWdlID0gKGltYWdlX0NhcmRJbWFnZSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2NhcmQvY29tcG9uZW50cy9jb250ZW50LmpzXG5mdW5jdGlvbiBjb250ZW50X293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGNvbnRlbnRfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGNvbnRlbnRfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjb250ZW50X2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGNvbnRlbnRfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbnRlbnRfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBjb250ZW50X2V4dGVuZHMoKSB7IGNvbnRlbnRfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBjb250ZW50X2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBjb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBjb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBjb250ZW50X0NhcmRDb250ZW50ID0gZnVuY3Rpb24gQ2FyZENvbnRlbnQoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGNvbnRlbnRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjb250ZW50X2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnY2FyZC1jb250ZW50JywgY2xhc3NOYW1lKVxuICB9KSk7XG59O1xuXG5jb250ZW50X0NhcmRDb250ZW50LnByb3BUeXBlcyA9IGNvbnRlbnRfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmNvbnRlbnRfQ2FyZENvbnRlbnQuZGVmYXVsdFByb3BzID0gY29udGVudF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2J1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb250ZW50ID0gKGNvbnRlbnRfQ2FyZENvbnRlbnQpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9jYXJkL2NvbXBvbmVudHMvaGVhZGVyL2NvbXBvbmVudHMvaGVhZGVyLXRpdGxlLmpzXG5mdW5jdGlvbiBoZWFkZXJfdGl0bGVfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gaGVhZGVyX3RpdGxlX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBoZWFkZXJfdGl0bGVfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBoZWFkZXJfdGl0bGVfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgaGVhZGVyX3RpdGxlX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBoZWFkZXJfdGl0bGVfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBoZWFkZXJfdGl0bGVfZXh0ZW5kcygpIHsgaGVhZGVyX3RpdGxlX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gaGVhZGVyX3RpdGxlX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBoZWFkZXJfdGl0bGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGhlYWRlcl90aXRsZV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaGVhZGVyX3RpdGxlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBoZWFkZXJfdGl0bGVfQ2FyZEhlYWRlclRpdGxlID0gZnVuY3Rpb24gQ2FyZEhlYWRlclRpdGxlKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcHJvcHMgPSBoZWFkZXJfdGl0bGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBoZWFkZXJfdGl0bGVfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdjYXJkLWhlYWRlci10aXRsZScsIGNsYXNzTmFtZSlcbiAgfSkpO1xufTtcblxuaGVhZGVyX3RpdGxlX0NhcmRIZWFkZXJUaXRsZS5wcm9wVHlwZXMgPSBoZWFkZXJfdGl0bGVfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmhlYWRlcl90aXRsZV9DYXJkSGVhZGVyVGl0bGUuZGVmYXVsdFByb3BzID0gaGVhZGVyX3RpdGxlX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGhlYWRlcl90aXRsZSA9IChoZWFkZXJfdGl0bGVfQ2FyZEhlYWRlclRpdGxlKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY2FyZC9jb21wb25lbnRzL2hlYWRlci9jb21wb25lbnRzL2hlYWRlci1pY29uLmpzXG5mdW5jdGlvbiBoZWFkZXJfaWNvbl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBoZWFkZXJfaWNvbl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgaGVhZGVyX2ljb25fb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBoZWFkZXJfaWNvbl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBoZWFkZXJfaWNvbl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaGVhZGVyX2ljb25fZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBoZWFkZXJfaWNvbl9leHRlbmRzKCkgeyBoZWFkZXJfaWNvbl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGhlYWRlcl9pY29uX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBoZWFkZXJfaWNvbl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gaGVhZGVyX2ljb25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGhlYWRlcl9pY29uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBoZWFkZXJfaWNvbl9DYXJkSGVhZGVySWNvbiA9IGZ1bmN0aW9uIENhcmRIZWFkZXJJY29uKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcHJvcHMgPSBoZWFkZXJfaWNvbl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGhlYWRlcl9pY29uX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnY2FyZC1oZWFkZXItaWNvbicsIGNsYXNzTmFtZSlcbiAgfSkpO1xufTtcblxuaGVhZGVyX2ljb25fQ2FyZEhlYWRlckljb24ucHJvcFR5cGVzID0gaGVhZGVyX2ljb25fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmhlYWRlcl9pY29uX0NhcmRIZWFkZXJJY29uLmRlZmF1bHRQcm9wcyA9IGhlYWRlcl9pY29uX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGhlYWRlcl9pY29uID0gKGhlYWRlcl9pY29uX0NhcmRIZWFkZXJJY29uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY2FyZC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIuanNcbmZ1bmN0aW9uIGhlYWRlcl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBoZWFkZXJfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGhlYWRlcl9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGhlYWRlcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBoZWFkZXJfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGhlYWRlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGhlYWRlcl9leHRlbmRzKCkgeyBoZWFkZXJfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBoZWFkZXJfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGhlYWRlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gaGVhZGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBoZWFkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBoZWFkZXJfQ2FyZEhlYWRlciA9IGZ1bmN0aW9uIENhcmRIZWFkZXIoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGhlYWRlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGhlYWRlcl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2NhcmQtaGVhZGVyJywgY2xhc3NOYW1lKVxuICB9KSk7XG59O1xuXG5oZWFkZXJfQ2FyZEhlYWRlci5UaXRsZSA9IGhlYWRlcl90aXRsZTtcbmhlYWRlcl9DYXJkSGVhZGVyLkljb24gPSBoZWFkZXJfaWNvbjtcbmhlYWRlcl9DYXJkSGVhZGVyLnByb3BUeXBlcyA9IGhlYWRlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuaGVhZGVyX0NhcmRIZWFkZXIuZGVmYXVsdFByb3BzID0gaGVhZGVyX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGhlYWRlciA9IChoZWFkZXJfQ2FyZEhlYWRlcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2NhcmQvY29tcG9uZW50cy9oZWFkZXIvaW5kZXguanNcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9jYXJkL2NvbXBvbmVudHMvZm9vdGVyL2NvbXBvbmVudHMvZm9vdGVyLWl0ZW0uanNcbmZ1bmN0aW9uIGZvb3Rlcl9pdGVtX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGZvb3Rlcl9pdGVtX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBmb290ZXJfaXRlbV9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGZvb3Rlcl9pdGVtX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGZvb3Rlcl9pdGVtX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBmb290ZXJfaXRlbV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGZvb3Rlcl9pdGVtX2V4dGVuZHMoKSB7IGZvb3Rlcl9pdGVtX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gZm9vdGVyX2l0ZW1fZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGZvb3Rlcl9pdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBmb290ZXJfaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZm9vdGVyX2l0ZW1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGZvb3Rlcl9pdGVtX0NhcmRGb290ZXJJdGVtID0gZnVuY3Rpb24gQ2FyZEZvb3Rlckl0ZW0oX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGZvb3Rlcl9pdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgZm9vdGVyX2l0ZW1fZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdjYXJkLWZvb3Rlci1pdGVtJywgY2xhc3NOYW1lKVxuICB9KSk7XG59O1xuXG5mb290ZXJfaXRlbV9DYXJkRm9vdGVySXRlbS5wcm9wVHlwZXMgPSBmb290ZXJfaXRlbV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuZm9vdGVyX2l0ZW1fQ2FyZEZvb3Rlckl0ZW0uZGVmYXVsdFByb3BzID0gZm9vdGVyX2l0ZW1fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZm9vdGVyX2l0ZW0gPSAoZm9vdGVyX2l0ZW1fQ2FyZEZvb3Rlckl0ZW0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9jYXJkL2NvbXBvbmVudHMvZm9vdGVyL2Zvb3Rlci5qc1xuZnVuY3Rpb24gZm9vdGVyX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGZvb3Rlcl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgZm9vdGVyX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZm9vdGVyX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGZvb3Rlcl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZm9vdGVyX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gZm9vdGVyX2V4dGVuZHMoKSB7IGZvb3Rlcl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGZvb3Rlcl9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gZm9vdGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBmb290ZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZvb3Rlcl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG5cbnZhciBmb290ZXJfQ2FyZEZvb3RlciA9IGZ1bmN0aW9uIENhcmRGb290ZXIoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGZvb3Rlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGZvb3Rlcl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2NhcmQtZm9vdGVyJywgY2xhc3NOYW1lKVxuICB9KSk7XG59O1xuXG5mb290ZXJfQ2FyZEZvb3Rlci5JdGVtID0gZm9vdGVyX2l0ZW07XG5mb290ZXJfQ2FyZEZvb3Rlci5wcm9wVHlwZXMgPSBmb290ZXJfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmZvb3Rlcl9DYXJkRm9vdGVyLmRlZmF1bHRQcm9wcyA9IGZvb3Rlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2J1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmb290ZXIgPSAoZm9vdGVyX0NhcmRGb290ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9jYXJkL2NvbXBvbmVudHMvZm9vdGVyL2luZGV4LmpzXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY2FyZC9jYXJkLmpzXG5mdW5jdGlvbiBjYXJkX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGNhcmRfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGNhcmRfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjYXJkX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGNhcmRfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNhcmRfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBjYXJkX2V4dGVuZHMoKSB7IGNhcmRfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBjYXJkX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBjYXJkX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBjYXJkX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjYXJkX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNhcmRfQ2FyZCA9IGZ1bmN0aW9uIENhcmQoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBwcm9wcyA9IGNhcmRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCIsIFwiY2hpbGRyZW5cIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGNhcmRfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnY2FyZCcsIGNsYXNzTmFtZSlcbiAgfSwgcHJvcHMpLCBjaGlsZHJlbik7XG59O1xuXG5jYXJkX0NhcmQuSW1hZ2UgPSBjb21wb25lbnRzX2ltYWdlO1xuY2FyZF9DYXJkLkNvbnRlbnQgPSBjb250ZW50O1xuY2FyZF9DYXJkLkhlYWRlciA9IGhlYWRlcjtcbmNhcmRfQ2FyZC5Gb290ZXIgPSBmb290ZXI7XG5jYXJkX0NhcmQucHJvcFR5cGVzID0gY2FyZF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmNhcmRfQ2FyZC5kZWZhdWx0UHJvcHMgPSBjYXJkX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgY2hpbGRyZW46IG51bGwsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2J1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjYXJkX2NhcmQgPSAoY2FyZF9DYXJkKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY2FyZC9pbmRleC5qc1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY29sdW1ucy9jb25zdGFudHMuanNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbHVtbnNfY29uc3RhbnRzID0gKHtcbiAgU0laRVM6IHtcbiAgICBUSFJFRVFVQVJURVJTOiAndGhyZWUtcXVhcnRlcnMnLFxuICAgIFRXT1RISVJEUzogJ3R3by10aGlyZHMnLFxuICAgIEhBTEY6ICdoYWxmJyxcbiAgICBPTkVUSElSRDogJ29uZS10aGlyZCcsXG4gICAgT05FUVVBUlRFUjogJ29uZS1xdWFydGVyJyxcbiAgICBPTkVGSUZUSDogJ29uZS1maWZ0aCcsXG4gICAgVFdPRklGVEhTOiAndHdvLWZpZnRocycsXG4gICAgVEhSRUVGSUZUSFM6ICd0aHJlZS1maWZ0aHMnLFxuICAgIEZPVVJGSUZUSFM6ICdmb3VyLWZpZnRocydcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2NvbHVtbnMvY29tcG9uZW50cy9jb2x1bW4uanNcbmZ1bmN0aW9uIGNvbHVtbl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBjb2x1bW5fb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGNvbHVtbl9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGNvbHVtbl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBjb2x1bW5fb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbHVtbl9leHRlbmRzKCkgeyBjb2x1bW5fZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBjb2x1bW5fZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGNvbHVtbl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGNvbHVtbl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gY29sdW1uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb2x1bW5fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cbnZhciBzaXplcyA9IFtudWxsLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyXS5jb25jYXQoT2JqZWN0LmtleXMoY29sdW1uc19jb25zdGFudHMuU0laRVMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBjb2x1bW5zX2NvbnN0YW50cy5TSVpFU1trZXldO1xufSkpO1xuXG52YXIgY29sdW1uX0NvbHVtbiA9IGZ1bmN0aW9uIENvbHVtbihfcmVmKSB7XG4gIHZhciBfY2xhc3NOYW1lcztcblxuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICBuYXJyb3cgPSBfcmVmLm5hcnJvdyxcbiAgICAgIG1vYmlsZSA9IF9yZWYubW9iaWxlLFxuICAgICAgdGFibGV0ID0gX3JlZi50YWJsZXQsXG4gICAgICBkZXNrdG9wID0gX3JlZi5kZXNrdG9wLFxuICAgICAgd2lkZXNjcmVlbiA9IF9yZWYud2lkZXNjcmVlbixcbiAgICAgIGZ1bGxoZCA9IF9yZWYuZnVsbGhkLFxuICAgICAgdG91Y2ggPSBfcmVmLnRvdWNoLFxuICAgICAgcHJvcHMgPSBjb2x1bW5fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJzaXplXCIsIFwib2Zmc2V0XCIsIFwibmFycm93XCIsIFwibW9iaWxlXCIsIFwidGFibGV0XCIsIFwiZGVza3RvcFwiLCBcIndpZGVzY3JlZW5cIiwgXCJmdWxsaGRcIiwgXCJ0b3VjaFwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgY29sdW1uX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKShjbGFzc05hbWUsICdjb2x1bW4nLCAoX2NsYXNzTmFtZXMgPSB7fSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBcImlzLVwiLmNvbmNhdChzaXplKSwgc2l6ZSksIGNvbHVtbl9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgXCJpcy1cIi5jb25jYXQodG91Y2guc2l6ZSwgXCItbW9iaWxlXCIpLCB0b3VjaC5zaXplKSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBcImlzLVwiLmNvbmNhdChtb2JpbGUuc2l6ZSwgXCItbW9iaWxlXCIpLCBtb2JpbGUuc2l6ZSksIGNvbHVtbl9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgXCJpcy1cIi5jb25jYXQodGFibGV0LnNpemUsIFwiLXRhYmxldFwiKSwgdGFibGV0LnNpemUpLCBjb2x1bW5fZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsIFwiaXMtXCIuY29uY2F0KGRlc2t0b3Auc2l6ZSwgXCItZGVza3RvcFwiKSwgZGVza3RvcC5zaXplKSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBcImlzLVwiLmNvbmNhdCh3aWRlc2NyZWVuLnNpemUsIFwiLXdpZGVzY3JlZW5cIiksIHdpZGVzY3JlZW4uc2l6ZSksIGNvbHVtbl9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgXCJpcy1cIi5jb25jYXQoZnVsbGhkLnNpemUsIFwiLWZ1bGxoZFwiKSwgZnVsbGhkLnNpemUpLCBjb2x1bW5fZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsIFwiaXMtb2Zmc2V0LVwiLmNvbmNhdCh0b3VjaC5vZmZzZXQsIFwiLW1vYmlsZVwiKSwgdG91Y2gub2Zmc2V0KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBcImlzLW9mZnNldC1cIi5jb25jYXQobW9iaWxlLm9mZnNldCwgXCItbW9iaWxlXCIpLCBtb2JpbGUub2Zmc2V0KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBcImlzLW9mZnNldC1cIi5jb25jYXQodGFibGV0Lm9mZnNldCwgXCItdGFibGV0XCIpLCB0YWJsZXQub2Zmc2V0KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBcImlzLW9mZnNldC1cIi5jb25jYXQoZGVza3RvcC5vZmZzZXQsIFwiLWRlc2t0b3BcIiksIGRlc2t0b3Aub2Zmc2V0KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBcImlzLW9mZnNldC1cIi5jb25jYXQod2lkZXNjcmVlbi5vZmZzZXQsIFwiLXdpZGVzY3JlZW5cIiksIHdpZGVzY3JlZW4ub2Zmc2V0KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBcImlzLW9mZnNldC1cIi5jb25jYXQoZnVsbGhkLm9mZnNldCwgXCItZnVsbGhkXCIpLCBmdWxsaGQub2Zmc2V0KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBcImlzLW9mZnNldC1cIi5jb25jYXQob2Zmc2V0KSwgb2Zmc2V0KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCAnaXMtbmFycm93JywgbmFycm93KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCAnaXMtbmFycm93LXRvdWNoJywgdG91Y2gubmFycm93KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCAnaXMtbmFycm93LW1vYmlsZScsIG1vYmlsZS5uYXJyb3cpLCBjb2x1bW5fZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsICdpcy1uYXJyb3ctdGFibGV0JywgdGFibGV0Lm5hcnJvdyksIGNvbHVtbl9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgJ2lzLW5hcnJvdy1kZXNrdG9wJywgZGVza3RvcC5uYXJyb3cpLCBjb2x1bW5fZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsICdpcy1uYXJyb3ctd2lkZXNjcmVlbicsIHdpZGVzY3JlZW4ubmFycm93KSwgY29sdW1uX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCAnaXMtbmFycm93LWZ1bGxoZCcsIGZ1bGxoZC5uYXJyb3cpLCBfY2xhc3NOYW1lcykpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5jb2x1bW5fQ29sdW1uLnByb3BUeXBlcyA9IGNvbHVtbl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgY29sdW1uLiB0aGUgbWF4aW11bSBzaXplIG9mIGEgcm93IGlzIDEyXG4gICAqL1xuICBzaXplOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihzaXplcyksXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBob3Jpem9udGFsIHNwYWNlIGFyb3VuZCBDb2x1bW4gZWxlbWVudHNcbiAgICovXG4gIG9mZnNldDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2Yoc2l6ZXMpLFxuXG4gIC8qKlxuICAgKiBJZiB5b3Ugd2FudCBhIGNvbHVtbiB0byBvbmx5IHRha2UgdGhlIHNwYWNlIGl0IG5lZWRzLCB1c2UgdGhlIG5hcnJvdyBtb2RpZmllci4gVGhlIG90aGVyIGNvbHVtbihzKSB3aWxsIGZpbGwgdXAgdGhlIHJlbWFpbmluZyBzcGFjZS5cbiAgICovXG4gIG5hcnJvdzogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcblxuICAvKipcbiAgICogU2l6ZSwgT2Zmc2V0IGFuZCBOYXJyb3cgcHJvcHMgZm9yIE1vYmlsZSBkZXZpY2VzIChVcCB0byA3NjhweClcbiAgICovXG4gIHRvdWNoOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7XG4gICAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2Yoc2l6ZXMpLFxuICAgIG9mZnNldDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2Yoc2l6ZXMpLFxuICAgIG5hcnJvdzogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbFxuICB9KSxcblxuICAvKipcbiAgICogU2l6ZSwgT2Zmc2V0IGFuZCBOYXJyb3cgcHJvcHMgZm9yIE1vYmlsZSBkZXZpY2VzIChVcCB0byA3NjhweClcbiAgICovXG4gIG1vYmlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe1xuICAgIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKHNpemVzKSxcbiAgICBvZmZzZXQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKHNpemVzKSxcbiAgICBuYXJyb3c6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbiAgfSksXG5cbiAgLyoqXG4gICAqIFNpemUsIE9mZnNldCBhbmQgTmFycm93IHByb3BzIGZvciBUYWJsZXQgZGV2aWNlcyAoQmV0d2VlbiA3NjlweCBhbmQgMTAyM3B4KVxuICAgKi9cbiAgdGFibGV0OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7XG4gICAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2Yoc2l6ZXMpLFxuICAgIG9mZnNldDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2Yoc2l6ZXMpLFxuICAgIG5hcnJvdzogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbFxuICB9KSxcblxuICAvKipcbiAgICogU2l6ZSwgT2Zmc2V0IGFuZCBOYXJyb3cgcHJvcHMgZm9yIERlc2t0b3AgZGV2aWNlcyAoQmV0d2VlbiAxMDI0cHggYW5kIDEyMTVweClcbiAgICovXG4gIGRlc2t0b3A6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHtcbiAgICBzaXplOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihzaXplcyksXG4gICAgb2Zmc2V0OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihzaXplcyksXG4gICAgbmFycm93OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBTaXplLCBPZmZzZXQgYW5kIE5hcnJvdyBwcm9wcyBmb3IgV2lkZVNjcmVlbiBkZXZpY2VzIChCZXR3ZWVuIDEyMTZweCBhbmQgMTQwN3B4KVxuICAgKi9cbiAgd2lkZXNjcmVlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe1xuICAgIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKHNpemVzKSxcbiAgICBvZmZzZXQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKHNpemVzKSxcbiAgICBuYXJyb3c6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbiAgfSksXG5cbiAgLyoqXG4gICAqIFNpemUsIE9mZnNldCBhbmQgTmFycm93IHByb3BzIGZvciBGdWxsSEQgZGV2aWNlcyAoMTQwOHB4IGFuZCBhYm92ZSlcbiAgICovXG4gIGZ1bGxoZDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe1xuICAgIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKHNpemVzKSxcbiAgICBvZmZzZXQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKHNpemVzKSxcbiAgICBuYXJyb3c6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbiAgfSlcbn0pO1xuY29sdW1uX0NvbHVtbi5kZWZhdWx0UHJvcHMgPSBjb2x1bW5fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICBzaXplOiB1bmRlZmluZWQsXG4gIG9mZnNldDogdW5kZWZpbmVkLFxuICBuYXJyb3c6IHVuZGVmaW5lZCxcbiAgbW9iaWxlOiB7XG4gICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgIG9mZnNldDogdW5kZWZpbmVkLFxuICAgIG5hcnJvdzogdW5kZWZpbmVkXG4gIH0sXG4gIHRvdWNoOiB7XG4gICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgIG9mZnNldDogdW5kZWZpbmVkLFxuICAgIG5hcnJvdzogdW5kZWZpbmVkXG4gIH0sXG4gIHRhYmxldDoge1xuICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICBvZmZzZXQ6IHVuZGVmaW5lZCxcbiAgICBuYXJyb3c6IHVuZGVmaW5lZFxuICB9LFxuICBkZXNrdG9wOiB7XG4gICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgIG9mZnNldDogdW5kZWZpbmVkLFxuICAgIG5hcnJvdzogdW5kZWZpbmVkXG4gIH0sXG4gIHdpZGVzY3JlZW46IHtcbiAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgb2Zmc2V0OiB1bmRlZmluZWQsXG4gICAgbmFycm93OiB1bmRlZmluZWRcbiAgfSxcbiAgZnVsbGhkOiB7XG4gICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgIG9mZnNldDogdW5kZWZpbmVkLFxuICAgIG5hcnJvdzogdW5kZWZpbmVkXG4gIH1cbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29sdW1uID0gKGNvbHVtbl9Db2x1bW4pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9jb2x1bW5zL2NvbHVtbnMuanNcbmZ1bmN0aW9uIGNvbHVtbnNfZXh0ZW5kcygpIHsgY29sdW1uc19leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGNvbHVtbnNfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGNvbHVtbnNfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gY29sdW1uc19vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgY29sdW1uc19vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGNvbHVtbnNfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgY29sdW1uc19vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29sdW1uc19kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGNvbHVtbnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGNvbHVtbnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbHVtbnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxuXG52YXIgYnJlYWtwb2ludHMgPSBbbnVsbF0uY29uY2F0KE9iamVjdC5rZXlzKGNvbnN0YW50cy5CUkVBS1BPSU5UUykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGNvbnN0YW50cy5CUkVBS1BPSU5UU1trZXldO1xufSkpO1xudmFyIGNvbHVtbnNfc2l6ZXMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOF07XG5cbnZhciBjb2x1bW5zX0NvbHVtbnMgPSBmdW5jdGlvbiBDb2x1bW5zKF9yZWYpIHtcbiAgdmFyIF9vYmplY3RTcHJlYWQyLCBfcmVmMjtcblxuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBicmVha3BvaW50ID0gX3JlZi5icmVha3BvaW50LFxuICAgICAgZ2FwbGVzcyA9IF9yZWYuZ2FwbGVzcyxcbiAgICAgIG11bHRpbGluZSA9IF9yZWYubXVsdGlsaW5lLFxuICAgICAgY2VudGVyZWQgPSBfcmVmLmNlbnRlcmVkLFxuICAgICAgdkNlbnRlcmVkID0gX3JlZi52Q2VudGVyZWQsXG4gICAgICB2YXJpYWJsZUdhcCA9IF9yZWYudmFyaWFibGVHYXAsXG4gICAgICBwcm9wcyA9IGNvbHVtbnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCIsIFwiYnJlYWtwb2ludFwiLCBcImdhcGxlc3NcIiwgXCJtdWx0aWxpbmVcIiwgXCJjZW50ZXJlZFwiLCBcInZDZW50ZXJlZFwiLCBcInZhcmlhYmxlR2FwXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjb2x1bW5zX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKShjbGFzc05hbWUsICdjb2x1bW5zJywgY29sdW1uc19vYmplY3RTcHJlYWQoKF9vYmplY3RTcHJlYWQyID0ge30sIGNvbHVtbnNfZGVmaW5lUHJvcGVydHkoX29iamVjdFNwcmVhZDIsIFwiaXMtXCIuY29uY2F0KGJyZWFrcG9pbnQpLCBicmVha3BvaW50KSwgY29sdW1uc19kZWZpbmVQcm9wZXJ0eShfb2JqZWN0U3ByZWFkMiwgJ2lzLWdhcGxlc3MnLCBnYXBsZXNzKSwgY29sdW1uc19kZWZpbmVQcm9wZXJ0eShfb2JqZWN0U3ByZWFkMiwgJ2lzLW11bHRpbGluZScsIG11bHRpbGluZSksIGNvbHVtbnNfZGVmaW5lUHJvcGVydHkoX29iamVjdFNwcmVhZDIsICdpcy1jZW50ZXJlZCcsIGNlbnRlcmVkKSwgY29sdW1uc19kZWZpbmVQcm9wZXJ0eShfb2JqZWN0U3ByZWFkMiwgJ2lzLXZjZW50ZXJlZCcsIHZDZW50ZXJlZCksIGNvbHVtbnNfZGVmaW5lUHJvcGVydHkoX29iamVjdFNwcmVhZDIsICdpcy12YXJpYWJsZScsIE9iamVjdC5rZXlzKHZhcmlhYmxlR2FwKS5sZW5ndGggPiAwKSwgX29iamVjdFNwcmVhZDIpLCB2YXJpYWJsZUdhcCA/IChfcmVmMiA9IHt9LCBjb2x1bW5zX2RlZmluZVByb3BlcnR5KF9yZWYyLCBcImlzLVwiLmNvbmNhdCh2YXJpYWJsZUdhcC50b3VjaCwgXCItdG91Y2hcIiksIHZhcmlhYmxlR2FwLnRvdWNoKSwgY29sdW1uc19kZWZpbmVQcm9wZXJ0eShfcmVmMiwgXCJpcy1cIi5jb25jYXQodmFyaWFibGVHYXAubW9iaWxlLCBcIi1tb2JpbGVcIiksIHZhcmlhYmxlR2FwLm1vYmlsZSksIGNvbHVtbnNfZGVmaW5lUHJvcGVydHkoX3JlZjIsIFwiaXMtXCIuY29uY2F0KHZhcmlhYmxlR2FwLnRhYmxldCwgXCItdGFibGV0XCIpLCB2YXJpYWJsZUdhcC50YWJsZXQpLCBjb2x1bW5zX2RlZmluZVByb3BlcnR5KF9yZWYyLCBcImlzLVwiLmNvbmNhdCh2YXJpYWJsZUdhcC5kZXNrdG9wLCBcIi1kZXNrdG9wXCIpLCB2YXJpYWJsZUdhcC5kZXNrdG9wKSwgY29sdW1uc19kZWZpbmVQcm9wZXJ0eShfcmVmMiwgXCJpcy1cIi5jb25jYXQodmFyaWFibGVHYXAud2lkZXNjcmVlbiwgXCItd2lkZXNjcmVlblwiKSwgdmFyaWFibGVHYXAud2lkZXNjcmVlbiksIGNvbHVtbnNfZGVmaW5lUHJvcGVydHkoX3JlZjIsIFwiaXMtXCIuY29uY2F0KHZhcmlhYmxlR2FwLmZ1bGxoZCwgXCItZnVsbGhkXCIpLCB2YXJpYWJsZUdhcC5mdWxsaGQpLCBfcmVmMikgOiB7fSkpXG4gIH0pKTtcbn07XG5cbmNvbHVtbnNfQ29sdW1ucy5Db2x1bW4gPSBjb2x1bW47XG5jb2x1bW5zX0NvbHVtbnMuQ09OU1RBTlRTID0gY29sdW1uc19jb25zdGFudHM7XG5jb2x1bW5zX0NvbHVtbnMucHJvcFR5cGVzID0gY29sdW1uc19vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICB2YXJpYWJsZUdhcDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoY29sdW1uc19vYmplY3RTcHJlYWQoe30sIE9iamVjdC52YWx1ZXMoY29uc3RhbnRzLkJSRUFLUE9JTlRTKS5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlcywgYnJlYWtwb2ludCkge1xuICAgIHJldHVybiBjb2x1bW5zX29iamVjdFNwcmVhZCh7fSwgdmFsdWVzLCBjb2x1bW5zX2RlZmluZVByb3BlcnR5KHt9LCBicmVha3BvaW50LCBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihjb2x1bW5zX3NpemVzKSkpO1xuICB9LCB7fSkpKSxcblxuICAvKipcbiAgICogQnJlYWtwb2ludCB3aGVyZSBjb2x1bW5zIGJlY29tZSBzdGFja2VkLlxuICAgKi9cbiAgYnJlYWtwb2ludDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoYnJlYWtwb2ludHMpLFxuXG4gIC8qKlxuICAgKiBgdHJ1ZWAgdG8gcmVtb3ZlIHNwYWNlIGJldHdlZW4gY29sdW1uc1xuICAgKi9cbiAgZ2FwbGVzczogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcblxuICAvKipcbiAgICogYHRydWVgIGlmIHlvdSB3YW50IHRvIHVzZSBtb3JlIHRoYW4gb25lIGxpbmUgaWYgeW91IGFkZCBtb3JlIGNvbHVtbiBlbGVtZW50cyB0aGF0IHdvdWxkIGZpdCBpbiBhIHNpbmdsZSByb3cuXG4gICAqL1xuICBtdWx0aWxpbmU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG5cbiAgLyoqXG4gICAqIGB0cnVlYCB5b3Ugd2FudCB0aGUgY29sdW1ucyBpbnNpZGUgdG8gYmUgaG9yaXpvbnRhbHkgY2VudGVyZWRcbiAgICovXG4gIGNlbnRlcmVkOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuXG4gIC8qKlxuICAgKiBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gdmVydGljYWxseSBhbGlnbiBjb2x1bW5zXG4gICAqL1xuICB2Q2VudGVyZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbn0pO1xuY29sdW1uc19Db2x1bW5zLmRlZmF1bHRQcm9wcyA9IGNvbHVtbnNfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgYnJlYWtwb2ludDogdW5kZWZpbmVkLFxuICBnYXBsZXNzOiBmYWxzZSxcbiAgY2VudGVyZWQ6IGZhbHNlLFxuICB2Q2VudGVyZWQ6IGZhbHNlLFxuICBtdWx0aWxpbmU6IHRydWUsXG4gIHZhcmlhYmxlR2FwOiB7fVxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb2x1bW5zID0gKGNvbHVtbnNfQ29sdW1ucyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY29sdW1ucy9jb2x1bW5zLnNhc3NcbnZhciBjb2x1bW5zX2NvbHVtbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9jb2x1bW5zL2luZGV4LmpzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19jb2x1bW5zID0gKGNvbHVtbnMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lci9jb250YWluZXIuc2Fzc1xudmFyIGNvbnRhaW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lci9jb250YWluZXIuanNcbmZ1bmN0aW9uIGNvbnRhaW5lcl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBjb250YWluZXJfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGNvbnRhaW5lcl9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGNvbnRhaW5lcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBjb250YWluZXJfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbnRhaW5lcl9leHRlbmRzKCkgeyBjb250YWluZXJfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBjb250YWluZXJfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGNvbnRhaW5lcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGNvbnRhaW5lcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gY29udGFpbmVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb250YWluZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGNvbnRhaW5lcl9icmVha3BvaW50cyA9IFtudWxsXS5jb25jYXQoT2JqZWN0LmtleXMoY29uc3RhbnRzLkJSRUFLUE9JTlRTKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gY29uc3RhbnRzLkJSRUFLUE9JTlRTW2tleV07XG59KSk7XG5cbnZhciBjb250YWluZXJfQ29udGFpbmVyID0gZnVuY3Rpb24gQ29udGFpbmVyKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGZsdWlkID0gX3JlZi5mbHVpZCxcbiAgICAgIGJyZWFrcG9pbnQgPSBfcmVmLmJyZWFrcG9pbnQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gY29udGFpbmVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiZmx1aWRcIiwgXCJicmVha3BvaW50XCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjb250YWluZXJfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdjb250YWluZXInLCBjbGFzc05hbWUsIGNvbnRhaW5lcl9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAnaXMtZmx1aWQnOiBmbHVpZFxuICAgIH0sIFwiaXMtXCIuY29uY2F0KGJyZWFrcG9pbnQpLCBicmVha3BvaW50KSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbmNvbnRhaW5lcl9Db250YWluZXIucHJvcFR5cGVzID0gY29udGFpbmVyX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgZmx1aWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICBicmVha3BvaW50OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihjb250YWluZXJfYnJlYWtwb2ludHMpLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmNvbnRhaW5lcl9Db250YWluZXIuZGVmYXVsdFByb3BzID0gY29udGFpbmVyX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBmbHVpZDogZmFsc2UsXG4gIGNoaWxkcmVuOiBudWxsLFxuICBicmVha3BvaW50OiB1bmRlZmluZWQsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29udGFpbmVyX2NvbnRhaW5lciA9IChjb250YWluZXJfQ29udGFpbmVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyL2luZGV4LmpzXG5cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2NvbnRlbnQvY29udGVudC5zYXNzXG52YXIgY29udGVudF9jb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY29udGVudC9jb250ZW50LmpzXG5mdW5jdGlvbiBjb250ZW50X2NvbnRlbnRfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gY29udGVudF9jb250ZW50X29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBjb250ZW50X2NvbnRlbnRfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjb250ZW50X2NvbnRlbnRfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgY29udGVudF9jb250ZW50X293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb250ZW50X2NvbnRlbnRfZXh0ZW5kcygpIHsgY29udGVudF9jb250ZW50X2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gY29udGVudF9jb250ZW50X2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBjb250ZW50X2NvbnRlbnRfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBjb250ZW50X2NvbnRlbnRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGNvbnRlbnRfY29udGVudF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29udGVudF9jb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBjb250ZW50X0NvbnRlbnQgPSBmdW5jdGlvbiBDb250ZW50KF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHByb3BzID0gY29udGVudF9jb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwic2l6ZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgY29udGVudF9jb250ZW50X2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnY29udGVudCcsIGNsYXNzTmFtZSwgY29udGVudF9jb250ZW50X2RlZmluZVByb3BlcnR5KHt9LCBcImlzLVwiLmNvbmNhdChzaXplKSwgc2l6ZSkpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5jb250ZW50X0NvbnRlbnQucHJvcFR5cGVzID0gY29udGVudF9jb250ZW50X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJ10pLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmNvbnRlbnRfQ29udGVudC5kZWZhdWx0UHJvcHMgPSBjb250ZW50X2NvbnRlbnRfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgc2l6ZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19jb250ZW50X2NvbnRlbnQgPSAoY29udGVudF9Db250ZW50KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY29udGVudC9pbmRleC5qc1xuXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9mb290ZXIvZm9vdGVyLnNhc3NcbnZhciBmb290ZXJfZm9vdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZm9vdGVyL2Zvb3Rlci5qc1xuZnVuY3Rpb24gZm9vdGVyX2Zvb3Rlcl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBmb290ZXJfZm9vdGVyX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBmb290ZXJfZm9vdGVyX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZm9vdGVyX2Zvb3Rlcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBmb290ZXJfZm9vdGVyX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBmb290ZXJfZm9vdGVyX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gZm9vdGVyX2Zvb3Rlcl9leHRlbmRzKCkgeyBmb290ZXJfZm9vdGVyX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gZm9vdGVyX2Zvb3Rlcl9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gZm9vdGVyX2Zvb3Rlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gZm9vdGVyX2Zvb3Rlcl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZm9vdGVyX2Zvb3Rlcl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgZm9vdGVyX0Zvb3RlciA9IGZ1bmN0aW9uIEZvb3RlcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gZm9vdGVyX2Zvb3Rlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgZm9vdGVyX2Zvb3Rlcl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2Zvb3RlcicsIGNsYXNzTmFtZSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbmZvb3Rlcl9Gb290ZXIucHJvcFR5cGVzID0gZm9vdGVyX2Zvb3Rlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmZvb3Rlcl9Gb290ZXIuZGVmYXVsdFByb3BzID0gZm9vdGVyX2Zvb3Rlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19mb290ZXJfZm9vdGVyID0gKGZvb3Rlcl9Gb290ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9mb290ZXIvaW5kZXguanNcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvaGVhZGluZy9oZWFkaW5nLnNhc3NcbnZhciBoZWFkaW5nX2hlYWRpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9oZWFkaW5nL2hlYWRpbmcuanNcbmZ1bmN0aW9uIGhlYWRpbmdfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gaGVhZGluZ19vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgaGVhZGluZ19vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGhlYWRpbmdfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgaGVhZGluZ19vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaGVhZGluZ19leHRlbmRzKCkgeyBoZWFkaW5nX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gaGVhZGluZ19leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gaGVhZGluZ19kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGhlYWRpbmdfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGhlYWRpbmdfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGhlYWRpbmdfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGhlYWRpbmdfSGVhZGluZyA9IGZ1bmN0aW9uIEhlYWRpbmcoX3JlZikge1xuICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHN1YnRpdGxlID0gX3JlZi5zdWJ0aXRsZSxcbiAgICAgIHdlaWdodCA9IF9yZWYud2VpZ2h0LFxuICAgICAgc3BhY2VkID0gX3JlZi5zcGFjZWQsXG4gICAgICBoZWFkaW5nID0gX3JlZi5oZWFkaW5nLFxuICAgICAgcHJvcHMgPSBoZWFkaW5nX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwic2l6ZVwiLCBcInN1YnRpdGxlXCIsIFwid2VpZ2h0XCIsIFwic3BhY2VkXCIsIFwiaGVhZGluZ1wiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgaGVhZGluZ19leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoY2xhc3NOYW1lLCAoX2NsYXNzbmFtZXMgPSB7XG4gICAgICB0aXRsZTogIXN1YnRpdGxlICYmICFoZWFkaW5nLFxuICAgICAgc3VidGl0bGU6IHN1YnRpdGxlLFxuICAgICAgaGVhZGluZzogaGVhZGluZ1xuICAgIH0sIGhlYWRpbmdfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KHNpemUpLCBzaXplKSwgaGVhZGluZ19kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJoYXMtdGV4dC13ZWlnaHQtXCIuY29uY2F0KHdlaWdodCksIHdlaWdodCksIGhlYWRpbmdfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy1zcGFjZWQnLCBzcGFjZWQgJiYgIXN1YnRpdGxlKSwgX2NsYXNzbmFtZXMpKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuaGVhZGluZ19IZWFkaW5nLnByb3BUeXBlcyA9IGhlYWRpbmdfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hcyxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWzEsIDIsIDMsIDQsIDUsIDZdKSxcbiAgd2VpZ2h0OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ2xpZ2h0JywgJ25vcm1hbCcsICdzZW1pYm9sZCcsICdib2xkJ10pLFxuICBzdWJ0aXRsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgaGVhZGluZzogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgc3BhY2VkOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sXG59KTtcbmhlYWRpbmdfSGVhZGluZy5kZWZhdWx0UHJvcHMgPSBoZWFkaW5nX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnaDEnLFxuICBzaXplOiB1bmRlZmluZWQsXG4gIHdlaWdodDogdW5kZWZpbmVkLFxuICBzdWJ0aXRsZTogZmFsc2UsXG4gIGhlYWRpbmc6IGZhbHNlLFxuICBzcGFjZWQ6IGZhbHNlXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfaGVhZGluZ19oZWFkaW5nID0gKGhlYWRpbmdfSGVhZGluZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2hlYWRpbmcvaW5kZXguanNcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvaGVyby9oZXJvLnNhc3NcbnZhciBoZXJvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvaGVyby9jb21wb25lbnRzL2hlcm8taGVhZC5qc1xuZnVuY3Rpb24gaGVyb19oZWFkX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGhlcm9faGVhZF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgaGVyb19oZWFkX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgaGVyb19oZWFkX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGhlcm9faGVhZF9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaGVyb19oZWFkX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gaGVyb19oZWFkX2V4dGVuZHMoKSB7IGhlcm9faGVhZF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGhlcm9faGVhZF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gaGVyb19oZWFkX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBoZXJvX2hlYWRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGhlcm9faGVhZF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgaGVyb19oZWFkX0hlcm9IZWFkID0gZnVuY3Rpb24gSGVyb0hlYWQoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGhlcm9faGVhZF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgaGVyb19oZWFkX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKShjbGFzc05hbWUsICdoZXJvLWhlYWQnKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuaGVyb19oZWFkX0hlcm9IZWFkLnByb3BUeXBlcyA9IGhlcm9faGVhZF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmhlcm9faGVhZF9IZXJvSGVhZC5kZWZhdWx0UHJvcHMgPSBoZXJvX2hlYWRfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGhlcm9faGVhZCA9IChoZXJvX2hlYWRfSGVyb0hlYWQpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9oZXJvL2NvbXBvbmVudHMvaGVyby1ib2R5LmpzXG5mdW5jdGlvbiBoZXJvX2JvZHlfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gaGVyb19ib2R5X29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBoZXJvX2JvZHlfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBoZXJvX2JvZHlfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgaGVyb19ib2R5X293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBoZXJvX2JvZHlfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBoZXJvX2JvZHlfZXh0ZW5kcygpIHsgaGVyb19ib2R5X2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gaGVyb19ib2R5X2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBoZXJvX2JvZHlfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGhlcm9fYm9keV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaGVyb19ib2R5X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBoZXJvX2JvZHlfSGVyb0JvZHkgPSBmdW5jdGlvbiBIZXJvQm9keShfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gaGVyb19ib2R5X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBoZXJvX2JvZHlfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKGNsYXNzTmFtZSwgJ2hlcm8tYm9keScpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5oZXJvX2JvZHlfSGVyb0JvZHkucHJvcFR5cGVzID0gaGVyb19ib2R5X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuaGVyb19ib2R5X0hlcm9Cb2R5LmRlZmF1bHRQcm9wcyA9IGhlcm9fYm9keV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaGVyb19ib2R5ID0gKGhlcm9fYm9keV9IZXJvQm9keSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2hlcm8vY29tcG9uZW50cy9oZXJvLWZvb3Rlci5qc1xuZnVuY3Rpb24gaGVyb19mb290ZXJfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gaGVyb19mb290ZXJfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGhlcm9fZm9vdGVyX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgaGVyb19mb290ZXJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgaGVyb19mb290ZXJfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGhlcm9fZm9vdGVyX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gaGVyb19mb290ZXJfZXh0ZW5kcygpIHsgaGVyb19mb290ZXJfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBoZXJvX2Zvb3Rlcl9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gaGVyb19mb290ZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGhlcm9fZm9vdGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBoZXJvX2Zvb3Rlcl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgaGVyb19mb290ZXJfSGVyb0Zvb3RlciA9IGZ1bmN0aW9uIEhlcm9Gb290ZXIoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGhlcm9fZm9vdGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBoZXJvX2Zvb3Rlcl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoY2xhc3NOYW1lLCAnaGVyby1mb290JylcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbmhlcm9fZm9vdGVyX0hlcm9Gb290ZXIucHJvcFR5cGVzID0gaGVyb19mb290ZXJfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hc1xufSk7XG5oZXJvX2Zvb3Rlcl9IZXJvRm9vdGVyLmRlZmF1bHRQcm9wcyA9IGhlcm9fZm9vdGVyX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2J1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBoZXJvX2Zvb3RlciA9IChoZXJvX2Zvb3Rlcl9IZXJvRm9vdGVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvaGVyby9oZXJvLmpzXG5mdW5jdGlvbiBoZXJvX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGhlcm9fb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGhlcm9fb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBoZXJvX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGhlcm9fb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGhlcm9fZXh0ZW5kcygpIHsgaGVyb19leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGhlcm9fZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGhlcm9fZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBoZXJvX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBoZXJvX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBoZXJvX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBoZXJvX2NvbG9ycyA9IFtudWxsXS5jb25jYXQoT2JqZWN0LmtleXMoY29uc3RhbnRzLkNPTE9SUykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGNvbnN0YW50cy5DT0xPUlNba2V5XTtcbn0pKTtcblxudmFyIGhlcm9fSGVybyA9IGZ1bmN0aW9uIEhlcm8oX3JlZikge1xuICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgZ3JhZGllbnQgPSBfcmVmLmdyYWRpZW50LFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGhhc05hdmJhciA9IF9yZWYuaGFzTmF2YmFyLFxuICAgICAgcHJvcHMgPSBoZXJvX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJncmFkaWVudFwiLCBcInNpemVcIiwgXCJoYXNOYXZiYXJcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGhlcm9fZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdoZXJvJywgY2xhc3NOYW1lLCAoX2NsYXNzbmFtZXMgPSB7fSwgaGVyb19kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoY29sb3IpLCBjb2xvciksIGhlcm9fZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KHNpemUpLCBzaXplKSwgaGVyb19kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2lzLWJvbGQnLCBncmFkaWVudCksIGhlcm9fZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy1mdWxsaGVpZ2h0LXdpdGgtbmF2YmFyJywgaGFzTmF2YmFyKSwgX2NsYXNzbmFtZXMpKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuaGVyb19IZXJvLkhlYWQgPSBoZXJvX2hlYWQ7XG5oZXJvX0hlcm8uQm9keSA9IGhlcm9fYm9keTtcbmhlcm9fSGVyby5Gb290ZXIgPSBoZXJvX2Zvb3Rlcjtcbmhlcm9fSGVyby5wcm9wVHlwZXMgPSBoZXJvX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXMsXG4gIGNvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihoZXJvX2NvbG9ycyksXG4gIGdyYWRpZW50OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBzaXplOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZScsICdmdWxsaGVpZ2h0J10pLFxuICBoYXNOYXZiYXI6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbn0pO1xuaGVyb19IZXJvLmRlZmF1bHRQcm9wcyA9IGhlcm9fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdzZWN0aW9uJyxcbiAgY29sb3I6IHVuZGVmaW5lZCxcbiAgZ3JhZGllbnQ6IHVuZGVmaW5lZCxcbiAgc2l6ZTogdW5kZWZpbmVkLFxuICBoYXNOYXZiYXI6IHVuZGVmaW5lZFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBoZXJvX2hlcm8gPSAoaGVyb19IZXJvKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvaGVyby9pbmRleC5qc1xuXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9sZXZlbC9sZXZlbC5zYXNzXG52YXIgbGV2ZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9sZXZlbC9jb21wb25lbnRzL2xldmVsLXNpZGUuanNcbmZ1bmN0aW9uIGxldmVsX3NpZGVfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gbGV2ZWxfc2lkZV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbGV2ZWxfc2lkZV9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGxldmVsX3NpZGVfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgbGV2ZWxfc2lkZV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbGV2ZWxfc2lkZV9leHRlbmRzKCkgeyBsZXZlbF9zaWRlX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gbGV2ZWxfc2lkZV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gbGV2ZWxfc2lkZV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGxldmVsX3NpZGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGxldmVsX3NpZGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGxldmVsX3NpZGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGxldmVsX3NpZGVfTGV2ZWxTaWRlID0gZnVuY3Rpb24gTGV2ZWxTaWRlKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgcHJvcHMgPSBsZXZlbF9zaWRlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiYWxpZ25cIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGxldmVsX3NpZGVfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKGNsYXNzTmFtZSwgbGV2ZWxfc2lkZV9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJsZXZlbC1cIi5jb25jYXQoYWxpZ24pLCBhbGlnbikpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5sZXZlbF9zaWRlX0xldmVsU2lkZS5wcm9wVHlwZXMgPSBsZXZlbF9zaWRlX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXMsXG4gIGFsaWduOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmdcbn0pO1xubGV2ZWxfc2lkZV9MZXZlbFNpZGUuZGVmYXVsdFByb3BzID0gbGV2ZWxfc2lkZV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2RpdicsXG4gIGFsaWduOiAnbGVmdCdcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbGV2ZWxfc2lkZSA9IChsZXZlbF9zaWRlX0xldmVsU2lkZSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2xldmVsL2NvbXBvbmVudHMvbGV2ZWwtaXRlbS5qc1xuZnVuY3Rpb24gbGV2ZWxfaXRlbV9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBsZXZlbF9pdGVtX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBsZXZlbF9pdGVtX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgbGV2ZWxfaXRlbV9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBsZXZlbF9pdGVtX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBsZXZlbF9pdGVtX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbGV2ZWxfaXRlbV9leHRlbmRzKCkgeyBsZXZlbF9pdGVtX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gbGV2ZWxfaXRlbV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gbGV2ZWxfaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gbGV2ZWxfaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbGV2ZWxfaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgbGV2ZWxfaXRlbV9MZXZlbEl0ZW0gPSBmdW5jdGlvbiBMZXZlbEl0ZW0oX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGxldmVsX2l0ZW1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGxldmVsX2l0ZW1fZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdsZXZlbC1pdGVtJywgY2xhc3NOYW1lLCB7fSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbmxldmVsX2l0ZW1fTGV2ZWxJdGVtLnByb3BUeXBlcyA9IGxldmVsX2l0ZW1fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hc1xufSk7XG5sZXZlbF9pdGVtX0xldmVsSXRlbS5kZWZhdWx0UHJvcHMgPSBsZXZlbF9pdGVtX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2J1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsZXZlbF9pdGVtID0gKGxldmVsX2l0ZW1fTGV2ZWxJdGVtKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbGV2ZWwvbGV2ZWwuanNcbmZ1bmN0aW9uIGxldmVsX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGxldmVsX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBsZXZlbF9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGxldmVsX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGxldmVsX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBsZXZlbF9leHRlbmRzKCkgeyBsZXZlbF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGxldmVsX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBsZXZlbF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGxldmVsX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBsZXZlbF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbGV2ZWxfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBsZXZlbF9icmVha3BvaW50cyA9IFtudWxsXS5jb25jYXQoT2JqZWN0LmtleXMoY29uc3RhbnRzLkJSRUFLUE9JTlRTKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gY29uc3RhbnRzLkJSRUFLUE9JTlRTW2tleV07XG59KSk7XG5cbnZhciBsZXZlbF9MZXZlbCA9IGZ1bmN0aW9uIExldmVsKF9yZWYpIHtcbiAgdmFyIF9jbGFzc25hbWVzO1xuXG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGJyZWFrcG9pbnQgPSBfcmVmLmJyZWFrcG9pbnQsXG4gICAgICBtb2JpbGUgPSBfcmVmLm1vYmlsZSxcbiAgICAgIHByb3BzID0gbGV2ZWxfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJicmVha3BvaW50XCIsIFwibW9iaWxlXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBsZXZlbF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2xldmVsJywgY2xhc3NOYW1lLCAoX2NsYXNzbmFtZXMgPSB7fSwgbGV2ZWxfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KGJyZWFrcG9pbnQpLCBicmVha3BvaW50KSwgbGV2ZWxfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy1tb2JpbGUnLCBtb2JpbGUpLCBfY2xhc3NuYW1lcykpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5sZXZlbF9MZXZlbC5TaWRlID0gbGV2ZWxfc2lkZTtcbmxldmVsX0xldmVsLkl0ZW0gPSBsZXZlbF9pdGVtO1xubGV2ZWxfTGV2ZWwucHJvcFR5cGVzID0gbGV2ZWxfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgbW9iaWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICBicmVha3BvaW50OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihsZXZlbF9icmVha3BvaW50cyksXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xubGV2ZWxfTGV2ZWwuZGVmYXVsdFByb3BzID0gbGV2ZWxfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgbW9iaWxlOiBmYWxzZSxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgYnJlYWtwb2ludDogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbGV2ZWxfbGV2ZWwgPSAobGV2ZWxfTGV2ZWwpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9sZXZlbC9pbmRleC5qc1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbGlzdC9jb21wb25lbnRzL2xpc3QtaXRlbS5qc1xuZnVuY3Rpb24gbGlzdF9pdGVtX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGxpc3RfaXRlbV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbGlzdF9pdGVtX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgbGlzdF9pdGVtX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGxpc3RfaXRlbV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbGlzdF9pdGVtX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbGlzdF9pdGVtX2V4dGVuZHMoKSB7IGxpc3RfaXRlbV9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGxpc3RfaXRlbV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gbGlzdF9pdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBsaXN0X2l0ZW1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGxpc3RfaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgbGlzdF9pdGVtX0xpc3RJdGVtID0gZnVuY3Rpb24gTGlzdEl0ZW0oX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmUgPSBfcmVmLmFjdGl2ZSxcbiAgICAgIHByb3BzID0gbGlzdF9pdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiYWN0aXZlXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBsaXN0X2l0ZW1fZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdsaXN0LWl0ZW0nLCBjbGFzc05hbWUsIHtcbiAgICAgICdpcy1hY3RpdmUnOiBhY3RpdmVcbiAgICB9KVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxubGlzdF9pdGVtX0xpc3RJdGVtLnByb3BUeXBlcyA9IGxpc3RfaXRlbV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmxpc3RfaXRlbV9MaXN0SXRlbS5kZWZhdWx0UHJvcHMgPSBsaXN0X2l0ZW1fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxpc3RfaXRlbSA9IChsaXN0X2l0ZW1fTGlzdEl0ZW0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9saXN0L2xpc3QuanNcbmZ1bmN0aW9uIGxpc3Rfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gbGlzdF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbGlzdF9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGxpc3RfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgbGlzdF9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbGlzdF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGxpc3RfZXh0ZW5kcygpIHsgbGlzdF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGxpc3RfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGxpc3Rfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGxpc3Rfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGxpc3Rfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxuXG52YXIgbGlzdF9MaXN0ID0gZnVuY3Rpb24gTGlzdChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGhvdmVyYWJsZSA9IF9yZWYuaG92ZXJhYmxlLFxuICAgICAgcHJvcHMgPSBsaXN0X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiaG92ZXJhYmxlXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBsaXN0X2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnbGlzdCcsIGNsYXNzTmFtZSwge1xuICAgICAgJ2lzLWhvdmVyYWJsZSc6IGhvdmVyYWJsZVxuICAgIH0pXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5saXN0X0xpc3QucHJvcFR5cGVzID0gbGlzdF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmxpc3RfTGlzdC5kZWZhdWx0UHJvcHMgPSBsaXN0X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2J1xufSk7XG5saXN0X0xpc3QuSXRlbSA9IGxpc3RfaXRlbTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxpc3QgPSAobGlzdF9MaXN0KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9saXN0L2xpc3Quc2Fzc1xudmFyIGxpc3RfbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2xpc3QvaW5kZXguanNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2xpc3QgPSAobGlzdCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbWVkaWEvbWVkaWEuc2Fzc1xudmFyIG1lZGlhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbWVkaWEvY29tcG9uZW50cy9tZWRpYS1pdGVtLmpzXG5mdW5jdGlvbiBtZWRpYV9pdGVtX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIG1lZGlhX2l0ZW1fb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG1lZGlhX2l0ZW1fb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBtZWRpYV9pdGVtX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG1lZGlhX2l0ZW1fb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG1lZGlhX2l0ZW1fZXh0ZW5kcygpIHsgbWVkaWFfaXRlbV9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIG1lZGlhX2l0ZW1fZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIG1lZGlhX2l0ZW1fZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBtZWRpYV9pdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBtZWRpYV9pdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBtZWRpYV9pdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBtZWRpYV9pdGVtX01lZGlhSXRlbSA9IGZ1bmN0aW9uIE1lZGlhSXRlbShfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHBvc2l0aW9uID0gX3JlZi5wb3NpdGlvbixcbiAgICAgIHByb3BzID0gbWVkaWFfaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcInBvc2l0aW9uXCJdKTtcblxuICB2YXIgcCA9IHBvc2l0aW9uID09PSAnY2VudGVyJyA/ICdjb250ZW50JyA6IHBvc2l0aW9uO1xuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBtZWRpYV9pdGVtX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKShjbGFzc05hbWUsIG1lZGlhX2l0ZW1fZGVmaW5lUHJvcGVydHkoe30sIFwibWVkaWEtXCIuY29uY2F0KHApLCBwKSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbm1lZGlhX2l0ZW1fTWVkaWFJdGVtLnByb3BUeXBlcyA9IG1lZGlhX2l0ZW1fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hcyxcbiAgcG9zaXRpb246IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsnY2VudGVyJywgJ3JpZ2h0JywgJ2xlZnQnXSlcbn0pO1xubWVkaWFfaXRlbV9NZWRpYUl0ZW0uZGVmYXVsdFByb3BzID0gbWVkaWFfaXRlbV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2RpdicsXG4gIHBvc2l0aW9uOiAnY2VudGVyJ1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtZWRpYV9pdGVtID0gKG1lZGlhX2l0ZW1fTWVkaWFJdGVtKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbWVkaWEvY29tcG9uZW50cy9tZWRpYS1jb250ZW50LmpzXG5mdW5jdGlvbiBtZWRpYV9jb250ZW50X293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIG1lZGlhX2NvbnRlbnRfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG1lZGlhX2NvbnRlbnRfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBtZWRpYV9jb250ZW50X2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG1lZGlhX2NvbnRlbnRfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG1lZGlhX2NvbnRlbnRfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBtZWRpYV9jb250ZW50X2V4dGVuZHMoKSB7IG1lZGlhX2NvbnRlbnRfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBtZWRpYV9jb250ZW50X2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBtZWRpYV9jb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBtZWRpYV9jb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBtZWRpYV9jb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBtZWRpYV9jb250ZW50X01lZGlhQ29udGVudCA9IGZ1bmN0aW9uIE1lZGlhQ29udGVudChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gbWVkaWFfY29udGVudF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgbWVkaWFfY29udGVudF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoY2xhc3NOYW1lLCAnY29udGVudCcpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5tZWRpYV9jb250ZW50X01lZGlhQ29udGVudC5wcm9wVHlwZXMgPSBtZWRpYV9jb250ZW50X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xubWVkaWFfY29udGVudF9NZWRpYUNvbnRlbnQuZGVmYXVsdFByb3BzID0gbWVkaWFfY29udGVudF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbWVkaWFfY29udGVudCA9IChtZWRpYV9jb250ZW50X01lZGlhQ29udGVudCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL21lZGlhL21lZGlhLmpzXG5mdW5jdGlvbiBtZWRpYV9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBtZWRpYV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbWVkaWFfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBtZWRpYV9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBtZWRpYV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbWVkaWFfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBtZWRpYV9leHRlbmRzKCkgeyBtZWRpYV9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIG1lZGlhX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBtZWRpYV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gbWVkaWFfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG1lZGlhX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgbWVkaWFfTWVkaWEgPSBmdW5jdGlvbiBNZWRpYShfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gbWVkaWFfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIG1lZGlhX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnbWVkaWEnLCBjbGFzc05hbWUsIHt9KVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxubWVkaWFfTWVkaWEuSXRlbSA9IG1lZGlhX2l0ZW07XG5tZWRpYV9NZWRpYS5Db250ZW50ID0gbWVkaWFfY29udGVudDtcbm1lZGlhX01lZGlhLnByb3BUeXBlcyA9IG1lZGlhX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xubWVkaWFfTWVkaWEuZGVmYXVsdFByb3BzID0gbWVkaWFfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdhcnRpY2xlJ1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtZWRpYV9tZWRpYSA9IChtZWRpYV9NZWRpYSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL21lZGlhL2luZGV4LmpzXG5cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24uc2Fzc1xudmFyIG5vdGlmaWNhdGlvbl9ub3RpZmljYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9ub3RpZmljYXRpb24vbm90aWZpY2F0aW9uLmpzXG5mdW5jdGlvbiBub3RpZmljYXRpb25fb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gbm90aWZpY2F0aW9uX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBub3RpZmljYXRpb25fb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBub3RpZmljYXRpb25fZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgbm90aWZpY2F0aW9uX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBub3RpZmljYXRpb25fZXh0ZW5kcygpIHsgbm90aWZpY2F0aW9uX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gbm90aWZpY2F0aW9uX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBub3RpZmljYXRpb25fZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBub3RpZmljYXRpb25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IG5vdGlmaWNhdGlvbl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbm90aWZpY2F0aW9uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBub3RpZmljYXRpb25fY29sb3JzID0gW251bGxdLmNvbmNhdChPYmplY3Qua2V5cyhjb25zdGFudHMuQ09MT1JTKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gY29uc3RhbnRzLkNPTE9SU1trZXldO1xufSkpO1xuXG52YXIgbm90aWZpY2F0aW9uX05vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIE5vdGlmaWNhdGlvbihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgIHByb3BzID0gbm90aWZpY2F0aW9uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIG5vdGlmaWNhdGlvbl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ25vdGlmaWNhdGlvbicsIG5vdGlmaWNhdGlvbl9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJpcy1cIi5jb25jYXQoY29sb3IpLCBjb2xvciksIGNsYXNzTmFtZSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbm5vdGlmaWNhdGlvbl9Ob3RpZmljYXRpb24ucHJvcFR5cGVzID0gbm90aWZpY2F0aW9uX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXMsXG4gIGNvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihub3RpZmljYXRpb25fY29sb3JzKVxufSk7XG5ub3RpZmljYXRpb25fTm90aWZpY2F0aW9uLmRlZmF1bHRQcm9wcyA9IG5vdGlmaWNhdGlvbl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2RpdicsXG4gIGNvbG9yOiB1bmRlZmluZWRcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19ub3RpZmljYXRpb25fbm90aWZpY2F0aW9uID0gKG5vdGlmaWNhdGlvbl9Ob3RpZmljYXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9ub3RpZmljYXRpb24vaW5kZXguanNcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcHJvZ3Jlc3MvcHJvZ3Jlc3Muc2Fzc1xudmFyIHByb2dyZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcHJvZ3Jlc3MvcHJvZ3Jlc3MuanNcbmZ1bmN0aW9uIHByb2dyZXNzX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIHByb2dyZXNzX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBwcm9ncmVzc19vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHByb2dyZXNzX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IHByb2dyZXNzX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBwcm9ncmVzc19leHRlbmRzKCkgeyBwcm9ncmVzc19leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIHByb2dyZXNzX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBwcm9ncmVzc19kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHByb2dyZXNzX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBwcm9ncmVzc19vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcHJvZ3Jlc3Nfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cbnZhciBwcm9ncmVzc19jb2xvcnMgPSBbbnVsbF0uY29uY2F0KE9iamVjdC5rZXlzKGNvbnN0YW50cy5DT0xPUlMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBjb25zdGFudHMuQ09MT1JTW2tleV07XG59KSk7XG5cbnZhciBwcm9ncmVzc19Qcm9ncmVzcyA9IGZ1bmN0aW9uIFByb2dyZXNzKF9yZWYpIHtcbiAgdmFyIF9jbGFzc25hbWVzO1xuXG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgIG1heCA9IF9yZWYubWF4LFxuICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHByb3BzID0gcHJvZ3Jlc3Nfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCIsIFwidmFsdWVcIiwgXCJtYXhcIiwgXCJjb2xvclwiLCBcInNpemVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIHByb2dyZXNzX2V4dGVuZHMoe1xuICAgIHJlbmRlckFzOiBcInByb2dyZXNzXCJcbiAgfSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgbWF4OiBtYXgsXG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgncHJvZ3Jlc3MnLCBjbGFzc05hbWUsIChfY2xhc3NuYW1lcyA9IHt9LCBwcm9ncmVzc19kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoY29sb3IpLCBjb2xvciksIHByb2dyZXNzX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImlzLVwiLmNvbmNhdChzaXplKSwgc2l6ZSksIF9jbGFzc25hbWVzKSlcbiAgfSkpO1xufTtcblxucHJvZ3Jlc3NfUHJvZ3Jlc3MucHJvcFR5cGVzID0gcHJvZ3Jlc3Nfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICBjb2xvcjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YocHJvZ3Jlc3NfY29sb3JzKSxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXSksXG4gIHZhbHVlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5udW1iZXIsXG4gIG1heDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubnVtYmVyXG59KTtcbnByb2dyZXNzX1Byb2dyZXNzLmRlZmF1bHRQcm9wcyA9IHByb2dyZXNzX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgY29sb3I6IHVuZGVmaW5lZCxcbiAgc2l6ZTogdW5kZWZpbmVkLFxuICB2YWx1ZTogdW5kZWZpbmVkLFxuICBtYXg6IHVuZGVmaW5lZFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwcm9ncmVzc19wcm9ncmVzcyA9IChwcm9ncmVzc19Qcm9ncmVzcyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Byb2dyZXNzL2luZGV4LmpzXG5cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3NlY3Rpb24vc2VjdGlvbi5zYXNzXG52YXIgc2VjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3NlY3Rpb24vc2VjdGlvbi5qc1xuZnVuY3Rpb24gc2VjdGlvbl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBzZWN0aW9uX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBzZWN0aW9uX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgc2VjdGlvbl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBzZWN0aW9uX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBzZWN0aW9uX2V4dGVuZHMoKSB7IHNlY3Rpb25fZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBzZWN0aW9uX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBzZWN0aW9uX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gc2VjdGlvbl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gc2VjdGlvbl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gc2VjdGlvbl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgc2VjdGlvbl9TZWN0aW9uID0gZnVuY3Rpb24gU2VjdGlvbihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICBwcm9wcyA9IHNlY3Rpb25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJzaXplXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBzZWN0aW9uX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnc2VjdGlvbicsIGNsYXNzTmFtZSwgc2VjdGlvbl9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuc2VjdGlvbl9TZWN0aW9uLnByb3BUeXBlcyA9IHNlY3Rpb25fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hcyxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydtZWRpdW0nLCAnbGFyZ2UnXSlcbn0pO1xuc2VjdGlvbl9TZWN0aW9uLmRlZmF1bHRQcm9wcyA9IHNlY3Rpb25fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdzZWN0aW9uJyxcbiAgc2l6ZTogdW5kZWZpbmVkXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNlY3Rpb25fc2VjdGlvbiA9IChzZWN0aW9uX1NlY3Rpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9zZWN0aW9uL2luZGV4LmpzXG5cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3RhYmxlL3RhYmxlLnNhc3NcbnZhciB0YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3RhYmxlL3RhYmxlLmpzXG5mdW5jdGlvbiB0YWJsZV9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiB0YWJsZV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgdGFibGVfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyB0YWJsZV9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyB0YWJsZV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdGFibGVfZXh0ZW5kcygpIHsgdGFibGVfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiB0YWJsZV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gdGFibGVfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiB0YWJsZV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gdGFibGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIHRhYmxlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgdGFibGVfVGFibGUgPSBmdW5jdGlvbiBUYWJsZShfcmVmKSB7XG4gIHZhciBfY2xhc3NuYW1lcztcblxuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgc3RyaXBlZCA9IF9yZWYuc3RyaXBlZCxcbiAgICAgIGJvcmRlcmVkID0gX3JlZi5ib3JkZXJlZCxcbiAgICAgIHByb3BzID0gdGFibGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJzaXplXCIsIFwic3RyaXBlZFwiLCBcImJvcmRlcmVkXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCB0YWJsZV9leHRlbmRzKHtcbiAgICByZW5kZXJBczogXCJ0YWJsZVwiXG4gIH0sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgndGFibGUnLCBjbGFzc05hbWUsIChfY2xhc3NuYW1lcyA9IHt9LCB0YWJsZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpLCB0YWJsZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2lzLWJvcmRlcmVkJywgYm9yZGVyZWQpLCB0YWJsZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2lzLXN0cmlwZWQnLCBzdHJpcGVkKSwgX2NsYXNzbmFtZXMpKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxudGFibGVfVGFibGUucHJvcFR5cGVzID0gdGFibGVfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydmdWxsd2lkdGgnLCAnbmFycm93J10pLFxuICBzdHJpcGVkOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBib3JkZXJlZDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbFxufSk7XG50YWJsZV9UYWJsZS5kZWZhdWx0UHJvcHMgPSB0YWJsZV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICBzaXplOiAnZnVsbHdpZHRoJyxcbiAgc3RyaXBlZDogdHJ1ZSxcbiAgYm9yZGVyZWQ6IGZhbHNlXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRhYmxlX3RhYmxlID0gKHRhYmxlX1RhYmxlKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdGFibGUvaW5kZXguanNcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdGFnL3RhZy5zYXNzXG52YXIgdGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdGFnL2NvbXBvbmVudHMvdGFnLWdyb3VwLmpzXG5mdW5jdGlvbiB0YWdfZ3JvdXBfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gdGFnX2dyb3VwX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyB0YWdfZ3JvdXBfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyB0YWdfZ3JvdXBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgdGFnX2dyb3VwX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiB0YWdfZ3JvdXBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiB0YWdfZ3JvdXBfZXh0ZW5kcygpIHsgdGFnX2dyb3VwX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gdGFnX2dyb3VwX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiB0YWdfZ3JvdXBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHRhZ19ncm91cF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdGFnX2dyb3VwX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgdGFnX2dyb3VwX1RhZ0dyb3VwID0gZnVuY3Rpb24gVGFnR3JvdXAoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBnYXBsZXNzID0gX3JlZi5nYXBsZXNzLFxuICAgICAgcHJvcHMgPSB0YWdfZ3JvdXBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJnYXBsZXNzXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCB0YWdfZ3JvdXBfZXh0ZW5kcyh7XG4gICAgcmVuZGVyQXM6IFwic3BhblwiXG4gIH0sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgndGFncycsIGNsYXNzTmFtZSwge1xuICAgICAgJ2hhcy1hZGRvbnMnOiBnYXBsZXNzXG4gICAgfSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbnRhZ19ncm91cF9UYWdHcm91cC5wcm9wVHlwZXMgPSB0YWdfZ3JvdXBfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgZ2FwbGVzczogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbFxufSk7XG50YWdfZ3JvdXBfVGFnR3JvdXAuZGVmYXVsdFByb3BzID0gdGFnX2dyb3VwX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIGdhcGxlc3M6IGZhbHNlXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRhZ19ncm91cCA9ICh0YWdfZ3JvdXBfVGFnR3JvdXApO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90YWcvdGFnLmpzXG5mdW5jdGlvbiB0YWdfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gdGFnX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyB0YWdfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyB0YWdfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgdGFnX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiB0YWdfZXh0ZW5kcygpIHsgdGFnX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gdGFnX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiB0YWdfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiB0YWdfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHRhZ19vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdGFnX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cblxudmFyIHRhZ19jb2xvcnMgPSBbbnVsbF0uY29uY2F0KE9iamVjdC5rZXlzKGNvbnN0YW50cy5DT0xPUlMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBjb25zdGFudHMuQ09MT1JTW2tleV07XG59KSk7XG5cbnZhciB0YWdfVGFnID0gZnVuY3Rpb24gVGFnKF9yZWYpIHtcbiAgdmFyIF9jbGFzc25hbWVzO1xuXG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICByb3VuZGVkID0gX3JlZi5yb3VuZGVkLFxuICAgICAgcmVtb3ZlID0gX3JlZi5yZW1vdmUsXG4gICAgICBwcm9wcyA9IHRhZ19vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImNvbG9yXCIsIFwic2l6ZVwiLCBcInJvdW5kZWRcIiwgXCJyZW1vdmVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIHRhZ19leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ3RhZycsIGNsYXNzTmFtZSwgKF9jbGFzc25hbWVzID0ge30sIHRhZ19kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpLCB0YWdfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KGNvbG9yKSwgY29sb3IpLCB0YWdfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy1yb3VuZGVkJywgcm91bmRlZCksIHRhZ19kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2lzLWRlbGV0ZScsIHJlbW92ZSksIF9jbGFzc25hbWVzKSlcbiAgfSksICFyZW1vdmUgJiYgY2hpbGRyZW4pO1xufTtcblxudGFnX1RhZy5Hcm91cCA9IHRhZ19ncm91cDtcbnRhZ19UYWcucHJvcFR5cGVzID0gdGFnX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIGNvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZih0YWdfY29sb3JzKSxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydtZWRpdW0nLCAnbGFyZ2UnXSksXG4gIHJvdW5kZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHJlbW92ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hc1xufSk7XG50YWdfVGFnLmRlZmF1bHRQcm9wcyA9IHRhZ19vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICBzaXplOiB1bmRlZmluZWQsXG4gIHJvdW5kZWQ6IGZhbHNlLFxuICByZW1vdmU6IGZhbHNlLFxuICByZW5kZXJBczogJ3NwYW4nXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRhZ190YWcgPSAodGFnX1RhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3RhZy9pbmRleC5qc1xuXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90aWxlL3RpbGUuc2Fzc1xudmFyIHRpbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90aWxlL3RpbGUuanNcbmZ1bmN0aW9uIHRpbGVfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gdGlsZV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgdGlsZV9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHRpbGVfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgdGlsZV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdGlsZV9leHRlbmRzKCkgeyB0aWxlX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gdGlsZV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gdGlsZV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHRpbGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHRpbGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIHRpbGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIHRpbGVfY29sb3JzID0gW251bGxdLmNvbmNhdChPYmplY3Qua2V5cyhjb25zdGFudHMuQ09MT1JTKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gY29uc3RhbnRzLkNPTE9SU1trZXldO1xufSkpO1xuXG52YXIgdGlsZV9UaWxlID0gZnVuY3Rpb24gVGlsZShfcmVmKSB7XG4gIHZhciBfY2xhc3NuYW1lcztcblxuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBraW5kID0gX3JlZi5raW5kLFxuICAgICAgdmVydGljYWwgPSBfcmVmLnZlcnRpY2FsLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgIG5vdGlmaWNhdGlvbiA9IF9yZWYubm90aWZpY2F0aW9uLFxuICAgICAgcHJvcHMgPSB0aWxlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwia2luZFwiLCBcInZlcnRpY2FsXCIsIFwic2l6ZVwiLCBcImNvbG9yXCIsIFwibm90aWZpY2F0aW9uXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCB0aWxlX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgndGlsZScsIGNsYXNzTmFtZSwgKF9jbGFzc25hbWVzID0ge1xuICAgICAgbm90aWZpY2F0aW9uOiBub3RpZmljYXRpb25cbiAgICB9LCB0aWxlX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImlzLVwiLmNvbmNhdChraW5kKSwga2luZCksIHRpbGVfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KHNpemUpLCBzaXplKSwgdGlsZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoY29sb3IpLCBjb2xvciksIHRpbGVfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsICdpcy12ZXJ0aWNhbCcsIHZlcnRpY2FsKSwgX2NsYXNzbmFtZXMpKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxudGlsZV9UaWxlLnByb3BUeXBlcyA9IHRpbGVfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hcyxcbiAga2luZDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydhbmNlc3RvcicsICdwYXJlbnQnLCAnY2hpbGQnXSksXG4gIHZlcnRpY2FsOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBzaXplOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl0pLFxuICBjb2xvcjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YodGlsZV9jb2xvcnMpLFxuICBub3RpZmljYXRpb246IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbn0pO1xudGlsZV9UaWxlLmRlZmF1bHRQcm9wcyA9IHRpbGVfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnLFxuICBraW5kOiB1bmRlZmluZWQsXG4gIHZlcnRpY2FsOiBmYWxzZSxcbiAgc2l6ZTogdW5kZWZpbmVkLFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICBub3RpZmljYXRpb246IGZhbHNlXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRpbGVfdGlsZSA9ICh0aWxlX1RpbGUpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90aWxlL2luZGV4LmpzXG5cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL21vZGFsL21vZGFsLnNhc3NcbnZhciBtb2RhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwicmVhY3QtZG9tXCJcbnZhciBleHRlcm5hbF9yZWFjdF9kb21fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBleHRlcm5hbF9yZWFjdF9kb21fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZXh0ZXJuYWxfcmVhY3RfZG9tXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbW9kYWwvY29tcG9uZW50cy9jb250ZW50LmpzXG5mdW5jdGlvbiBjb21wb25lbnRzX2NvbnRlbnRfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19jb250ZW50X29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBjb21wb25lbnRzX2NvbnRlbnRfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjb21wb25lbnRzX2NvbnRlbnRfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgY29tcG9uZW50c19jb250ZW50X293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2NvbnRlbnRfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2NvbnRlbnRfZXh0ZW5kcygpIHsgY29tcG9uZW50c19jb250ZW50X2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gY29tcG9uZW50c19jb250ZW50X2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2NvbnRlbnRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGNvbXBvbmVudHNfY29udGVudF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19jb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBjb250ZW50X01vZGFsQ29udGVudCA9IGZ1bmN0aW9uIE1vZGFsQ29udGVudChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gY29tcG9uZW50c19jb250ZW50X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjb21wb25lbnRzX2NvbnRlbnRfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdtb2RhbC1jb250ZW50JywgY2xhc3NOYW1lKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuY29udGVudF9Nb2RhbENvbnRlbnQucHJvcFR5cGVzID0gY29tcG9uZW50c19jb250ZW50X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuY29udGVudF9Nb2RhbENvbnRlbnQuZGVmYXVsdFByb3BzID0gY29tcG9uZW50c19jb250ZW50X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2J1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2NvbnRlbnQgPSAoY29udGVudF9Nb2RhbENvbnRlbnQpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9tb2RhbC9jb21wb25lbnRzL2NhcmQvaGVhZC5qc1xuZnVuY3Rpb24gaGVhZF9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBoZWFkX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBoZWFkX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgaGVhZF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBoZWFkX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBoZWFkX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gaGVhZF9leHRlbmRzKCkgeyBoZWFkX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gaGVhZF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gaGVhZF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gaGVhZF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaGVhZF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgaGVhZF9Nb2RhbENhcmRIZWFkID0gZnVuY3Rpb24gTW9kYWxDYXJkSGVhZChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHNob3dDbG9zZSA9IF9yZWYuc2hvd0Nsb3NlLFxuICAgICAgb25DbG9zZSA9IF9yZWYub25DbG9zZSxcbiAgICAgIHByb3BzID0gaGVhZF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcInNob3dDbG9zZVwiLCBcIm9uQ2xvc2VcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGhlYWRfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdtb2RhbC1jYXJkLWhlYWQnLCBjbGFzc05hbWUpXG4gIH0pLCBjaGlsZHJlbiwgc2hvd0Nsb3NlICYmIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfYnV0dG9uX2J1dHRvbiwge1xuICAgIHJlbW92ZTogdHJ1ZSxcbiAgICBvbkNsaWNrOiBvbkNsb3NlXG4gIH0pKTtcbn07XG5cbmhlYWRfTW9kYWxDYXJkSGVhZC5wcm9wVHlwZXMgPSBoZWFkX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHNob3dDbG9zZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgb25DbG9zZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuZnVuY1xufSk7XG5oZWFkX01vZGFsQ2FyZEhlYWQuZGVmYXVsdFByb3BzID0gaGVhZF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICBzaG93Q2xvc2U6IHRydWUsXG4gIG9uQ2xvc2U6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdoZWFkZXInXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGhlYWQgPSAoaGVhZF9Nb2RhbENhcmRIZWFkKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbW9kYWwvY29tcG9uZW50cy9jYXJkL2JvZHkuanNcbmZ1bmN0aW9uIGJvZHlfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gYm9keV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgYm9keV9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGJvZHlfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgYm9keV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gYm9keV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGJvZHlfZXh0ZW5kcygpIHsgYm9keV9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGJvZHlfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGJvZHlfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGJvZHlfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGJvZHlfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGJvZHlfTW9kYWxDYXJkQm9keSA9IGZ1bmN0aW9uIE1vZGFsQ2FyZEJvZHkoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGJvZHlfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGJvZHlfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdtb2RhbC1jYXJkLWJvZHknLCBjbGFzc05hbWUpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5ib2R5X01vZGFsQ2FyZEJvZHkucHJvcFR5cGVzID0gYm9keV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmJvZHlfTW9kYWxDYXJkQm9keS5kZWZhdWx0UHJvcHMgPSBib2R5X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnc2VjdGlvbidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYm9keSA9IChib2R5X01vZGFsQ2FyZEJvZHkpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9tb2RhbC9jb21wb25lbnRzL2NhcmQvZm9vdC5qc1xuZnVuY3Rpb24gZm9vdF9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBmb290X29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBmb290X293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZm9vdF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBmb290X293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBmb290X2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gZm9vdF9leHRlbmRzKCkgeyBmb290X2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gZm9vdF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gZm9vdF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gZm9vdF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZm9vdF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxudmFyIGZvb3RfTW9kYWxDYXJkRm9vdCA9IGZ1bmN0aW9uIE1vZGFsQ2FyZEZvb3QoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGZvb3Rfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGZvb3RfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdtb2RhbC1jYXJkLWZvb3QnLCBjbGFzc05hbWUpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5mb290X01vZGFsQ2FyZEZvb3QucHJvcFR5cGVzID0gZm9vdF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pXG59KTtcbmZvb3RfTW9kYWxDYXJkRm9vdC5kZWZhdWx0UHJvcHMgPSBmb290X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZm9vdGVyJ1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmb290ID0gKGZvb3RfTW9kYWxDYXJkRm9vdCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL21vZGFsL2NvbXBvbmVudHMvY2FyZC90aXRsZS5qc1xuZnVuY3Rpb24gdGl0bGVfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gdGl0bGVfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IHRpdGxlX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgdGl0bGVfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgdGl0bGVfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIHRpdGxlX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gdGl0bGVfZXh0ZW5kcygpIHsgdGl0bGVfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiB0aXRsZV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gdGl0bGVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHRpdGxlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiB0aXRsZV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxudmFyIHRpdGxlX01vZGFsQ2FyZFRpdGxlID0gZnVuY3Rpb24gTW9kYWxDYXJkVGl0bGUoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IHRpdGxlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCB0aXRsZV9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ21vZGFsLWNhcmQtdGl0bGUnLCBjbGFzc05hbWUpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG50aXRsZV9Nb2RhbENhcmRUaXRsZS5wcm9wVHlwZXMgPSB0aXRsZV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pXG59KTtcbnRpdGxlX01vZGFsQ2FyZFRpdGxlLmRlZmF1bHRQcm9wcyA9IHRpdGxlX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAncCdcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2FyZF90aXRsZSA9ICh0aXRsZV9Nb2RhbENhcmRUaXRsZSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL21vZGFsL2NvbXBvbmVudHMvY2FyZC9jYXJkLmpzXG5mdW5jdGlvbiBjYXJkX2NhcmRfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gY2FyZF9jYXJkX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBjYXJkX2NhcmRfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjYXJkX2NhcmRfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgY2FyZF9jYXJkX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjYXJkX2NhcmRfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBjYXJkX2NhcmRfZXh0ZW5kcygpIHsgY2FyZF9jYXJkX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gY2FyZF9jYXJkX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBjYXJkX2NhcmRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGNhcmRfY2FyZF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY2FyZF9jYXJkX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBjYXJkX01vZGFsQ2FyZCA9IGZ1bmN0aW9uIE1vZGFsQ2FyZChfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIG9uQ2xvc2UgPSBfcmVmLm9uQ2xvc2UsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBwcm9wcyA9IGNhcmRfY2FyZF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIiwgXCJvbkNsb3NlXCIsIFwiY2hpbGRyZW5cIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGNhcmRfY2FyZF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ21vZGFsLWNhcmQnLCBjbGFzc05hbWUpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5jYXJkX01vZGFsQ2FyZC5IZWFkID0gaGVhZDtcbmNhcmRfTW9kYWxDYXJkLkJvZHkgPSBib2R5O1xuY2FyZF9Nb2RhbENhcmQuRm9vdCA9IGZvb3Q7XG5jYXJkX01vZGFsQ2FyZC5UaXRsZSA9IGNhcmRfdGl0bGU7XG5jYXJkX01vZGFsQ2FyZC5wcm9wVHlwZXMgPSBjYXJkX2NhcmRfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgb25DbG9zZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuZnVuY1xufSk7XG5jYXJkX01vZGFsQ2FyZC5kZWZhdWx0UHJvcHMgPSBjYXJkX2NhcmRfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgb25DbG9zZTogdW5kZWZpbmVkXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfY2FyZF9jYXJkID0gKGNhcmRfTW9kYWxDYXJkKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbW9kYWwvY29tcG9uZW50cy9jYXJkL2luZGV4LmpzXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfY2FyZCA9IChjb21wb25lbnRzX2NhcmRfY2FyZCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL21vZGFsL21vZGFsLmpzXG5mdW5jdGlvbiBtb2RhbF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBtb2RhbF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgbW9kYWxfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIG1vZGFsX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIG1vZGFsX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gbW9kYWxfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIG1vZGFsX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgbW9kYWxfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIG1vZGFsX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIG1vZGFsX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAobW9kYWxfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBtb2RhbF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gbW9kYWxfZ2V0UHJvdG90eXBlT2YobykgeyBtb2RhbF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBtb2RhbF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBtb2RhbF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBtb2RhbF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBtb2RhbF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gbW9kYWxfc2V0UHJvdG90eXBlT2YobywgcCkgeyBtb2RhbF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gbW9kYWxfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gbW9kYWxfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cblxuXG5cblxuXG52YXIgS0VZQ09ERVMgPSB7XG4gIEVTQ0FQRTogMjdcbn07XG5cbnZhciBtb2RhbF9Nb2RhbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgbW9kYWxfaW5oZXJpdHMoTW9kYWwsIF9QdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNb2RhbChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIG1vZGFsX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsKTtcblxuICAgIF90aGlzID0gbW9kYWxfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBtb2RhbF9nZXRQcm90b3R5cGVPZihNb2RhbCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgbW9kYWxfZGVmaW5lUHJvcGVydHkobW9kYWxfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJwb3J0YWxFbGVtZW50XCIsIG51bGwpO1xuXG4gICAgbW9kYWxfZGVmaW5lUHJvcGVydHkobW9kYWxfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXREb2N1bWVudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmRvY3VtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuXG4gICAgbW9kYWxfZGVmaW5lUHJvcGVydHkobW9kYWxfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoYW5kbGVLZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFUy5FU0NBUEUgJiYgX3RoaXMucHJvcHMuc2hvdykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIG1vZGFsX2NyZWF0ZUNsYXNzKE1vZGFsLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBjbG9zZU9uRXNjID0gdGhpcy5wcm9wcy5jbG9zZU9uRXNjO1xuICAgICAgdmFyIGRvYyA9IHRoaXMuZ2V0RG9jdW1lbnQoKTtcbiAgICAgIHRoaXMucG9ydGFsRWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMucG9ydGFsRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ21vZGFsLWNvbnRhaW5lcicpO1xuICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3J0YWxFbGVtZW50KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgIGlmIChjbG9zZU9uRXNjKSB7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHZhciBkb2MgPSB0aGlzLmdldERvY3VtZW50KCk7XG4gICAgICB2YXIgY2xvc2VPbkVzYyA9IHRoaXMucHJvcHMuY2xvc2VPbkVzYztcblxuICAgICAgaWYgKGNsb3NlT25Fc2MgJiYgZG9jKSB7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duKTtcbiAgICAgIH0gLy8gSUUxMSBmaXhcblxuXG4gICAgICB0aGlzLnBvcnRhbEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcnRhbEVsZW1lbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkb21SZWYgPSBfdGhpcyRwcm9wcy5kb21SZWYsXG4gICAgICAgICAgY2xvc2VPbkJsdXIgPSBfdGhpcyRwcm9wcy5jbG9zZU9uQmx1cixcbiAgICAgICAgICBzaG93ID0gX3RoaXMkcHJvcHMuc2hvdyxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWU7XG5cbiAgICAgIGlmICghdGhpcy5nZXREb2N1bWVudCgpIHx8ICF0aGlzLnBvcnRhbEVsZW1lbnQgfHwgIXNob3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgaXNDYXJkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpc0NhcmQgPSBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuQ2hpbGRyZW4ub25seShjaGlsZHJlbikudHlwZS50b1N0cmluZygpLmluZGV4T2YoJ01vZGFsQ2FyZCcpICE9PSAtMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaXNDYXJkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG93Q2xvc2UgPSAhaXNDYXJkICYmIHRoaXMucHJvcHMuc2hvd0Nsb3NlO1xuXG4gICAgICBpZiAoaXNDYXJkKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgICAgICAgIG9uQ2xvc2U6IHRoaXMucHJvcHMub25DbG9zZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RvbV9kZWZhdWx0LmEuY3JlYXRlUG9ydGFsKGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgcmVmOiBkb21SZWYsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ21vZGFsJywgY2xhc3NOYW1lLCB7XG4gICAgICAgICAgJ2lzLWFjdGl2ZSc6IHNob3dcbiAgICAgICAgfSlcbiAgICAgIH0sIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgcm9sZTogXCJwcmVzZW50YXRpb25cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1vZGFsLWJhY2tncm91bmRcIixcbiAgICAgICAgb25DbGljazogY2xvc2VPbkJsdXIgPyB0aGlzLnByb3BzLm9uQ2xvc2UgOiB1bmRlZmluZWRcbiAgICAgIH0pLCBjaGlsZHJlbiwgc2hvd0Nsb3NlICYmIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgb25DbGljazogdGhpcy5wcm9wcy5vbkNsb3NlLFxuICAgICAgICBjbGFzc05hbWU6IFwibW9kYWwtY2xvc2UgaXMtbGFyZ2VcIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IFwiY2xvc2VcIlxuICAgICAgfSkpLCB0aGlzLnBvcnRhbEVsZW1lbnQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNb2RhbDtcbn0oZXh0ZXJuYWxfcmVhY3RfW1wiUHVyZUNvbXBvbmVudFwiXSk7XG5cbm1vZGFsX01vZGFsLkNvbnRlbnQgPSBjb21wb25lbnRzX2NvbnRlbnQ7XG5tb2RhbF9Nb2RhbC5DYXJkID0gY29tcG9uZW50c19jYXJkO1xubW9kYWxfTW9kYWwucHJvcFR5cGVzID0ge1xuICBzaG93OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLmlzUmVxdWlyZWQsXG4gIG9uQ2xvc2U6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmZ1bmMuaXNSZXF1aXJlZCxcbiAgY2xvc2VPbkVzYzogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgY2xvc2VPbkJsdXI6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHNob3dDbG9zZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUuaXNSZXF1aXJlZCxcbiAgZG9jdW1lbnQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9iamVjdCxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIGRvbVJlZjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub2JqZWN0XG59O1xubW9kYWxfTW9kYWwuZGVmYXVsdFByb3BzID0ge1xuICBjbG9zZU9uRXNjOiB0cnVlLFxuICBzaG93Q2xvc2U6IHRydWUsXG4gIGNsb3NlT25CbHVyOiBmYWxzZSxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIGRvbVJlZjogZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZVJlZigpLFxuICAvLyBFeHBvc2UgbW91bnQgcG9pbnQgZm9yIHRlc3RpbmdcbiAgZG9jdW1lbnQ6IHVuZGVmaW5lZFxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1vZGFsX21vZGFsID0gKG1vZGFsX01vZGFsKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbW9kYWwvaW5kZXguanNcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZHJvcGRvd24vZHJvcGRvd24uc2Fzc1xudmFyIGRyb3Bkb3duX2Ryb3Bkb3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZHJvcGRvd24vY29tcG9uZW50cy9pdGVtLmpzXG5mdW5jdGlvbiBpdGVtX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGl0ZW1fb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGl0ZW1fb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBpdGVtX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGl0ZW1fb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGl0ZW1fZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBpdGVtX2V4dGVuZHMoKSB7IGl0ZW1fZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBpdGVtX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBpdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBpdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBpdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgaXRlbV9Ecm9wZG93bkl0ZW0gPSBmdW5jdGlvbiBEcm9wZG93bkl0ZW0oX3JlZikge1xuICB2YXIgYWN0aXZlID0gX3JlZi5hY3RpdmUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJhY3RpdmVcIiwgXCJjaGlsZHJlblwiLCBcInZhbHVlXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBpdGVtX2V4dGVuZHMoe1xuICAgIHRpdGxlOiB2YWx1ZVxuICB9LCBwcm9wcywge1xuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKShjbGFzc05hbWUsICdkcm9wZG93bi1pdGVtJywge1xuICAgICAgJ2lzLWFjdGl2ZSc6IGFjdGl2ZVxuICAgIH0pXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5pdGVtX0Ryb3Bkb3duSXRlbS5wcm9wVHlwZXMgPSBpdGVtX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBhY3RpdmU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICB2YWx1ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYW55LmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmZ1bmNcbn0pO1xuaXRlbV9Ecm9wZG93bkl0ZW0uZGVmYXVsdFByb3BzID0gaXRlbV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgYWN0aXZlOiBmYWxzZSxcbiAgb25DbGljazogdW5kZWZpbmVkLFxuICBjaGlsZHJlbjogbnVsbFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2l0ZW0gPSAoaXRlbV9Ecm9wZG93bkl0ZW0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9kcm9wZG93bi9jb21wb25lbnRzL2RpdmlkZXIuanNcbmZ1bmN0aW9uIGRpdmlkZXJfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gZGl2aWRlcl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgZGl2aWRlcl9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRpdmlkZXJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgZGl2aWRlcl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZGl2aWRlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGRpdmlkZXJfZXh0ZW5kcygpIHsgZGl2aWRlcl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGRpdmlkZXJfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGRpdmlkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGRpdmlkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGRpdmlkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cbnZhciBkaXZpZGVyX0Ryb3Bkb3duRGl2aWRlciA9IGZ1bmN0aW9uIERyb3Bkb3duRGl2aWRlcihfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gZGl2aWRlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGRpdmlkZXJfZXh0ZW5kcyh7XG4gICAgcmVuZGVyQXM6IFwiaHJcIlxuICB9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2Ryb3Bkb3duLWRpdmlkZXInLCBjbGFzc05hbWUpXG4gIH0pKTtcbn07XG5cbmRpdmlkZXJfRHJvcGRvd25EaXZpZGVyLnByb3BUeXBlcyA9IGRpdmlkZXJfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nXG59KTtcbmRpdmlkZXJfRHJvcGRvd25EaXZpZGVyLmRlZmF1bHRQcm9wcyA9IGRpdmlkZXJfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRpdmlkZXIgPSAoZGl2aWRlcl9Ecm9wZG93bkRpdmlkZXIpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2ljb24vaWNvbi5zYXNzXG52YXIgaWNvbl9pY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvaWNvbi9pY29uLmpzXG5mdW5jdGlvbiBpY29uX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGljb25fb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGljb25fb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBpY29uX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGljb25fb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGljb25fZXh0ZW5kcygpIHsgaWNvbl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGljb25fZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGljb25fZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBpY29uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBpY29uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBpY29uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgaWNvbl9jb2xvcnMgPSBbbnVsbF0uY29uY2F0KE9iamVjdC5rZXlzKGNvbnN0YW50cy5DT0xPUlMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBjb25zdGFudHMuQ09MT1JTW2tleV07XG59KSk7XG5cbnZhciBpY29uX0ljb24gPSBmdW5jdGlvbiBJY29uKF9yZWYpIHtcbiAgdmFyIF9jbGFzc25hbWVzO1xuXG4gIHZhciBpY29uID0gX3JlZi5pY29uLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcHJvcHMgPSBpY29uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImljb25cIiwgXCJzaXplXCIsIFwiY29sb3JcIiwgXCJjbGFzc05hbWVcIiwgXCJhbGlnblwiLCBcImNoaWxkcmVuXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBpY29uX2V4dGVuZHMoe1xuICAgIHJlbmRlckFzOiBcInNwYW5cIlxuICB9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ2ljb24nLCBjbGFzc05hbWUsIChfY2xhc3NuYW1lcyA9IHt9LCBpY29uX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImlzLVwiLmNvbmNhdChzaXplKSwgc2l6ZSksIGljb25fZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KGFsaWduKSwgYWxpZ24pLCBpY29uX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImhhcy10ZXh0LVwiLmNvbmNhdChjb2xvciksIGNvbG9yKSwgX2NsYXNzbmFtZXMpKVxuICB9KSwgY2hpbGRyZW4gfHwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJpXCIsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdyYmMnLCBpY29uX2RlZmluZVByb3BlcnR5KHt9LCBcInJiYy1cIi5jb25jYXQoaWNvbiksIGljb24pKVxuICB9KSk7XG59O1xuXG5pY29uX0ljb24ucHJvcFR5cGVzID0gaWNvbl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgaWNvbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuZWxlbWVudCxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJywgJ2F1dG8nXSksXG4gIGFsaWduOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ2xlZnQnLCAncmlnaHQnXSksXG4gIGNvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihpY29uX2NvbG9ycylcbn0pO1xuaWNvbl9JY29uLmRlZmF1bHRQcm9wcyA9IGljb25fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICBzaXplOiB1bmRlZmluZWQsXG4gIGNvbG9yOiB1bmRlZmluZWQsXG4gIGNoaWxkcmVuOiBudWxsLFxuICBhbGlnbjogdW5kZWZpbmVkLFxuICBpY29uOiB1bmRlZmluZWRcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19pY29uX2ljb24gPSAoaWNvbl9JY29uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvaWNvbi9pbmRleC5qc1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZHJvcGRvd24vZHJvcGRvd24uanNcbmZ1bmN0aW9uIGRyb3Bkb3duX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGRyb3Bkb3duX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBkcm9wZG93bl9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRyb3Bkb3duX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGRyb3Bkb3duX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBkcm9wZG93bl90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBkcm9wZG93bl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgZHJvcGRvd25fdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIGRyb3Bkb3duX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGRyb3Bkb3duX2V4dGVuZHMoKSB7IGRyb3Bkb3duX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gZHJvcGRvd25fZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGRyb3Bkb3duX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBkcm9wZG93bl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZHJvcGRvd25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGRyb3Bkb3duX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gZHJvcGRvd25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGRyb3Bkb3duX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZHJvcGRvd25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRyb3Bkb3duX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIGRyb3Bkb3duX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoZHJvcGRvd25fdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBkcm9wZG93bl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gZHJvcGRvd25fZ2V0UHJvdG90eXBlT2YobykgeyBkcm9wZG93bl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBkcm9wZG93bl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBkcm9wZG93bl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBkcm9wZG93bl9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBkcm9wZG93bl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gZHJvcGRvd25fc2V0UHJvdG90eXBlT2YobywgcCkgeyBkcm9wZG93bl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gZHJvcGRvd25fc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gZHJvcGRvd25fZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBkcm9wZG93bl9jb2xvcnMgPSBbbnVsbF0uY29uY2F0KE9iamVjdC52YWx1ZXMoY29uc3RhbnRzLkNPTE9SUykpO1xuXG52YXIgZHJvcGRvd25fRHJvcGRvd24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIGRyb3Bkb3duX2luaGVyaXRzKERyb3Bkb3duLCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRHJvcGRvd24ocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBkcm9wZG93bl9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bik7XG5cbiAgICBfdGhpcyA9IGRyb3Bkb3duX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgZHJvcGRvd25fZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24pLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIGRyb3Bkb3duX2RlZmluZVByb3BlcnR5KGRyb3Bkb3duX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2xvc2VcIiwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgLy8gSURLIHlldCBob3cgdG8gdGVzdCB1c2luZyB0aGUgcmVmIGluIGVuemltZVxuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICBpZiAoX3RoaXMucHJvcHMuaG92ZXJhYmxlIHx8IGV2dCAmJiBfdGhpcy5kb21SZWYgJiYgX3RoaXMuZG9tUmVmLmN1cnJlbnQgJiYgX3RoaXMuZG9tUmVmLmN1cnJlbnQuY29udGFpbnMoZXZ0LnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuZG9tUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIG9wZW46IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZHJvcGRvd25fZGVmaW5lUHJvcGVydHkoZHJvcGRvd25fYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0b2dnbGVcIiwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLmhvdmVyYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldnQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBvcGVuID0gX3JlZi5vcGVuO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wZW46ICFvcGVuXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRyb3Bkb3duX2RlZmluZVByb3BlcnR5KGRyb3Bkb3duX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2VsZWN0XCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmNsb3NlT25TZWxlY3QpIHtcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgX3RoaXMuZG9tUmVmID0gcHJvcHMuZG9tUmVmIHx8IGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVSZWYoKTtcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG9wZW46IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBkcm9wZG93bl9jcmVhdGVDbGFzcyhEcm9wZG93biwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY2xvc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbG9zZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICB2YWx1ZSA9IF90aGlzJHByb3BzLnZhbHVlLFxuICAgICAgICAgIGNvbG9yID0gX3RoaXMkcHJvcHMuY29sb3IsXG4gICAgICAgICAgYWxpZ24gPSBfdGhpcyRwcm9wcy5hbGlnbixcbiAgICAgICAgICByaWdodCA9IF90aGlzJHByb3BzLnJpZ2h0LFxuICAgICAgICAgIHVwID0gX3RoaXMkcHJvcHMudXAsXG4gICAgICAgICAgaG92ZXJhYmxlID0gX3RoaXMkcHJvcHMuaG92ZXJhYmxlLFxuICAgICAgICAgIGxhYmVsID0gX3RoaXMkcHJvcHMubGFiZWwsXG4gICAgICAgICAgb25DaGFuZ2UgPSBfdGhpcyRwcm9wcy5vbkNoYW5nZSxcbiAgICAgICAgICBjbG9zZU9uU2VsZWN0ID0gX3RoaXMkcHJvcHMuY2xvc2VPblNlbGVjdCxcbiAgICAgICAgICBwcm9wcyA9IGRyb3Bkb3duX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjbGFzc05hbWVcIiwgXCJjaGlsZHJlblwiLCBcInZhbHVlXCIsIFwiY29sb3JcIiwgXCJhbGlnblwiLCBcInJpZ2h0XCIsIFwidXBcIiwgXCJob3ZlcmFibGVcIiwgXCJsYWJlbFwiLCBcIm9uQ2hhbmdlXCIsIFwiY2xvc2VPblNlbGVjdFwiXSk7XG5cbiAgICAgIHZhciBjdXJyZW50ID0gbGFiZWw7XG4gICAgICB2YXIgY2hpbGRyZW5BcnJheSA9IGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gY29tcG9uZW50c19pdGVtICYmIChpID09PSAwICYmICFsYWJlbCB8fCBjaGlsZC5wcm9wcy52YWx1ZSA9PT0gdmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudCA9IGNoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkLnR5cGUgPT09IGNvbXBvbmVudHNfaXRlbSA/IHtcbiAgICAgICAgICBhY3RpdmU6IGNoaWxkLnByb3BzLnZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICBvbkNsaWNrOiBfdGhpczIuc2VsZWN0KGNoaWxkLnByb3BzLnZhbHVlKVxuICAgICAgICB9IDoge30pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oJ3JlYWN0LWJ1bG1hLWNvbXBvbmVudHM6IFwiQWxpZ25cIiBwcm9wIHdpbGwgYmUgcmVwbGFjZWQgYnkgXCJyaWdodFwiIHByb3AgaW4gZnV0dXJlIHJlbGVhc2VzLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VzLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBkcm9wZG93bl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICBkb21SZWY6IHRoaXMuZG9tUmVmLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdkcm9wZG93bicsIGNsYXNzTmFtZSwge1xuICAgICAgICAgICdpcy1hY3RpdmUnOiB0aGlzLnN0YXRlLm9wZW4sXG4gICAgICAgICAgJ2lzLXVwJzogdXAsXG4gICAgICAgICAgJ2lzLXJpZ2h0JzogcmlnaHQgfHwgYWxpZ24gPT09ICdyaWdodCcsXG4gICAgICAgICAgJ2lzLWhvdmVyYWJsZSc6IGhvdmVyYWJsZVxuICAgICAgICB9KVxuICAgICAgfSksIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImRyb3Bkb3duLXRyaWdnZXJcIixcbiAgICAgICAgcm9sZTogXCJwcmVzZW50YXRpb25cIixcbiAgICAgICAgb25DbGljazogdGhpcy50b2dnbGVcbiAgICAgIH0sIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfYnV0dG9uX2J1dHRvbiwge1xuICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgIH0sIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBjdXJyZW50KSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19pY29uX2ljb24sIHtcbiAgICAgICAgaWNvbjogXCJhbmdsZS1kb3duXCIsXG4gICAgICAgIHNpemU6IFwic21hbGxcIlxuICAgICAgfSkpKSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwiZHJvcGRvd24tbWVudVwiLFxuICAgICAgICBpZDogXCJkcm9wZG93bi1tZW51XCIsXG4gICAgICAgIHJvbGU6IFwibWVudVwiXG4gICAgICB9LCBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJkcm9wZG93bi1jb250ZW50XCJcbiAgICAgIH0sIGNoaWxkcmVuQXJyYXkpKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERyb3Bkb3duO1xufShleHRlcm5hbF9yZWFjdF9bXCJQdXJlQ29tcG9uZW50XCJdKTtcblxuXG5kcm9wZG93bl9Ecm9wZG93bi5JdGVtID0gY29tcG9uZW50c19pdGVtO1xuZHJvcGRvd25fRHJvcGRvd24uRGl2aWRlciA9IGRpdmlkZXI7XG5kcm9wZG93bl9Ecm9wZG93bi5wcm9wVHlwZXMgPSBkcm9wZG93bl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICB2YWx1ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYW55LFxuICBvbkNoYW5nZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuZnVuYyxcbiAgY29sb3I6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKGRyb3Bkb3duX2NvbG9ycyksXG4gIHJpZ2h0OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICB1cDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgYWxpZ246IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsncmlnaHQnXSksXG4gIGhvdmVyYWJsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgbGFiZWw6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsb3NlT25TZWxlY3Q6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbn0pO1xuZHJvcGRvd25fRHJvcGRvd24uZGVmYXVsdFByb3BzID0gZHJvcGRvd25fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNsb3NlT25TZWxlY3Q6IHRydWUsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2RpdicsXG4gIGRvbVJlZjogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICB2YWx1ZTogdW5kZWZpbmVkLFxuICBjaGlsZHJlbjogW10sXG4gIG9uQ2hhbmdlOiB1bmRlZmluZWQsXG4gIGNvbG9yOiB1bmRlZmluZWQsXG4gIGFsaWduOiB1bmRlZmluZWQsXG4gIGhvdmVyYWJsZTogdW5kZWZpbmVkLFxuICBsYWJlbDogdW5kZWZpbmVkXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvZHJvcGRvd24vaW5kZXguanNcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbG9hZGVyL2xvYWRlci5zYXNzXG52YXIgbG9hZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbG9hZGVyL2xvYWRlci5qc1xuZnVuY3Rpb24gbG9hZGVyX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGxvYWRlcl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbG9hZGVyX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgbG9hZGVyX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGxvYWRlcl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbG9hZGVyX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbG9hZGVyX2V4dGVuZHMoKSB7IGxvYWRlcl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGxvYWRlcl9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gbG9hZGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBsb2FkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGxvYWRlcl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgbG9hZGVyX0xvYWRlciA9IGZ1bmN0aW9uIExvYWRlcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gbG9hZGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBsb2FkZXJfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdsb2FkZXInLCBjbGFzc05hbWUpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5sb2FkZXJfTG9hZGVyLnByb3BUeXBlcyA9IGxvYWRlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbmxvYWRlcl9Mb2FkZXIuZGVmYXVsdFByb3BzID0gbG9hZGVyX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnZGl2J1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsb2FkZXJfbG9hZGVyID0gKGxvYWRlcl9Mb2FkZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9sb2FkZXIvaW5kZXguanNcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZXJ2aWNlcy9jYW4tdXNlLWRvbS5qc1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2FuX3VzZV9kb20gPSAoISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL25hdmJhci9jb21wb25lbnRzL2JyYW5kLmpzXG5mdW5jdGlvbiBicmFuZF9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBicmFuZF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgYnJhbmRfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBicmFuZF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBicmFuZF9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gYnJhbmRfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBicmFuZF9leHRlbmRzKCkgeyBicmFuZF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGJyYW5kX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBicmFuZF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gYnJhbmRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGJyYW5kX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG52YXIgYnJhbmRfTmF2YmFyQnJhbmQgPSBmdW5jdGlvbiBOYXZiYXJCcmFuZChfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHByb3BzID0gYnJhbmRfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCIsIFwiY2hpbGRyZW5cIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGJyYW5kX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnbmF2YmFyLWJyYW5kJywgY2xhc3NOYW1lKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuYnJhbmRfTmF2YmFyQnJhbmQucHJvcFR5cGVzID0gYnJhbmRfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZVxufSk7XG5icmFuZF9OYXZiYXJCcmFuZC5kZWZhdWx0UHJvcHMgPSBicmFuZF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIGNoaWxkcmVuOiBudWxsXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJyYW5kID0gKGJyYW5kX05hdmJhckJyYW5kKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbmF2YmFyL2NvbnRleHQuanNcblxudmFyIFNob3dDb250ZXh0ID0gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9uYXZiYXIvY29tcG9uZW50cy9idXJnZXIuanNcbmZ1bmN0aW9uIGJ1cmdlcl9leHRlbmRzKCkgeyBidXJnZXJfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBidXJnZXJfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGJ1cmdlcl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBidXJnZXJfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGJ1cmdlcl9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGJ1cmdlcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBidXJnZXJfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGJ1cmdlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGJ1cmdlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gYnVyZ2VyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBidXJnZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGJ1cmdlcl9OYXZiYXJCdXJnZXIgPSBmdW5jdGlvbiBOYXZiYXJCdXJnZXIoX3JlZikge1xuICB2YXIgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGJ1cmdlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFNob3dDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgYnVyZ2VyX2V4dGVuZHMoe1xuICAgICAgcm9sZTogXCJidXR0b25cIixcbiAgICAgIHRhYkluZGV4OiBcIjBcIixcbiAgICAgIHN0eWxlOiBidXJnZXJfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgb3V0bGluZTogJ25vbmUnXG4gICAgICB9LCBzdHlsZSksXG4gICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCduYXZiYXItYnVyZ2VyJywgY2xhc3NOYW1lLCB7XG4gICAgICAgICdpcy1hY3RpdmUnOiBhY3RpdmVcbiAgICAgIH0pXG4gICAgfSwgcHJvcHMpLCBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCksIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsKSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwpKTtcbiAgfSk7XG59O1xuXG5idXJnZXJfTmF2YmFyQnVyZ2VyLnByb3BUeXBlcyA9IGJ1cmdlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIG9uQ2xpY2s6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmZ1bmNcbn0pO1xuYnVyZ2VyX05hdmJhckJ1cmdlci5kZWZhdWx0UHJvcHMgPSBidXJnZXJfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge31cbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYnVyZ2VyID0gKGJ1cmdlcl9OYXZiYXJCdXJnZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9uYXZiYXIvY29tcG9uZW50cy9tZW51LmpzXG5mdW5jdGlvbiBtZW51X293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIG1lbnVfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG1lbnVfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBtZW51X2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG1lbnVfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG1lbnVfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBtZW51X2V4dGVuZHMoKSB7IG1lbnVfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBtZW51X2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBtZW51X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBtZW51X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBtZW51X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBtZW51X05hdmJhck1lbnUgPSBmdW5jdGlvbiBOYXZiYXJNZW51KF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcHJvcHMgPSBtZW51X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoU2hvd0NvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChhY3RpdmUpIHtcbiAgICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBtZW51X2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCduYXZiYXItbWVudScsIGNsYXNzTmFtZSwge1xuICAgICAgICAnaXMtYWN0aXZlJzogYWN0aXZlXG4gICAgICB9KVxuICAgIH0pLCBjaGlsZHJlbik7XG4gIH0pO1xufTtcblxubWVudV9OYXZiYXJNZW51LnByb3BUeXBlcyA9IG1lbnVfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZVxufSk7XG5tZW51X05hdmJhck1lbnUuZGVmYXVsdFByb3BzID0gbWVudV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIGNoaWxkcmVuOiBudWxsXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1lbnUgPSAobWVudV9OYXZiYXJNZW51KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbmF2YmFyL2NvbXBvbmVudHMvaXRlbS5qc1xuZnVuY3Rpb24gY29tcG9uZW50c19pdGVtX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfaXRlbV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgY29tcG9uZW50c19pdGVtX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgY29tcG9uZW50c19pdGVtX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGNvbXBvbmVudHNfaXRlbV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19pdGVtX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19pdGVtX2V4dGVuZHMoKSB7IGNvbXBvbmVudHNfaXRlbV9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGNvbXBvbmVudHNfaXRlbV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19pdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBjb21wb25lbnRzX2l0ZW1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgaXRlbV9OYXZiYXJJdGVtID0gZnVuY3Rpb24gTmF2YmFySXRlbShfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGFjdGl2ZSA9IF9yZWYuYWN0aXZlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgZHJvcGRvd24gPSBfcmVmLmRyb3Bkb3duLFxuICAgICAgZHJvcGRvd25VcCA9IF9yZWYuZHJvcGRvd25VcCxcbiAgICAgIGhvdmVyYWJsZSA9IF9yZWYuaG92ZXJhYmxlLFxuICAgICAgcmVuZGVyQXMgPSBfcmVmLnJlbmRlckFzLFxuICAgICAgYXJyb3dsZXNzID0gX3JlZi5hcnJvd2xlc3MsXG4gICAgICBwcm9wcyA9IGNvbXBvbmVudHNfaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIiwgXCJhY3RpdmVcIiwgXCJjaGlsZHJlblwiLCBcImRyb3Bkb3duXCIsIFwiZHJvcGRvd25VcFwiLCBcImhvdmVyYWJsZVwiLCBcInJlbmRlckFzXCIsIFwiYXJyb3dsZXNzXCJdKTtcblxuICB2YXIgYXMgPSByZW5kZXJBcztcblxuICBpZiAoZHJvcGRvd24gJiYgcmVuZGVyQXMgPT09ICdhJykge1xuICAgIGFzID0gJ3NwYW4nO1xuICB9XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgY29tcG9uZW50c19pdGVtX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgcmVuZGVyQXM6IGFzLFxuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ25hdmJhci1pdGVtJywgY2xhc3NOYW1lLCB7XG4gICAgICAnaXMtYWN0aXZlJzogYWN0aXZlLFxuICAgICAgJ2hhcy1kcm9wZG93bic6IGRyb3Bkb3duLFxuICAgICAgJ2lzLWhvdmVyYWJsZSc6IGhvdmVyYWJsZSxcbiAgICAgICdoYXMtZHJvcGRvd24tdXAnOiBkcm9wZG93blVwLFxuICAgICAgJ2lzLWFycm93bGVzcyc6IGFycm93bGVzc1xuICAgIH0pXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5pdGVtX05hdmJhckl0ZW0ucHJvcFR5cGVzID0gY29tcG9uZW50c19pdGVtX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgYWN0aXZlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBkcm9wZG93bjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgZHJvcGRvd25VcDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgaG92ZXJhYmxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgYXJyb3dsZXNzOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbml0ZW1fTmF2YmFySXRlbS5kZWZhdWx0UHJvcHMgPSBjb21wb25lbnRzX2l0ZW1fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBhY3RpdmU6IHVuZGVmaW5lZCxcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRyb3Bkb3duOiB1bmRlZmluZWQsXG4gIGhvdmVyYWJsZTogdW5kZWZpbmVkLFxuICBkcm9wZG93blVwOiB1bmRlZmluZWQsXG4gIGFycm93bGVzczogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2EnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG5hdmJhcl9jb21wb25lbnRzX2l0ZW0gPSAoaXRlbV9OYXZiYXJJdGVtKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbmF2YmFyL2NvbXBvbmVudHMvZHJvcGRvd24uanNcbmZ1bmN0aW9uIGNvbXBvbmVudHNfZHJvcGRvd25fb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19kcm9wZG93bl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgY29tcG9uZW50c19kcm9wZG93bl9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGNvbXBvbmVudHNfZHJvcGRvd25fZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgY29tcG9uZW50c19kcm9wZG93bl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19kcm9wZG93bl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfZHJvcGRvd25fZXh0ZW5kcygpIHsgY29tcG9uZW50c19kcm9wZG93bl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGNvbXBvbmVudHNfZHJvcGRvd25fZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfZHJvcGRvd25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGNvbXBvbmVudHNfZHJvcGRvd25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfZHJvcGRvd25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGRyb3Bkb3duX05hdmJhckRyb3Bkb3duID0gZnVuY3Rpb24gTmF2YmFyRHJvcGRvd24oX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBib3hlZCA9IF9yZWYuYm94ZWQsXG4gICAgICByaWdodCA9IF9yZWYucmlnaHQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBwcm9wcyA9IGNvbXBvbmVudHNfZHJvcGRvd25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCIsIFwiYm94ZWRcIiwgXCJyaWdodFwiLCBcImNoaWxkcmVuXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjb21wb25lbnRzX2Ryb3Bkb3duX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnbmF2YmFyLWRyb3Bkb3duJywgY2xhc3NOYW1lLCB7XG4gICAgICAnaXMtYm94ZWQnOiBib3hlZCxcbiAgICAgICdpcy1yaWdodCc6IHJpZ2h0XG4gICAgfSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbmRyb3Bkb3duX05hdmJhckRyb3Bkb3duLnByb3BUeXBlcyA9IGNvbXBvbmVudHNfZHJvcGRvd25fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hcyxcbiAgYm94ZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHJpZ2h0OiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sXG59KTtcbmRyb3Bkb3duX05hdmJhckRyb3Bkb3duLmRlZmF1bHRQcm9wcyA9IGNvbXBvbmVudHNfZHJvcGRvd25fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBjaGlsZHJlbjogbnVsbCxcbiAgcmVuZGVyQXM6ICdzcGFuJyxcbiAgYm94ZWQ6IGZhbHNlLFxuICByaWdodDogZmFsc2Vcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19kcm9wZG93biA9IChkcm9wZG93bl9OYXZiYXJEcm9wZG93bik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL25hdmJhci9jb21wb25lbnRzL2RpdmlkZXIuanNcbmZ1bmN0aW9uIGNvbXBvbmVudHNfZGl2aWRlcl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2RpdmlkZXJfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGNvbXBvbmVudHNfZGl2aWRlcl9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGNvbXBvbmVudHNfZGl2aWRlcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBjb21wb25lbnRzX2RpdmlkZXJfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfZGl2aWRlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfZGl2aWRlcl9leHRlbmRzKCkgeyBjb21wb25lbnRzX2RpdmlkZXJfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBjb21wb25lbnRzX2RpdmlkZXJfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfZGl2aWRlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gY29tcG9uZW50c19kaXZpZGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2RpdmlkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cbnZhciBkaXZpZGVyX05hdmJhckRpdmlkZXIgPSBmdW5jdGlvbiBOYXZiYXJEaXZpZGVyKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcHJvcHMgPSBjb21wb25lbnRzX2RpdmlkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjb21wb25lbnRzX2RpdmlkZXJfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCduYXZiYXItZGl2aWRlcicsIGNsYXNzTmFtZSlcbiAgfSkpO1xufTtcblxuZGl2aWRlcl9OYXZiYXJEaXZpZGVyLnByb3BUeXBlcyA9IGNvbXBvbmVudHNfZGl2aWRlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmdcbn0pO1xuZGl2aWRlcl9OYXZiYXJEaXZpZGVyLmRlZmF1bHRQcm9wcyA9IGNvbXBvbmVudHNfZGl2aWRlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWRcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19kaXZpZGVyID0gKGRpdmlkZXJfTmF2YmFyRGl2aWRlcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL25hdmJhci9jb21wb25lbnRzL2xpbmsuanNcbmZ1bmN0aW9uIGxpbmtfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gbGlua19vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbGlua19vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGxpbmtfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgbGlua19vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbGlua19kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGxpbmtfZXh0ZW5kcygpIHsgbGlua19leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGxpbmtfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGxpbmtfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGxpbmtfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGxpbmtfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIGxpbmtfTmF2YmFyTGluayA9IGZ1bmN0aW9uIE5hdmJhckxpbmsoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBhcnJvd2xlc3MgPSBfcmVmLmFycm93bGVzcyxcbiAgICAgIHByb3BzID0gbGlua19vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIiwgXCJjaGlsZHJlblwiLCBcImFycm93bGVzc1wiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgbGlua19leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ25hdmJhci1saW5rJywgY2xhc3NOYW1lLCB7XG4gICAgICAnaXMtYXJyb3dsZXNzJzogYXJyb3dsZXNzXG4gICAgfSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbmxpbmtfTmF2YmFyTGluay5wcm9wVHlwZXMgPSBsaW5rX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIHJlbmRlckFzOiByZW5kZXJfYXMsXG4gIGFycm93bGVzczogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbFxufSk7XG5saW5rX05hdmJhckxpbmsuZGVmYXVsdFByb3BzID0gbGlua19vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIGNoaWxkcmVuOiBudWxsLFxuICBhcnJvd2xlc3M6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdzcGFuJ1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2xpbmsgPSAobGlua19OYXZiYXJMaW5rKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbmF2YmFyL2NvbXBvbmVudHMvY29udGFpbmVyLmpzXG5mdW5jdGlvbiBjb21wb25lbnRzX2NvbnRhaW5lcl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2NvbnRhaW5lcl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgY29tcG9uZW50c19jb250YWluZXJfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjb21wb25lbnRzX2NvbnRhaW5lcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBjb21wb25lbnRzX2NvbnRhaW5lcl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19jb250YWluZXJfZXh0ZW5kcygpIHsgY29tcG9uZW50c19jb250YWluZXJfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBjb21wb25lbnRzX2NvbnRhaW5lcl9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19jb250YWluZXJfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2NvbnRhaW5lcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gY29tcG9uZW50c19jb250YWluZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfY29udGFpbmVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBjb250YWluZXJfTmF2YmFyQ29udGFpbmVyID0gZnVuY3Rpb24gTmF2YmFyQ29udGFpbmVyKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcG9zaXRpb24gPSBfcmVmLnBvc2l0aW9uLFxuICAgICAgcHJvcHMgPSBjb21wb25lbnRzX2NvbnRhaW5lcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIiwgXCJjaGlsZHJlblwiLCBcInBvc2l0aW9uXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjb21wb25lbnRzX2NvbnRhaW5lcl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoY29tcG9uZW50c19jb250YWluZXJfZGVmaW5lUHJvcGVydHkoe30sIFwibmF2YmFyLVwiLmNvbmNhdChwb3NpdGlvbiksIHBvc2l0aW9uKSwgY2xhc3NOYW1lKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuY29udGFpbmVyX05hdmJhckNvbnRhaW5lci5wcm9wVHlwZXMgPSBjb21wb25lbnRzX2NvbnRhaW5lcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICByZW5kZXJBczogcmVuZGVyX2FzLFxuICBwb3NpdGlvbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydzdGFydCcsICdlbmQnXSlcbn0pO1xuY29udGFpbmVyX05hdmJhckNvbnRhaW5lci5kZWZhdWx0UHJvcHMgPSBjb21wb25lbnRzX2NvbnRhaW5lcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIGNoaWxkcmVuOiBudWxsLFxuICByZW5kZXJBczogJ2RpdicsXG4gIHBvc2l0aW9uOiAnc3RhcnQnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfY29udGFpbmVyID0gKGNvbnRhaW5lcl9OYXZiYXJDb250YWluZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9uYXZiYXIvbmF2YmFyLmpzXG5mdW5jdGlvbiBuYXZiYXJfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gbmF2YmFyX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBuYXZiYXJfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBuYXZiYXJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgbmF2YmFyX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBuYXZiYXJfZXh0ZW5kcygpIHsgbmF2YmFyX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gbmF2YmFyX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBuYXZiYXJfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBuYXZiYXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IG5hdmJhcl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbmF2YmFyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIG5hdmJhcl9jb2xvcnMgPSBbbnVsbF0uY29uY2F0KE9iamVjdC5rZXlzKGNvbnN0YW50cy5DT0xPUlMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBjb25zdGFudHMuQ09MT1JTW2tleV07XG59KSk7XG52YXIgaHRtbENsYXNzID0gJyc7XG52YXIgZ2V0SHRtbENsYXNzZXMgPSBmdW5jdGlvbiBnZXRIdG1sQ2xhc3NlcygpIHtcbiAgcmV0dXJuIGh0bWxDbGFzcztcbn07XG5cbnZhciBuYXZiYXJfTmF2YmFyID0gZnVuY3Rpb24gTmF2YmFyKF9yZWYpIHtcbiAgdmFyIF9jbGFzc25hbWVzO1xuXG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGZpeGVkID0gX3JlZi5maXhlZCxcbiAgICAgIHRyYW5zcGFyZW50ID0gX3JlZi50cmFuc3BhcmVudCxcbiAgICAgIGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgIGFjdGl2ZSA9IF9yZWYuYWN0aXZlLFxuICAgICAgcHJvcHMgPSBuYXZiYXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJmaXhlZFwiLCBcInRyYW5zcGFyZW50XCIsIFwiY29sb3JcIiwgXCJhY3RpdmVcIl0pO1xuXG4gIGh0bWxDbGFzcyA9IGZpeGVkID8gXCJoYXMtbmF2YmFyLWZpeGVkLVwiLmNvbmNhdChmaXhlZCkgOiAnJztcbiAgT2JqZWN0KGV4dGVybmFsX3JlYWN0X1tcInVzZUVmZmVjdFwiXSkoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FuX3VzZV9kb20pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJyk7XG5cbiAgICBpZiAoIWh0bWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGFzLW5hdmJhci1maXhlZC1cIi5jb25jYXQoZml4ZWQpKSkge1xuICAgICAgaHRtbC5jbGFzc0xpc3QucmVtb3ZlKCdoYXMtbmF2YmFyLWZpeGVkLXRvcCcpO1xuICAgICAgaHRtbC5jbGFzc0xpc3QucmVtb3ZlKCdoYXMtbmF2YmFyLWZpeGVkLWJvdHRvbScpO1xuICAgIH1cblxuICAgIGlmIChmaXhlZCkge1xuICAgICAgaHRtbC5jbGFzc0xpc3QuYWRkKFwiaGFzLW5hdmJhci1maXhlZC1cIi5jb25jYXQoZml4ZWQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJykuY2xhc3NMaXN0LnJlbW92ZShcImhhcy1uYXZiYXItZml4ZWQtXCIuY29uY2F0KGZpeGVkKSk7XG4gICAgfTtcbiAgfSwgW2ZpeGVkXSk7XG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChTaG93Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhY3RpdmVcbiAgfSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBuYXZiYXJfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByb2xlOiBcIm5hdmlnYXRpb25cIixcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCduYXZiYXInLCBtb2RpZmllcnMuY2xhc3NuYW1lcyhwcm9wcyksIGNsYXNzTmFtZSwgKF9jbGFzc25hbWVzID0ge1xuICAgICAgJ2lzLXRyYW5zcGFyZW50JzogdHJhbnNwYXJlbnRcbiAgICB9LCBuYXZiYXJfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtZml4ZWQtXCIuY29uY2F0KGZpeGVkKSwgZml4ZWQpLCBuYXZiYXJfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KGNvbG9yKSwgY29sb3IpLCBfY2xhc3NuYW1lcykpXG4gIH0pLCBjaGlsZHJlbikpO1xufTtcblxubmF2YmFyX05hdmJhci5wcm9wVHlwZXMgPSBuYXZiYXJfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgdHJhbnNwYXJlbnQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIHJlbmRlckFzOiByZW5kZXJfYXMsXG4gIGZpeGVkOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihbJ3RvcCcsICdib3R0b20nXSksXG4gIGNvbG9yOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5vbmVPZihuYXZiYXJfY29sb3JzKSxcbiAgYWN0aXZlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sXG59KTtcbm5hdmJhcl9OYXZiYXIuZGVmYXVsdFByb3BzID0gbmF2YmFyX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnbmF2JyxcbiAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICBhY3RpdmU6IGZhbHNlLFxuICBmaXhlZDogdW5kZWZpbmVkLFxuICBjb2xvcjogdW5kZWZpbmVkXG59KTtcbm5hdmJhcl9OYXZiYXIuQnJhbmQgPSBicmFuZDtcbm5hdmJhcl9OYXZiYXIuQnVyZ2VyID0gYnVyZ2VyO1xubmF2YmFyX05hdmJhci5NZW51ID0gbWVudTtcbm5hdmJhcl9OYXZiYXIuSXRlbSA9IG5hdmJhcl9jb21wb25lbnRzX2l0ZW07XG5uYXZiYXJfTmF2YmFyLkRyb3Bkb3duID0gY29tcG9uZW50c19kcm9wZG93bjtcbm5hdmJhcl9OYXZiYXIuTGluayA9IGNvbXBvbmVudHNfbGluaztcbm5hdmJhcl9OYXZiYXIuRGl2aWRlciA9IGNvbXBvbmVudHNfZGl2aWRlcjtcbm5hdmJhcl9OYXZiYXIuQ29udGFpbmVyID0gY29tcG9uZW50c19jb250YWluZXI7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBuYXZiYXIgPSAobmF2YmFyX05hdmJhcik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbmF2YmFyL25hdmJhci5zYXNzXG52YXIgbmF2YmFyX25hdmJhciA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL25hdmJhci9pbmRleC5qc1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfbmF2YmFyID0gKG5hdmJhcik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90YWJzL3RhYnMuc2Fzc1xudmFyIHRhYnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90YWJzL2NvbXBvbmVudHMvdGFiLmpzXG5mdW5jdGlvbiB0YWJfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gdGFiX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyB0YWJfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyB0YWJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgdGFiX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiB0YWJfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiB0YWJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHRhYl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdGFiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciB0YWJfVGFiID0gZnVuY3Rpb24gVGFiKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgYWN0aXZlID0gX3JlZi5hY3RpdmUsXG4gICAgICBkb21SZWYgPSBfcmVmLmRvbVJlZixcbiAgICAgIHByb3BzID0gdGFiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwic3R5bGVcIiwgXCJhY3RpdmVcIiwgXCJkb21SZWZcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChcImxpXCIsIHtcbiAgICByZWY6IGRvbVJlZixcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKShjbGFzc05hbWUsIHtcbiAgICAgICdpcy1hY3RpdmUnOiBhY3RpdmVcbiAgICB9KVxuICB9LCBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikpO1xufTtcblxudGFiX1RhYi5wcm9wVHlwZXMgPSB0YWJfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgc3R5bGU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnNoYXBlKHt9KSxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hcyxcbiAgYWN0aXZlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sXG59KTtcbnRhYl9UYWIuZGVmYXVsdFByb3BzID0gdGFiX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnYScsXG4gIGFjdGl2ZTogZmFsc2Vcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGFiID0gKHRhYl9UYWIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90YWJzL3RhYnMuanNcbmZ1bmN0aW9uIHRhYnNfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gdGFic19vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgdGFic19vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHRhYnNfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgdGFic19vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdGFic19leHRlbmRzKCkgeyB0YWJzX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gdGFic19leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gdGFic19kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHRhYnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHRhYnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIHRhYnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxuXG52YXIgdGFic19UYWJzID0gZnVuY3Rpb24gVGFicyhfcmVmKSB7XG4gIHZhciBfY2xhc3NuYW1lcztcblxuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgIGZ1bGx3aWR0aCA9IF9yZWYuZnVsbHdpZHRoLFxuICAgICAgcHJvcHMgPSB0YWJzX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiYWxpZ25cIiwgXCJzaXplXCIsIFwidHlwZVwiLCBcImZ1bGx3aWR0aFwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgdGFic19leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ3RhYnMnLCBjbGFzc05hbWUsIChfY2xhc3NuYW1lcyA9IHt9LCB0YWJzX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImlzLVwiLmNvbmNhdChhbGlnbiksIGFsaWduKSwgdGFic19kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpLCB0YWJzX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCAnaXMtdG9nZ2xlJywgdHlwZSA9PT0gJ3RvZ2dsZS1yb3VuZGVkJyksIHRhYnNfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiaXMtXCIuY29uY2F0KHR5cGUpLCB0eXBlKSwgdGFic19kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ2lzLWZ1bGx3aWR0aCcsIGZ1bGx3aWR0aCksIF9jbGFzc25hbWVzKSlcbiAgfSksIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwidWxcIiwgbnVsbCwgY2hpbGRyZW4pKTtcbn07XG5cbnRhYnNfVGFicy5UYWIgPSB0YWI7XG50YWJzX1RhYnMucHJvcFR5cGVzID0gdGFic19vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm5vZGUsXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICBzdHlsZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc2hhcGUoe30pLFxuICByZW5kZXJBczogcmVuZGVyX2FzLFxuICBhbGlnbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydjZW50ZXJlZCcsICdyaWdodCddKSxcbiAgc2l6ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWydzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXSksXG5cbiAgLyoqIFRoaXMgaXMgY2FsbGVkIHN0eWxlIG9uIEJ1bG1hIGRvY3VtZW50YXRpb24gKi9cbiAgdHlwZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoWyd0b2dnbGUnLCAnYm94ZWQnLCAndG9nZ2xlLXJvdW5kZWQnXSksXG4gIGZ1bGx3aWR0aDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbFxufSk7XG50YWJzX1RhYnMuZGVmYXVsdFByb3BzID0gdGFic19vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBzdHlsZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2RpdicsXG4gIGFsaWduOiB1bmRlZmluZWQsXG4gIHNpemU6IHVuZGVmaW5lZCxcbiAgdHlwZTogdW5kZWZpbmVkLFxuICBmdWxsd2lkdGg6IGZhbHNlXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRhYnNfdGFicyA9ICh0YWJzX1RhYnMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90YWJzL2luZGV4LmpzXG5cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5zYXNzXG52YXIgcGFnaW5hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5qc1xuZnVuY3Rpb24gcGFnaW5hdGlvbl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBwYWdpbmF0aW9uX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBwYWdpbmF0aW9uX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcGFnaW5hdGlvbl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBwYWdpbmF0aW9uX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBwYWdpbmF0aW9uX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IHBhZ2luYXRpb25fdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IHBhZ2luYXRpb25fdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIHBhZ2luYXRpb25fdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gcGFnaW5hdGlvbl9leHRlbmRzKCkgeyBwYWdpbmF0aW9uX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gcGFnaW5hdGlvbl9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gcGFnaW5hdGlvbl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gcGFnaW5hdGlvbl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcGFnaW5hdGlvbl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcGFnaW5hdGlvbl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHBhZ2luYXRpb25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHBhZ2luYXRpb25fY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBwYWdpbmF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBwYWdpbmF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHBhZ2luYXRpb25fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChwYWdpbmF0aW9uX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gcGFnaW5hdGlvbl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gcGFnaW5hdGlvbl9nZXRQcm90b3R5cGVPZihvKSB7IHBhZ2luYXRpb25fZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gcGFnaW5hdGlvbl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBwYWdpbmF0aW9uX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHBhZ2luYXRpb25faW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgcGFnaW5hdGlvbl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gcGFnaW5hdGlvbl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IHBhZ2luYXRpb25fc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHBhZ2luYXRpb25fc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gcGFnaW5hdGlvbl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblxuXG5cblxuXG5cbnZhciBwYWdpbmF0aW9uX1BhZ2luYXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIHBhZ2luYXRpb25faW5oZXJpdHMoUGFnaW5hdGlvbiwgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBhZ2luYXRpb24oKSB7XG4gICAgdmFyIF9nZXRQcm90b3R5cGVPZjI7XG5cbiAgICB2YXIgX3RoaXM7XG5cbiAgICBwYWdpbmF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhZ2luYXRpb24pO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gcGFnaW5hdGlvbl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfZ2V0UHJvdG90eXBlT2YyID0gcGFnaW5hdGlvbl9nZXRQcm90b3R5cGVPZihQYWdpbmF0aW9uKSkuY2FsbC5hcHBseShfZ2V0UHJvdG90eXBlT2YyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSk7XG5cbiAgICBwYWdpbmF0aW9uX2RlZmluZVByb3BlcnR5KHBhZ2luYXRpb25fYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnb1RvUGFnZVwiLCBmdW5jdGlvbiAocGFnZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBvbkNoYW5nZSA9IF90aGlzLnByb3BzLm9uQ2hhbmdlO1xuICAgICAgICBvbkNoYW5nZShwYWdlKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBwYWdpbmF0aW9uX2RlZmluZVByb3BlcnR5KHBhZ2luYXRpb25fYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJmaXJzdFBhZ2VcIiwgZnVuY3Rpb24gKGN1cnJlbnQsIGxhc3QpIHtcbiAgICAgIHZhciBkZWx0YSA9IF90aGlzLnByb3BzLmRlbHRhO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pblBhZ2UgPSBsYXN0IC0gZGVsdGEgKiAyO1xuICAgICAgdmFyIHBhZ2UgPSBNYXRoLm1pbihjdXJyZW50IC0gZGVsdGEsIG1pblBhZ2UpO1xuICAgICAgcmV0dXJuIHBhZ2UgPD0gMCA/IDEgOiBwYWdlO1xuICAgIH0pO1xuXG4gICAgcGFnaW5hdGlvbl9kZWZpbmVQcm9wZXJ0eShwYWdpbmF0aW9uX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibGFzdFBhZ2VcIiwgZnVuY3Rpb24gKGN1cnJlbnQsIHRvdGFsKSB7XG4gICAgICB2YXIgZGVsdGEgPSBfdGhpcy5wcm9wcy5kZWx0YTtcblxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRvdGFsKSB7XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heFBhZ2UgPSBkZWx0YSAqIDIgKyAxO1xuICAgICAgdmFyIHBhZ2UgPSBNYXRoLm1heChjdXJyZW50ICsgZGVsdGEsIG1heFBhZ2UpO1xuICAgICAgcmV0dXJuIHBhZ2UgPiB0b3RhbCA/IHRvdGFsIDogcGFnZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHBhZ2luYXRpb25fY3JlYXRlQ2xhc3MoUGFnaW5hdGlvbiwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGN1cnJlbnQgPSBfdGhpcyRwcm9wcy5jdXJyZW50LFxuICAgICAgICAgIGRpc2FibGVkID0gX3RoaXMkcHJvcHMuZGlzYWJsZWQsXG4gICAgICAgICAgdG90YWwgPSBfdGhpcyRwcm9wcy50b3RhbCxcbiAgICAgICAgICBuZXh0ID0gX3RoaXMkcHJvcHMubmV4dCxcbiAgICAgICAgICBwcmV2aW91cyA9IF90aGlzJHByb3BzLnByZXZpb3VzLFxuICAgICAgICAgIHNob3dQcmV2TmV4dCA9IF90aGlzJHByb3BzLnNob3dQcmV2TmV4dCxcbiAgICAgICAgICBkZWx0YSA9IF90aGlzJHByb3BzLmRlbHRhLFxuICAgICAgICAgIGF1dG9IaWRlID0gX3RoaXMkcHJvcHMuYXV0b0hpZGUsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICAgIG9uQ2hhbmdlID0gX3RoaXMkcHJvcHMub25DaGFuZ2UsXG4gICAgICAgICAgcHJvcHMgPSBwYWdpbmF0aW9uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjdXJyZW50XCIsIFwiZGlzYWJsZWRcIiwgXCJ0b3RhbFwiLCBcIm5leHRcIiwgXCJwcmV2aW91c1wiLCBcInNob3dQcmV2TmV4dFwiLCBcImRlbHRhXCIsIFwiYXV0b0hpZGVcIiwgXCJjbGFzc05hbWVcIiwgXCJvbkNoYW5nZVwiXSk7XG5cbiAgICAgIGlmICh0b3RhbCA8PSAxICYmIGF1dG9IaWRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA+IHRvdGFsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdFBhZ2UgPSB0aGlzLmxhc3RQYWdlKGN1cnJlbnQsIHRvdGFsKTtcbiAgICAgIHZhciBmaXJzdFBhZ2UgPSB0aGlzLmZpcnN0UGFnZShjdXJyZW50LCBsYXN0UGFnZSk7XG4gICAgICB2YXIgcHJldkRpc2FibGVkID0gY3VycmVudCA9PT0gMSB8fCBkaXNhYmxlZDtcbiAgICAgIHZhciBuZXh0RGlzYWJsZWQgPSBjdXJyZW50ID09PSB0b3RhbCB8fCBkaXNhYmxlZDtcbiAgICAgIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIHBhZ2luYXRpb25fZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgncGFnaW5hdGlvbicsIGNsYXNzTmFtZSksXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBcInBhZ2luYXRpb25cIlxuICAgICAgfSksIHNob3dQcmV2TmV4dCAmJiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuRnJhZ21lbnQsIG51bGwsIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgIHJvbGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbkNsaWNrOiBwcmV2RGlzYWJsZWQgPyB1bmRlZmluZWQgOiB0aGlzLmdvVG9QYWdlKGN1cnJlbnQgLSAxKSxcbiAgICAgICAgY2xhc3NOYW1lOiBcInBhZ2luYXRpb24tcHJldmlvdXNcIixcbiAgICAgICAgdGl0bGU6IFwiVGhpcyBpcyB0aGUgZmlyc3QgcGFnZVwiLFxuICAgICAgICBkaXNhYmxlZDogcHJldkRpc2FibGVkXG4gICAgICB9LCBwcmV2aW91cyksIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgIHJvbGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbkNsaWNrOiBuZXh0RGlzYWJsZWQgPyB1bmRlZmluZWQgOiB0aGlzLmdvVG9QYWdlKGN1cnJlbnQgKyAxKSxcbiAgICAgICAgY2xhc3NOYW1lOiBcInBhZ2luYXRpb24tbmV4dFwiLFxuICAgICAgICBkaXNhYmxlZDogbmV4dERpc2FibGVkXG4gICAgICB9LCBuZXh0KSksIGRlbHRhID4gMCAmJiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuRnJhZ21lbnQsIG51bGwsIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KFwidWxcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicGFnaW5hdGlvbi1saXN0XCJcbiAgICAgIH0sIEFycmF5KGxhc3RQYWdlIC0gZmlyc3RQYWdlICsgMSkuZmlsbCgwKS5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgcmV0dXJuICgvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7XG4gICAgICAgICAgICBrZXk6IGkgKyBmaXJzdFBhZ2VcbiAgICAgICAgICB9LCBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICAgICAgcm9sZTogXCJidXR0b25cIixcbiAgICAgICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgncGFnaW5hdGlvbi1saW5rJywge1xuICAgICAgICAgICAgICAnaXMtY3VycmVudCc6IGN1cnJlbnQgPT09IGkgKyBmaXJzdFBhZ2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25DbGljazogY3VycmVudCA9PT0gZmlyc3RQYWdlICsgaSA/IHVuZGVmaW5lZCA6IF90aGlzMi5nb1RvUGFnZShmaXJzdFBhZ2UgKyBpKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBcIlBhZ2UgXCIuY29uY2F0KGkgKyBmaXJzdFBhZ2UpLFxuICAgICAgICAgICAgXCJhcmlhLWN1cnJlbnRcIjogXCJwYWdlXCIsXG4gICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWRcbiAgICAgICAgICB9LCBpICsgZmlyc3RQYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH0pKSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYWdpbmF0aW9uO1xufShleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuUHVyZUNvbXBvbmVudCk7XG5cblxucGFnaW5hdGlvbl9QYWdpbmF0aW9uLnByb3BUeXBlcyA9IHBhZ2luYXRpb25fb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIC8qKiBDdXJyZW50IHBhZ2UgKi9cbiAgY3VycmVudDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubnVtYmVyLFxuXG4gIC8qKiB3aGV0aGVyIHRvIGRpc2FibGUgdGhlIGJ1dHRvbnMgKi9cbiAgZGlzYWJsZWQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG5cbiAgLyoqIFRvdGFsIHBhZ2VzIGluIHRvdGFsICovXG4gIHRvdGFsOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5udW1iZXIsXG5cbiAgLyoqIEFtb3VudCBvZyBwYWdlcyB0byBkaXNwbGF5IGF0IHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgY3VycmVudCAoaWYgZGVsdGEgMiBhbmQgY3VycmVudCBwYWdlIGlzIDMsIHRoZSBwYWdpbmF0b3Igd2lsbCBkaXNwbGF5IHBhZ2VzIGZyb20gMSB0byA1KSAqL1xuICBkZWx0YTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubnVtYmVyLFxuICBvbkNoYW5nZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuZnVuYyxcblxuICAvKiogVGV4dCBvZiB0aGUgTmV4dCBidXR0b24gKi9cbiAgbmV4dDogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcblxuICAvKiogVGV4dCBvZiB0aGUgUHJldmlvdXMgYnV0dG9uICovXG4gIHByZXZpb3VzOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBzaG93UHJldk5leHQ6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2wsXG4gIGF1dG9IaWRlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sLFxuXG4gIC8qKlxuICAgKiBDbGFzc25hbWUgb2YgdGhlIGNvbnRhaW5lciBvZiB0aGUgcGFnaW5hdGlvbiwgdGhpcyBjb3VsZCBiZSB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgaW5uZXIgdmlld3NcbiAgICovXG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nXG59KTtcbnBhZ2luYXRpb25fUGFnaW5hdGlvbi5kZWZhdWx0UHJvcHMgPSBwYWdpbmF0aW9uX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICB0b3RhbDogMSxcbiAgY3VycmVudDogMSxcbiAgZGVsdGE6IDEsXG4gIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9LFxuICBuZXh0OiAnTmV4dCcsXG4gIHByZXZpb3VzOiAnUHJldmlvdXMnLFxuICBzaG93UHJldk5leHQ6IHRydWUsXG4gIGRpc2FibGVkOiB1bmRlZmluZWQsXG4gIGF1dG9IaWRlOiB0cnVlLFxuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICduYXYnXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcGFnaW5hdGlvbi9pbmRleC5qc1xuXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9tZW51L21lbnUuc2Fzc1xudmFyIG1lbnVfbWVudSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL21lbnUvY29tcG9uZW50cy9saXN0L2NvbXBvbmVudHMvaXRlbS5qc1xuZnVuY3Rpb24gbGlzdF9jb21wb25lbnRzX2l0ZW1fb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gbGlzdF9jb21wb25lbnRzX2l0ZW1fb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IGxpc3RfY29tcG9uZW50c19pdGVtX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgbGlzdF9jb21wb25lbnRzX2l0ZW1fZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgbGlzdF9jb21wb25lbnRzX2l0ZW1fb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGxpc3RfY29tcG9uZW50c19pdGVtX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbGlzdF9jb21wb25lbnRzX2l0ZW1fZXh0ZW5kcygpIHsgbGlzdF9jb21wb25lbnRzX2l0ZW1fZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBsaXN0X2NvbXBvbmVudHNfaXRlbV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gbGlzdF9jb21wb25lbnRzX2l0ZW1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGxpc3RfY29tcG9uZW50c19pdGVtX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBsaXN0X2NvbXBvbmVudHNfaXRlbV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1jeWNsZSAqL1xuXG5cblxuXG5cblxudmFyIGl0ZW1fTWVudUxpc3RJdGVtID0gZnVuY3Rpb24gTWVudUxpc3RJdGVtKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGFjdGl2ZSA9IF9yZWYuYWN0aXZlLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICByZWYgPSBfcmVmLmRvbVJlZixcbiAgICAgIHByb3BzID0gbGlzdF9jb21wb25lbnRzX2l0ZW1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJhY3RpdmVcIiwgXCJjbGFzc05hbWVcIiwgXCJkb21SZWZcIl0pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gIT09ICdzdHJpbmcnICYmIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKS5sZW5ndGggPT09IDEgJiYgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLnR5cGUgPT09IGNvbXBvbmVudHNfbGlzdF9saXN0KSB7XG4gICAgdmFyIGNoaWxkID0gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChcImxpXCIsIHtcbiAgICAgIHJlZjogcmVmXG4gICAgfSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBsaXN0X2NvbXBvbmVudHNfaXRlbV9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoY2xhc3NOYW1lLCB7XG4gICAgICAgICdpcy1hY3RpdmUnOiBhY3RpdmVcbiAgICAgIH0pXG4gICAgfSwgcHJvcHMpLCBjaGlsZC5wcm9wcy50aXRsZSksIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIHRpdGxlOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7XG4gICAgcmVmOiByZWZcbiAgfSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBsaXN0X2NvbXBvbmVudHNfaXRlbV9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKGNsYXNzTmFtZSwge1xuICAgICAgJ2lzLWFjdGl2ZSc6IGFjdGl2ZVxuICAgIH0pXG4gIH0sIHByb3BzKSwgY2hpbGRyZW4pKTtcbn07XG5cbml0ZW1fTWVudUxpc3RJdGVtLnByb3BUeXBlcyA9IGxpc3RfY29tcG9uZW50c19pdGVtX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgY2hpbGRyZW46IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mVHlwZShbZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLCBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5lbGVtZW50XSksXG4gIGFjdGl2ZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuYm9vbCxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hc1xufSk7XG5pdGVtX01lbnVMaXN0SXRlbS5kZWZhdWx0UHJvcHMgPSBsaXN0X2NvbXBvbmVudHNfaXRlbV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIGNoaWxkcmVuOiBudWxsLFxuICBhY3RpdmU6IGZhbHNlLFxuICByZW5kZXJBczogJ2EnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxpc3RfY29tcG9uZW50c19pdGVtID0gKGl0ZW1fTWVudUxpc3RJdGVtKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbWVudS9jb21wb25lbnRzL2xpc3QvbGlzdC5qc1xuZnVuY3Rpb24gbGlzdF9saXN0X293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGxpc3RfbGlzdF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbGlzdF9saXN0X293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgbGlzdF9saXN0X2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGxpc3RfbGlzdF9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbGlzdF9saXN0X2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbGlzdF9saXN0X2V4dGVuZHMoKSB7IGxpc3RfbGlzdF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGxpc3RfbGlzdF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gbGlzdF9saXN0X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBsaXN0X2xpc3Rfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGxpc3RfbGlzdF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1jeWNsZSAqL1xuXG5cblxuXG5cbnZhciBsaXN0X01lbnVMaXN0ID0gZnVuY3Rpb24gTWVudUxpc3QoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0aXRsZSA9IF9yZWYudGl0bGUsXG4gICAgICBwcm9wcyA9IGxpc3RfbGlzdF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIiwgXCJ0aXRsZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5GcmFnbWVudCwgbnVsbCwgdGl0bGUgJiYgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWVudS1sYWJlbFwiXG4gIH0sIHRpdGxlKSwgZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBsaXN0X2xpc3RfZXh0ZW5kcyh7XG4gICAgcmVuZGVyQXM6IFwidWxcIixcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdtZW51LWxpc3QnLCBjbGFzc05hbWUpXG4gIH0sIHByb3BzKSkpO1xufTtcblxubGlzdF9NZW51TGlzdC5JdGVtID0gbGlzdF9jb21wb25lbnRzX2l0ZW07XG5saXN0X01lbnVMaXN0LnByb3BUeXBlcyA9IGxpc3RfbGlzdF9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHRpdGxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlXG59KTtcbmxpc3RfTWVudUxpc3QuZGVmYXVsdFByb3BzID0gbGlzdF9saXN0X29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgdGl0bGU6IHVuZGVmaW5lZFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2xpc3RfbGlzdCA9IChsaXN0X01lbnVMaXN0KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbWVudS9jb21wb25lbnRzL2xpc3QvaW5kZXguanNcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9tZW51L21lbnUuanNcbmZ1bmN0aW9uIG1lbnVfbWVudV9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBtZW51X21lbnVfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG1lbnVfbWVudV9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IG1lbnVfbWVudV9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBtZW51X21lbnVfb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG1lbnVfbWVudV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIG1lbnVfbWVudV9leHRlbmRzKCkgeyBtZW51X21lbnVfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBtZW51X21lbnVfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIG1lbnVfbWVudV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gbWVudV9tZW51X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBtZW51X21lbnVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxuXG52YXIgbWVudV9NZW51ID0gZnVuY3Rpb24gTWVudShfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gbWVudV9tZW51X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgbWVudV9tZW51X2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnbWVudScsIGNsYXNzTmFtZSlcbiAgfSkpO1xufTtcblxubWVudV9NZW51Lkxpc3QgPSBjb21wb25lbnRzX2xpc3RfbGlzdDtcbm1lbnVfTWVudS5wcm9wVHlwZXMgPSBtZW51X21lbnVfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICByZW5kZXJBczogcmVuZGVyX2FzXG59KTtcbm1lbnVfTWVudS5kZWZhdWx0UHJvcHMgPSBtZW51X21lbnVfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2FzaWRlJ1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX21lbnVfbWVudSA9IChtZW51X01lbnUpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9tZW51L2luZGV4LmpzXG5cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2UvbWVzc2FnZS5zYXNzXG52YXIgbWVzc2FnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2UvY29tcG9uZW50cy9ib2R5LmpzXG5mdW5jdGlvbiBjb21wb25lbnRzX2JvZHlfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19ib2R5X29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBjb21wb25lbnRzX2JvZHlfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjb21wb25lbnRzX2JvZHlfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgY29tcG9uZW50c19ib2R5X293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2JvZHlfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2JvZHlfZXh0ZW5kcygpIHsgY29tcG9uZW50c19ib2R5X2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gY29tcG9uZW50c19ib2R5X2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2JvZHlfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IGNvbXBvbmVudHNfYm9keV9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19ib2R5X29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBib2R5X01lc3NhZ2VCb2R5ID0gZnVuY3Rpb24gTWVzc2FnZUJvZHkoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGNvbXBvbmVudHNfYm9keV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgY29tcG9uZW50c19ib2R5X2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgnbWVzc2FnZS1ib2R5JywgY2xhc3NOYW1lKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuYm9keV9NZXNzYWdlQm9keS5wcm9wVHlwZXMgPSBjb21wb25lbnRzX2JvZHlfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hc1xufSk7XG5ib2R5X01lc3NhZ2VCb2R5LmRlZmF1bHRQcm9wcyA9IGNvbXBvbmVudHNfYm9keV9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19ib2R5ID0gKGJvZHlfTWVzc2FnZUJvZHkpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlL2NvbXBvbmVudHMvaGVhZGVyLmpzXG5mdW5jdGlvbiBjb21wb25lbnRzX2hlYWRlcl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2hlYWRlcl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgY29tcG9uZW50c19oZWFkZXJfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBjb21wb25lbnRzX2hlYWRlcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBjb21wb25lbnRzX2hlYWRlcl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19oZWFkZXJfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2hlYWRlcl9leHRlbmRzKCkgeyBjb21wb25lbnRzX2hlYWRlcl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGNvbXBvbmVudHNfaGVhZGVyX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX2hlYWRlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gY29tcG9uZW50c19oZWFkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfaGVhZGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBoZWFkZXJfTWVzc2FnZUhlYWRlciA9IGZ1bmN0aW9uIE1lc3NhZ2VIZWFkZXIoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGNvbXBvbmVudHNfaGVhZGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBjb21wb25lbnRzX2hlYWRlcl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ21lc3NhZ2UtaGVhZGVyJywgY2xhc3NOYW1lKVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuaGVhZGVyX01lc3NhZ2VIZWFkZXIucHJvcFR5cGVzID0gY29tcG9uZW50c19oZWFkZXJfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNoaWxkcmVuOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ub2RlLFxuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hc1xufSk7XG5oZWFkZXJfTWVzc2FnZUhlYWRlci5kZWZhdWx0UHJvcHMgPSBjb21wb25lbnRzX2hlYWRlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2Rpdidcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19oZWFkZXIgPSAoaGVhZGVyX01lc3NhZ2VIZWFkZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlL21lc3NhZ2UuanNcbmZ1bmN0aW9uIG1lc3NhZ2Vfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gbWVzc2FnZV9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbWVzc2FnZV9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IG1lc3NhZ2VfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgbWVzc2FnZV9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbWVzc2FnZV9leHRlbmRzKCkgeyBtZXNzYWdlX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gbWVzc2FnZV9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gbWVzc2FnZV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIG1lc3NhZ2Vfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IG1lc3NhZ2Vfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG1lc3NhZ2Vfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBtZXNzYWdlX2NvbG9ycyA9IFtudWxsXS5jb25jYXQoT2JqZWN0LmtleXMoY29uc3RhbnRzLkNPTE9SUykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGNvbnN0YW50cy5DT0xPUlNba2V5XTtcbn0pKTtcblxudmFyIG1lc3NhZ2VfTWVzc2FnZSA9IGZ1bmN0aW9uIE1lc3NhZ2UoX3JlZikge1xuICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHByb3BzID0gbWVzc2FnZV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImNvbG9yXCIsIFwic2l6ZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgbWVzc2FnZV9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ21lc3NhZ2UnLCBjbGFzc05hbWUsIChfY2xhc3NuYW1lcyA9IHt9LCBtZXNzYWdlX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBcImlzLVwiLmNvbmNhdChjb2xvciksIGNvbG9yKSwgbWVzc2FnZV9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJpcy1cIi5jb25jYXQoc2l6ZSksIHNpemUpLCBfY2xhc3NuYW1lcykpXG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG5tZXNzYWdlX01lc3NhZ2UuQm9keSA9IGNvbXBvbmVudHNfYm9keTtcbm1lc3NhZ2VfTWVzc2FnZS5IZWFkZXIgPSBjb21wb25lbnRzX2hlYWRlcjtcbm1lc3NhZ2VfTWVzc2FnZS5wcm9wVHlwZXMgPSBtZXNzYWdlX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjaGlsZHJlbjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEubm9kZSxcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHN0eWxlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zaGFwZSh7fSksXG4gIHJlbmRlckFzOiByZW5kZXJfYXMsXG4gIHNpemU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJ10pLFxuICBjb2xvcjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YobWVzc2FnZV9jb2xvcnMpXG59KTtcbm1lc3NhZ2VfTWVzc2FnZS5kZWZhdWx0UHJvcHMgPSBtZXNzYWdlX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHN0eWxlOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnYXJ0aWNsZScsXG4gIGNvbG9yOiB1bmRlZmluZWQsXG4gIHNpemU6IHVuZGVmaW5lZFxufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtZXNzYWdlX21lc3NhZ2UgPSAobWVzc2FnZV9NZXNzYWdlKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZS9pbmRleC5qc1xuXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wYW5lbC9wYW5lbC5zYXNzXG52YXIgcGFuZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wYW5lbC9jb21wb25lbnRzL2Jsb2NrLmpzXG5mdW5jdGlvbiBibG9ja19vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBibG9ja19vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgYmxvY2tfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBibG9ja19kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBibG9ja19vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gYmxvY2tfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBibG9ja19leHRlbmRzKCkgeyBibG9ja19leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGJsb2NrX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBibG9ja19vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gYmxvY2tfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGJsb2NrX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBibG9ja19QYW5lbEJsb2NrID0gZnVuY3Rpb24gUGFuZWxCbG9jayhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGFjdGl2ZSA9IF9yZWYuYWN0aXZlLFxuICAgICAgcHJvcHMgPSBibG9ja19vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIiwgXCJhY3RpdmVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGJsb2NrX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzX2RlZmF1bHQoKSgncGFuZWwtYmxvY2snLCBjbGFzc05hbWUsIHtcbiAgICAgICdpcy1hY3RpdmUnOiBhY3RpdmVcbiAgICB9KVxuICB9KSk7XG59O1xuXG5ibG9ja19QYW5lbEJsb2NrLnByb3BUeXBlcyA9IGJsb2NrX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLnByb3BUeXBlcywge1xuICBjbGFzc05hbWU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLnN0cmluZyxcbiAgcmVuZGVyQXM6IHJlbmRlcl9hcyxcbiAgYWN0aXZlOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5ib29sXG59KTtcbmJsb2NrX1BhbmVsQmxvY2suZGVmYXVsdFByb3BzID0gYmxvY2tfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ2RpdicsXG4gIGFjdGl2ZTogZmFsc2Vcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYmxvY2sgPSAoYmxvY2tfUGFuZWxCbG9jayk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3BhbmVsL2NvbXBvbmVudHMvaGVhZGVyLmpzXG5mdW5jdGlvbiBwYW5lbF9jb21wb25lbnRzX2hlYWRlcl9vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBwYW5lbF9jb21wb25lbnRzX2hlYWRlcl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgcGFuZWxfY29tcG9uZW50c19oZWFkZXJfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBwYW5lbF9jb21wb25lbnRzX2hlYWRlcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBwYW5lbF9jb21wb25lbnRzX2hlYWRlcl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcGFuZWxfY29tcG9uZW50c19oZWFkZXJfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBwYW5lbF9jb21wb25lbnRzX2hlYWRlcl9leHRlbmRzKCkgeyBwYW5lbF9jb21wb25lbnRzX2hlYWRlcl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIHBhbmVsX2NvbXBvbmVudHNfaGVhZGVyX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBwYW5lbF9jb21wb25lbnRzX2hlYWRlcl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gcGFuZWxfY29tcG9uZW50c19oZWFkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIHBhbmVsX2NvbXBvbmVudHNfaGVhZGVyX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cbnZhciBoZWFkZXJfUGFuZWxIZWFkZXIgPSBmdW5jdGlvbiBQYW5lbEhlYWRlcihfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gcGFuZWxfY29tcG9uZW50c19oZWFkZXJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCBwYW5lbF9jb21wb25lbnRzX2hlYWRlcl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ3BhbmVsLWhlYWRpbmcnLCBjbGFzc05hbWUpXG4gIH0pKTtcbn07XG5cbmhlYWRlcl9QYW5lbEhlYWRlci5wcm9wVHlwZXMgPSBwYW5lbF9jb21wb25lbnRzX2hlYWRlcl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuaGVhZGVyX1BhbmVsSGVhZGVyLmRlZmF1bHRQcm9wcyA9IHBhbmVsX2NvbXBvbmVudHNfaGVhZGVyX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHBhbmVsX2NvbXBvbmVudHNfaGVhZGVyID0gKGhlYWRlcl9QYW5lbEhlYWRlcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3BhbmVsL2NvbXBvbmVudHMvaWNvbi5qc1xuZnVuY3Rpb24gY29tcG9uZW50c19pY29uX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfaWNvbl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgY29tcG9uZW50c19pY29uX293bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgY29tcG9uZW50c19pY29uX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGNvbXBvbmVudHNfaWNvbl9vd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19pY29uX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19pY29uX2V4dGVuZHMoKSB7IGNvbXBvbmVudHNfaWNvbl9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIGNvbXBvbmVudHNfaWNvbl9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c19pY29uX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBjb21wb25lbnRzX2ljb25fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfaWNvbl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuXG52YXIgaWNvbl9QYW5lbEljb24gPSBmdW5jdGlvbiBQYW5lbEljb24oX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IGNvbXBvbmVudHNfaWNvbl9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiBleHRlcm5hbF9yZWFjdF9kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChjb21wb25lbnRzX2VsZW1lbnQsIGNvbXBvbmVudHNfaWNvbl9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lc19kZWZhdWx0KCkoJ3BhbmVsLWljb24nLCBjbGFzc05hbWUpXG4gIH0pKTtcbn07XG5cbmljb25fUGFuZWxJY29uLnByb3BUeXBlcyA9IGNvbXBvbmVudHNfaWNvbl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xuaWNvbl9QYW5lbEljb24uZGVmYXVsdFByb3BzID0gY29tcG9uZW50c19pY29uX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdzcGFuJ1xufSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX2ljb24gPSAoaWNvbl9QYW5lbEljb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wYW5lbC9jb21wb25lbnRzL3RhYnMvY29tcG9uZW50cy90YWIuanNcbmZ1bmN0aW9uIGNvbXBvbmVudHNfdGFiX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfdGFiX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBjb21wb25lbnRzX3RhYl9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGNvbXBvbmVudHNfdGFiX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IGNvbXBvbmVudHNfdGFiX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjb21wb25lbnRzX3RhYl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHRhYl9leHRlbmRzKCkgeyB0YWJfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiB0YWJfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNfdGFiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBjb21wb25lbnRzX3RhYl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY29tcG9uZW50c190YWJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxudmFyIHRhYl9QYW5lbFRhYnNUYWIgPSBmdW5jdGlvbiBQYW5lbFRhYnNUYWIoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmUgPSBfcmVmLmFjdGl2ZSxcbiAgICAgIHByb3BzID0gY29tcG9uZW50c190YWJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCIsIFwiYWN0aXZlXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCB0YWJfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKGNsYXNzTmFtZSwge1xuICAgICAgJ2lzLWFjdGl2ZSc6IGFjdGl2ZVxuICAgIH0pXG4gIH0pKTtcbn07XG5cbnRhYl9QYW5lbFRhYnNUYWIucHJvcFR5cGVzID0gY29tcG9uZW50c190YWJfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICByZW5kZXJBczogcmVuZGVyX2FzLFxuICBhY3RpdmU6IGV4dGVybmFsX3Byb3BfdHlwZXNfZGVmYXVsdC5hLmJvb2xcbn0pO1xudGFiX1BhbmVsVGFic1RhYi5kZWZhdWx0UHJvcHMgPSBjb21wb25lbnRzX3RhYl9vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5kZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIHJlbmRlckFzOiAnYScsXG4gIGFjdGl2ZTogZmFsc2Vcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c190YWIgPSAodGFiX1BhbmVsVGFic1RhYik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3BhbmVsL2NvbXBvbmVudHMvdGFicy90YWJzLmpzXG5mdW5jdGlvbiB0YWJzX3RhYnNfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gdGFic190YWJzX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyB0YWJzX3RhYnNfb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyB0YWJzX3RhYnNfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgdGFic190YWJzX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiB0YWJzX3RhYnNfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiB0YWJzX3RhYnNfZXh0ZW5kcygpIHsgdGFic190YWJzX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gdGFic190YWJzX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiB0YWJzX3RhYnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHRhYnNfdGFic19vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gdGFic190YWJzX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG5cblxudmFyIHRhYnNfUGFuZWxUYWJzID0gZnVuY3Rpb24gUGFuZWxUYWJzKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcHJvcHMgPSB0YWJzX3RhYnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gZXh0ZXJuYWxfcmVhY3RfZGVmYXVsdC5hLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c19lbGVtZW50LCB0YWJzX3RhYnNfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdwYW5lbC10YWJzJywgY2xhc3NOYW1lKVxuICB9KSk7XG59O1xuXG50YWJzX1BhbmVsVGFicy5UYWIgPSBjb21wb25lbnRzX3RhYjtcbnRhYnNfUGFuZWxUYWJzLnByb3BUeXBlcyA9IHRhYnNfdGFic19vYmplY3RTcHJlYWQoe30sIG1vZGlmaWVycy5wcm9wVHlwZXMsIHtcbiAgY2xhc3NOYW1lOiBleHRlcm5hbF9wcm9wX3R5cGVzX2RlZmF1bHQuYS5zdHJpbmcsXG4gIHJlbmRlckFzOiByZW5kZXJfYXNcbn0pO1xudGFic19QYW5lbFRhYnMuZGVmYXVsdFByb3BzID0gdGFic190YWJzX29iamVjdFNwcmVhZCh7fSwgbW9kaWZpZXJzLmRlZmF1bHRQcm9wcywge1xuICBjbGFzc05hbWU6IHVuZGVmaW5lZCxcbiAgcmVuZGVyQXM6ICdkaXYnXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfdGFic190YWJzID0gKHRhYnNfUGFuZWxUYWJzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcGFuZWwvY29tcG9uZW50cy90YWJzL2luZGV4LmpzXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcGFuZWwvcGFuZWwuanNcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSB9XG5cbmZ1bmN0aW9uIHBhbmVsX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIHBhbmVsX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBwYW5lbF9vd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHBhbmVsX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IHBhbmVsX293bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBwYW5lbF9leHRlbmRzKCkgeyBwYW5lbF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIHBhbmVsX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBwYW5lbF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHBhbmVsX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBwYW5lbF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcGFuZWxfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwYW5lbF9QYW5lbCA9IGZ1bmN0aW9uIFBhbmVsKF9yZWYpIHtcbiAgdmFyIGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcHJvcHMgPSBwYW5lbF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjb2xvclwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIGV4dGVybmFsX3JlYWN0X2RlZmF1bHQuYS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNfZWxlbWVudCwgcGFuZWxfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXNfZGVmYXVsdCgpKCdwYW5lbCcsIGNsYXNzTmFtZSwgcGFuZWxfZGVmaW5lUHJvcGVydHkoe30sIFwiaXMtXCIuY29uY2F0KGNvbG9yKSwgY29sb3IpKVxuICB9KSk7XG59O1xuXG5wYW5lbF9QYW5lbC5IZWFkZXIgPSBwYW5lbF9jb21wb25lbnRzX2hlYWRlcjtcbnBhbmVsX1BhbmVsLlRhYnMgPSBjb21wb25lbnRzX3RhYnNfdGFicztcbnBhbmVsX1BhbmVsLkJsb2NrID0gYmxvY2s7XG5wYW5lbF9QYW5lbC5JY29uID0gY29tcG9uZW50c19pY29uO1xucGFuZWxfUGFuZWwucHJvcFR5cGVzID0gcGFuZWxfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMucHJvcFR5cGVzLCB7XG4gIGNsYXNzTmFtZTogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEuc3RyaW5nLFxuICByZW5kZXJBczogcmVuZGVyX2FzLFxuICBjb2xvcjogZXh0ZXJuYWxfcHJvcF90eXBlc19kZWZhdWx0LmEub25lT2YoW251bGwsICcnXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC52YWx1ZXMoY29uc3RhbnRzLkNPTE9SUykpKSlcbn0pO1xucGFuZWxfUGFuZWwuZGVmYXVsdFByb3BzID0gcGFuZWxfb2JqZWN0U3ByZWFkKHt9LCBtb2RpZmllcnMuZGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICByZW5kZXJBczogJ25hdicsXG4gIGNvbG9yOiB1bmRlZmluZWRcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGFuZWxfcGFuZWwgPSAocGFuZWxfUGFuZWwpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wYW5lbC9pbmRleC5qc1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2luZGV4LmpzXG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IEJveCAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkJveFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBvbmVudHNfYm94OyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgQnV0dG9uICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQnV0dG9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29tcG9uZW50c19idXR0b25fYnV0dG9uOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgQnJlYWRjcnVtYiAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkJyZWFkY3J1bWJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wb25lbnRzX2JyZWFkY3J1bWI7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBDYXJkICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ2FyZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhcmRfY2FyZDsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IENvbHVtbnMgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDb2x1bW5zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29tcG9uZW50c19jb2x1bW5zOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgQ29udGFpbmVyICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ29udGFpbmVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udGFpbmVyX2NvbnRhaW5lcjsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IENvbnRlbnQgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDb250ZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29tcG9uZW50c19jb250ZW50X2NvbnRlbnQ7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBGb290ZXIgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJGb290ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wb25lbnRzX2Zvb3Rlcl9mb290ZXI7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBGb3JtICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRm9ybVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBvbmVudHNfZm9ybV9uYW1lc3BhY2VPYmplY3Q7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBIZWFkaW5nICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiSGVhZGluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBvbmVudHNfaGVhZGluZ19oZWFkaW5nOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgSGVybyAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkhlcm9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBoZXJvX2hlcm87IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBJbWFnZSAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkltYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1hZ2VfSW1hZ2U7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBMZXZlbCAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxldmVsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbGV2ZWxfbGV2ZWw7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBMaXN0ICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTGlzdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBvbmVudHNfbGlzdDsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IE1lZGlhICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTWVkaWFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZWRpYV9tZWRpYTsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IE5vdGlmaWNhdGlvbiAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIk5vdGlmaWNhdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBvbmVudHNfbm90aWZpY2F0aW9uX25vdGlmaWNhdGlvbjsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IFByb2dyZXNzICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUHJvZ3Jlc3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwcm9ncmVzc19wcm9ncmVzczsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IFNlY3Rpb24gKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTZWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VjdGlvbl9zZWN0aW9uOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgVGFibGUgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUYWJsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRhYmxlX3RhYmxlOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgVGFnICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGFnX3RhZzsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IFRpbGUgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUaWxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGlsZV90aWxlOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgTW9kYWwgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJNb2RhbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1vZGFsX21vZGFsOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgRHJvcGRvd24gKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJEcm9wZG93blwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRyb3Bkb3duX0Ryb3Bkb3duOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgSWNvbiAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkljb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wb25lbnRzX2ljb25faWNvbjsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IExvYWRlciAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxvYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvYWRlcl9sb2FkZXI7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBOYXZiYXIgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJOYXZiYXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wb25lbnRzX25hdmJhcjsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0IFRhYnMgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUYWJzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGFic190YWJzOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgUGFnaW5hdGlvbiAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlBhZ2luYXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYWdpbmF0aW9uX1BhZ2luYXRpb247IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBNZW51ICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTWVudVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBvbmVudHNfbWVudV9tZW51OyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgTWVzc2FnZSAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIk1lc3NhZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlX21lc3NhZ2U7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBQYW5lbCAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlBhbmVsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFuZWxfcGFuZWw7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCBFbGVtZW50ICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRWxlbWVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBvbmVudHNfZWxlbWVudDsgfSk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIvVXNlcnMvam9zZXBoZGFtaWJhL0Rvd25sb2Fkcy9jb2RlL3dvcmsvcGxvdGx5L2Rhc2gtY29tcG9uZW50cy9teV9kYXNoX2NvbXBvbmVudC9ub2RlX21vZHVsZXMvcmVhY3QtYnVsbWEtY29tcG9uZW50c1wiXG5cbmNsYXNzIFRvZ2dsZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge2lzVG9nZ2xlT246IHRydWUsIGNvdW50ZXI6IDB9O1xuXG4gICAgICAgIC8vIFRoaXMgYmluZGluZyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBgdGhpc2Agd29yayBpbiB0aGUgY2FsbGJhY2tcbiAgICAgICAgdGhpcy5oYW5kbGVDbGljayA9IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUgPT4gKHtcbiAgICAgICAgICBpc1RvZ2dsZU9uOiAhc3RhdGUuaXNUb2dnbGVPbixcbiAgICAgICAgICBjb3VudGVyOiBzdGF0ZS5jb3VudGVyICsgMVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge2lkLCBsYWJlbCwgc2V0UHJvcHMsIHZhbHVlfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICA8cD57bGFiZWx9PC9wPlxuICAgICAgICAgIDxCdXR0b24gY2xhc3NOYW1lPVwiYnV0dG9uXCIgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gICAgICAgICAgICB7dGhpcy5zdGF0ZS5pc1RvZ2dsZU9uID8gJ09OJyA6ICdPRkYnfVxuICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgIDxwPnt0aGlzLnN0YXRlLmNvdW50ZXJ9PC9wPlxuICAgICAgICAgIDwvPlxuICAgICAgICApO1xuICAgICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb2dnbGU7XG5cblRvZ2dsZS5kZWZhdWx0UHJvcHMgPSB7fTtcblxuVG9nZ2xlLnByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGNvbXBvbmVudCBpbiBEYXNoIGNhbGxiYWNrcy5cbiAgICAgKi9cbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIEEgbGFiZWwgdGhhdCB3aWxsIGJlIHByaW50ZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGRpc3BsYXllZCBpbiB0aGUgaW5wdXQuXG4gICAgICovXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBEYXNoLWFzc2lnbmVkIGNhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB0byByZXBvcnQgcHJvcGVydHkgY2hhbmdlc1xuICAgICAqIHRvIERhc2gsIHRvIG1ha2UgdGhlbSBhdmFpbGFibGUgZm9yIGNhbGxiYWNrcy5cbiAgICAgKi9cbiAgICBzZXRQcm9wczogUHJvcFR5cGVzLmZ1bmNcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9